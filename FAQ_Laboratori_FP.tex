% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={FAQ Laboratori de Fonaments de Programació},
  pdfauthor={Jordi Blasco Planesas},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother


\usepackage{listings,xcolor,fontspec}
\definecolor{bluekeywords}{rgb}{0.13,0.13,1}
\definecolor{greencomments}{rgb}{0,0.5,0}
\definecolor{turqusnumbers}{rgb}{0.17,0.57,0.69}
\definecolor{redstrings}{rgb}{0.5,0,0}
\lstdefinelanguage{alg}
    {morekeywords={algorithm, type, end, var, if, else, while, for, and, or, function, action},
    alsoletter={\\{,\\}}
    keywordstyle=\bfseries,
    keywordstyle=\color{bluekeywords},
    sensitive=false,
    morecomment=[l][\color{greencomments}]{//},
    morestring=[b]",
    stringstyle=\color{redstrings},
    literate={\\}{}1
    }
\lstnewenvironment{algorisme}
  {
    \lstset{
        language=alg,
        basicstyle=\ttfamily,
        breaklines=true,
        columns=fullflexible
        }
  }
  {
  }




\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{FAQ Laboratori de Fonaments de Programació}
\author{Jordi Blasco Planesas}
\date{2020-06-08}

\begin{document}
\frontmatter
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\mainmatter
\hypertarget{introducciuxf3}{%
\chapter*{Introducció}\label{introducciuxf3}}
\addcontentsline{toc}{chapter}{Introducció}

El present recurs és un recopilatori de qüestions plantejades al \textbf{Laboratori de Fonaments de Programació} durant els últims semestres.

Les \textbf{FAQ} poden donar resposta a dubtes i errors habituals en el moment d'iniciar-nos en el món de la programació. També es poden utilitzar com a material complementari a la teoria explicada a la \textbf{xWiki} de \textbf{Fonaments de Programació}.

La lectura de les FAQ no cal realitzar-la seqüencialment: cada apartat respon a una consulta o conjunt de consultes, sense relació necessària entre elles.

El fil conductor són les \textbf{PAC} : les diferents respostes donades al \textbf{Laboratori de Fonaments de Programació} s'han agrupat en PAC segons el moment en que es van produïr. Això no significa que una resposta d'una PAC anterior o posterior a la que estiguem tractant, no ens pugui ser d'utilitat.

Donada aquesta independència de contingut és recomanable utilitzar el cercador del portal: per exemple, si volem cercar consultes on s'hagi tractat \texttt{strlen}, simplement posem aquesta comanda al cercador i obtindrem la relació d'entrades que la contenen.

És possible descarregar una versió en PDF/EPUB de totes les FAQ, des del botó de descàrrega de la part superior.

La documentació utilitza les següents icones per referenciar els blocs:

\includegraphics{./img/alg.png} Indica que el codi mostrat està en \textbf{llenguatge algorísmic} i és \textbf{correcte}.

\includegraphics{./img/alg_err.png} Indica que el codi mostrat està en \textbf{llenguatge algorísmic} i és \textbf{incorrecte}, conté algun error.

\includegraphics{./img/c.png} Indica que el codi mostrat està en \textbf{llenguatge C} i és \textbf{correcte}.

\includegraphics{./img/c_err.png} Indica que el codi mostrat està en \textbf{llenguatge C} i és \textbf{incorrecte}, conté algun error.

\includegraphics{./img/play.png} Mostra l'execució d'un programa en \textbf{llenguatge C}.

\hypertarget{pac01}{%
\chapter{PAC01}\label{pac01}}

\hypertarget{llenguatge-algoruxedsmic}{%
\section{Llenguatge algorísmic}\label{llenguatge-algoruxedsmic}}

El llenguatge algorísmic l'hem d'entendre com una aproximació al món real, el qual utilitza unes normes definides per nosaltres mateixos. En aquest punt encara no parlem de programes escrits en \textbf{C}, en \textbf{Java}, en \textbf{Python} o en \textbf{PHP}, per dir alguns llenguatges de programació.

Per exemple, en el llenguatge algorísmic que utilitzem a l'assignatura definim un bloc de variables de la següent forma:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    edat: integer;
    pes: real;
end var
\end{verbatim}

Que es tracti d'un llenguatge més proper al món real no significa que no s'hagin de complir unes determinades regles. Com es pot veure en aquest exemple, una d'aquestes regles és que quan definim variables ho precedim amb \texttt{var} i ho finalitzem amb \texttt{end\ var}.

Hem decidit utilitzar aquesta forma de llenguatge algorísmic, tot i que també ho podríem haver plantejat de la següent forma :

\includegraphics{./img/alg_err.png}

\begin{verbatim}
variable
    enter edat
    decimal pes
fvariable
\end{verbatim}

Remarcar que aquest segon exemple \textbf{és incorrecte}, no segueix la nomenclatura del llenguatge algorísmic definit a l'assignatura. El correcte és el primer exemple.

El llenguatge algorísmic és com fer una aproximació formal a la realitat, no és un llenguatge de programació en sí com és \textbf{C}, \textbf{Java} o similars. Per tant no és un llenguatge que es pugui compilar i executar amb l'IDE utilitzat a l'assignatura, el qual està preparat únicament per interpretar i executar codi programat en llenguatge C.

Ara bé la gran pregunta: i per què és necessari primer dissenyar l'algorisme, si puc directament programar-ho en C?

Un algorisme ens permet dissenyar un programa sense tenir presents les particularitats de cada llenguatge de programació. Aquesta aproximació formal a la realitat dels algorismes ens faciliten poder fer posteriorment una traducció ràpida a qualsevol llenguatge de programació simplement coneixent les equivalències corresponents. Per exemple, el primer cas si el programem en C equival a:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ edat;}
\DataTypeTok{float}\NormalTok{ pes;}
\end{Highlighting}
\end{Shaded}

El codi en C no el podem canviar, ja que si en comptes de posar \texttt{int} utilitzem \texttt{enter}, el compilador de C no comprèn el mot i ens donarà un error de codi.

Si mai hem programat és normal que aquest plantejament sobti al principi, però és important que poc a poc es vagi veient les diferències entre llenguatge algorísmic i llenguatge C.

\hypertarget{llenguatge-algoruxedsmic-vs-llenguatge-c}{%
\section{Llenguatge algorísmic vs llenguatge C}\label{llenguatge-algoruxedsmic-vs-llenguatge-c}}

En general:

\begin{itemize}
\tightlist
\item
  \textbf{Llenguatge algorísmic}: proper al llenguatge natural, es tracta d'una convenció que adoptem nosaltres mateixos per definir el un programa formalment. Els algorismes tenen una sèrie de normes i sentències que nosaltres definim (\textbf{Nomenclàtor}), però que no són de cap forma interpretables per un ordinador. Per tant un algorisme \textbf{no pot ser compilat ni executat}.
\item
  \textbf{Llenguatge C}: es tracta d'un llenguatge de programació que sí comprèn un ordinador. Això significa que únicament podem utilitzar les seves comandes i les seves normes per tal que el codi pugui ser compilat i executat sense problemes.
\end{itemize}

El llenguatge algorísmic és un pseudocodi que ens ajuda a definir com funciona un programa. No està lligat a cap llenguatge de programació, amb el que les accions que realitzarà, la forma de definir variables, etc. és genèrica. Funcions com \texttt{writeString()}, \texttt{readInteger()} o \texttt{writeChar()} formen part del llenguatge algorísmic: indiquen una acció genèrica a realitzar, com és escriure una cadena de caracters, llegir un enter o escriure un caràcter. Quan es vulgui codificar aquest algorisme en un llenguatge de programació concret com és C, només caldrà saber les comandes pròpies de C que ens permeten implementar l'algorisme.

La programació en C funciona exclusivament amb la sintaxi definida per aquest llenguatge de programació. Instruccions com \texttt{scanf()} i \texttt{printf()} són pròpies de C.

A mode d'exemple:

\textbf{Algorisme}: volem introduïr la lectura de la llum de casa nostra; una possible implementació és:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm lecturaLlum
    var
        lecturaMensual: integer;
    end var

    writeString("Introdueix la lectura mensual de la llum (kWh): ");
    lecturaMensual := readInteger();
end algorithm
\end{verbatim}

\textbf{Llenguatge C}: en aquest llenguatge no existeixen les funcions algorísmiques \texttt{writeString()} ni \texttt{readInteger()}, però en canvi sí que tenim vàries funcions pròpies de C que ens permeten llegir un valor per teclat i assignar-lo a una variable d'entorn. Per tant, les accions algorísmiques anteriors correspondran a la següent codificació en C:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{ }
    \DataTypeTok{int}\NormalTok{ lecturaMensual;}

\NormalTok{    printf(}\StringTok{"Introdueix la lectura mensual de la llum (kWh): "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&lecturaMensual);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

És molt important que es vegi clarament què és un \textbf{algorisme} i què és un \textbf{programa en C}.

\hypertarget{equivaluxe8ncies-llenguatge-algoruxedsmic-vs-llenguatge-c}{%
\section{Equivalències llenguatge algorísmic vs llenguatge C}\label{equivaluxe8ncies-llenguatge-algoruxedsmic-vs-llenguatge-c}}

A continuació s'indiquen algunes de les equivalències existents entre llenguatge algorísmic i el llenguatge de programació C:

\begin{longtable}[]{@{}lcc@{}}
\toprule
& Llenguatge algorísmic & Llenguatge C\tabularnewline
\midrule
\endhead
Segueix unes normes? & sí & sí\tabularnewline
Es pot compilar? & no & sí\tabularnewline
Es pot executar? & no & sí\tabularnewline
Assignació de valors a variables & \texttt{:=} & \texttt{=}\tabularnewline
Tipus booleà & \texttt{boolean} & \texttt{bool}\tabularnewline
Tipus enter & \texttt{integer} & \texttt{int}\tabularnewline
Tipus decimal & \texttt{real} & \texttt{float}\tabularnewline
Tipus caràcter & \texttt{char} & \texttt{char}\tabularnewline
Operador igual & \texttt{=} & \texttt{==}\tabularnewline
Operador diferent & \texttt{≠} & \texttt{!=}\tabularnewline
Operador major & \texttt{\textgreater{}} & \texttt{\textgreater{}}\tabularnewline
Operador major o igual & \texttt{≥} & \texttt{\textgreater{}=}\tabularnewline
Operador menor & \texttt{\textless{}} & \texttt{\textless{}}\tabularnewline
Operador menor o igual & \texttt{≤} & \texttt{\textless{}=}\tabularnewline
Operador lògic de conjunció & \texttt{and} & \texttt{\&\&}\tabularnewline
Operador lògic de disjunció & \texttt{or} & \texttt{\textbar{}\textbar{}}\tabularnewline
Operador lògic de negació & \texttt{not} & \texttt{!}\tabularnewline
\bottomrule
\end{longtable}

\hypertarget{impressiuxf3-de-valors-incorrecta}{%
\section{Impressió de valors incorrecta}\label{impressiuxf3-de-valors-incorrecta}}

Quan es mostra per pantalla el contingut d'alguna variable amb \texttt{printf()} és important eliminar el prefix \texttt{\&} de la variable. Per exemple, si no ho fem tenim que:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv)\{}
    \DataTypeTok{int}\NormalTok{ idAvio;}

\NormalTok{    printf(}\StringTok{"Introdueix l\textquotesingle{}identificador d\textquotesingle{}avió : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&idAvio);}
    
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Has escollit l\textquotesingle{}avió amb id \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, \&idAvio);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El resultat de l'execució és:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix l\textquotesingle{}identificador d\textquotesingle{}avió : }\DecValTok{9}
\NormalTok{\textgreater{}\textgreater{} Has escollit l\textquotesingle{}avió amb id {-}}\DecValTok{1078693464}
\end{Highlighting}
\end{Shaded}

Per quin motiu obtenim el valor estrany en l'identificador d'avió? Quan fem referència a \texttt{\&idAvio} estem obtenint realment la posició de memòria on resideix la variable \texttt{idAvio}, no pas el valor de la variable. Per obtenir el seu valor cal eliminar de dins \texttt{printf()} el prefix \texttt{\&} de la variable \texttt{idAvio}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv)\{}
    \DataTypeTok{int}\NormalTok{ idAvio;}

\NormalTok{    printf(}\StringTok{"Introdueix l\textquotesingle{}identificador d\textquotesingle{}avió : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&idAvio);}
    
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Has escollit l\textquotesingle{}avió amb id \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, idAvio);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La sortida generada ara sí és correcta:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix l\textquotesingle{}identificador d\textquotesingle{}avió : }\DecValTok{9}
\NormalTok{\textgreater{}\textgreater{} Has escollit l\textquotesingle{}avió amb id }\DecValTok{9} 
\end{Highlighting}
\end{Shaded}

\hypertarget{com-definir-un-enumeratiu}{%
\section{Com definir un enumeratiu}\label{com-definir-un-enumeratiu}}

La definició d'un tipus enumeratiu en llenguatge algorísmic es fa de la següent forma:

\includegraphics{./img/alg.png}

\begin{verbatim}
type
    typeName = {VALUE1, VALUE2, VALUE3, ... , VALUEn};
end type
\end{verbatim}

Els elements \texttt{VALUE1}, \texttt{VALUE2}, \texttt{VALUE3}\ldots{} acaben sent constants, i el valor que de cadascun és:

\includegraphics{./img/alg.png}

\begin{verbatim}
VALUE1 = 0
VALUE2 = 1
VALUE3 = 2 
{ ... }
VALUEn = n-1
\end{verbatim}

Posteriorment no és possible fer un canvi de valor d'aquests elements de tipus enumeratiu.

\hypertarget{com-utilitzar-un-enumeratiu}{%
\section{Com utilitzar un enumeratiu}\label{com-utilitzar-un-enumeratiu}}

Una enumeració és una assignació d'un valor enter a la sèrie d'elements que s'hi ha definit, començant pel 0 i incrementant-se en 1 en cada element.

Per exemple, podem tenir la següent definició:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{MALE, FEMALE\} tGender;}
\end{Highlighting}
\end{Shaded}

Això significa que \texttt{MALE\ ==\ 0} i \texttt{FEMALE\ ==\ 1}. Si l'ordre de la definició s'hagués fet al revés, \texttt{\{FEMALE,\ MALE\}}, tindríem que \texttt{FEMALE\ ==\ 0} i \texttt{MALE\ ==\ 1}.

Una possible forma d'utilitzar els enumeratius es llegir un enter i comparar-lo amb l'element corresponent definit dins de l'\texttt{enum}, per tal de realitzar una acció o una altra. Una possible implementació en llenguatge C seria:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{MALE, FEMALE\} tGender;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tGender gender;}

\NormalTok{    printf(}\StringTok{"Type patient gender: 0 for MALE, 1 for FEMALE}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&gender);}

    \ControlFlowTok{if}\NormalTok{ (gender == MALE) \{}
\NormalTok{        printf(}\StringTok{"Patient gender MALE}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{if}\NormalTok{ (gender == FEMALE) \{}
\NormalTok{            printf(}\StringTok{"Patient gender FEMALE}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            printf(}\StringTok{"Incorrect option}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{especificador-dun-enumeratiu}{%
\section{Especificador d'un enumeratiu}\label{especificador-dun-enumeratiu}}

Els enumeratius en llenguatge C, \texttt{enum} utilitzen l'especificador \texttt{\%u}.

Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{PRIVAT, PUBLIC\} tTransport;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tTransport tipusTransport;}

\NormalTok{    printf(}\StringTok{"Amb quin tipus de transport et desplaces a la feina (0=privat, 1=públic) ? : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&tipusTransport);}
\NormalTok{    printf(}\StringTok{"Et desplaces a la feina amb transport (0=privat, 1=públic) : "}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"\%u}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, tipusTransport);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{lectura-de-caruxe0cters-en-c}{%
\section{Lectura de caràcters en C}\label{lectura-de-caruxe0cters-en-c}}

En el llenguatge C la lectura d'un \texttt{char} pot comportar-se de forma inadequada si prèviament el buffer d'entrada conté algun caràcter previ.

Imaginem que volem crear un programa molt senzill que donat un número de DNI i la seva lletra, ens concateni els dos valors i ho mostri per pantalla. Una possible forma d'implementar aquest programa en C seria:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ dniNum;    }\CommentTok{/* número del DNI */}
    \DataTypeTok{char}\NormalTok{ dniChar;  }\CommentTok{/* lletra del DNI */}

\NormalTok{    printf(}\StringTok{"Introdueix el número del DNI: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&dniNum);}
\NormalTok{    printf(}\StringTok{"Introdueix la lletra del DNI: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%c"}\NormalTok{, \&dniChar);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{El DNI introduit és: \%d{-}\%c}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, dniNum, dniChar);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Què passa si executem aquest codi? Que veiem que es comporta de forma incorrecta, ja que no ens arriba a demanar la lletra del DNI, mostrant directament el resultat:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix el número del DNI: }\DecValTok{12345678}
\NormalTok{Introdueix la lletra del DNI:}
\NormalTok{El DNI introduit és: }\DecValTok{12345678}\NormalTok{{-}}
\end{Highlighting}
\end{Shaded}

Quan teclegem el primer enter el que fem realment és introduir un número + un \texttt{intro} al final de tot. El número queda assignat a la variable \texttt{dni\_num}, i l'\texttt{intro} és llegit com un caràcter i s'assigna a la variable \texttt{dni\_char}. Per aquest motiu C interpreta que les dues variables ja tenen valor i finalitza el programa.

Com podem solucionar aquest comportament? Buidant l'\texttt{intro} del buffer d'entrada abans de llegir el caràcter, i una possible forma per fer-ho és amb la comanda \texttt{getchar()}. Aquesta comanda llegeix un caràcter del buffer d'entrada i el buida del buffer.

Per tant es pot corregir el programa anterior de la següent forma:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ dni\_num;    }\CommentTok{/* número del DNI */}
    \DataTypeTok{char}\NormalTok{ dni\_char;  }\CommentTok{/* lletra del DNI */}

\NormalTok{    printf(}\StringTok{"Introdueix el número del DNI: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&dni\_num);}
\NormalTok{    getchar();}
\NormalTok{    printf(}\StringTok{"Introdueix la lletra del DNI: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%c"}\NormalTok{, \&dni\_char);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{El DNI introduit és: \%d{-}\%c}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, dni\_num, dni\_char);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Si ara executem ja funcionarà com desitgem:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix el número del DNI: }\DecValTok{12345678}
\NormalTok{Introdueix la lletra del DNI: B}

\NormalTok{El DNI introduit és: }\DecValTok{12345678}\NormalTok{{-}B}
\end{Highlighting}
\end{Shaded}

En cas de necessitat, amb \texttt{getChar()} es pot guardar el caràcter del buffer en una variable, per tal de tractar-lo posteriorment:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{char}\NormalTok{ nomVariable;}
\NormalTok{nomVariable = getChar();}
\end{Highlighting}
\end{Shaded}

\hypertarget{lectura-de-float-en-c}{%
\section{Lectura de float en C}\label{lectura-de-float-en-c}}

El separador de valors decimals (tipus \texttt{float}) en C \textbf{és el punt}, no la coma. Per aquest motiu quan s'introdueix un valor decimal des de teclat sempre ho farem amb un punt:

Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{\}}
    \CommentTok{/* Variable que contindrà el pes d\textquotesingle{}una persona */}
    \DataTypeTok{float}\NormalTok{ pes;}

    \CommentTok{/* Lectura de la dada per teclat (el separador de decimals és un . ) */}
\NormalTok{    printf(}\StringTok{"Introdueix el pes (kg) d\textquotesingle{}una persona : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&pes);}

    \CommentTok{/* Es mostra el valor decimal per pantalla */}
\NormalTok{    printf(}\StringTok{"Has introduit el pes = \%.1f kg.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pes);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució serà:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix el pes (kg) d\textquotesingle{}una persona : }\FloatTok{79.440}
\NormalTok{Has introduit el pes = }\FloatTok{79.4}\NormalTok{ kg.}
\end{Highlighting}
\end{Shaded}

\hypertarget{frequently-made-mistakes}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes}}

\hypertarget{definiciuxf3-de-tipus-tipus-booleuxe0}{%
\subsection{Definició de tipus: tipus booleà}\label{definiciuxf3-de-tipus-tipus-booleuxe0}}

En llenguatge algorísmic, el tipus \texttt{boolean} és un tipus bàsic, i com a tal no cal definir-lo en un bloc \texttt{type}.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
type
    boolean = {FALSE, TRUE};
end type
var 
    myNum: integer;
    myBool: boolean;
end var
\end{verbatim}

Es poden declarar variables de tipus booleà directament, igual que si fos un enter, un real o un caràcter.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var 
    myNum: integer;
    myBool: boolean;
end var
\end{verbatim}

\hypertarget{estil-i-format-absuxe8ncia-destil-i-format-en-llenguatge-algoruxedsmic}{%
\subsection{Estil i format: absència d'estil i format en llenguatge algorísmic}\label{estil-i-format-absuxe8ncia-destil-i-format-en-llenguatge-algoruxedsmic}}

Aquest no és un error sintàctic o semàntic, sinó una mala pràctica de disseny i programació molt freqüent.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action readHotel(out room: integer, out price: real)
var
i: integer;
end var
writeString("Enter room:");
readInteger(room);
writeString("Enter price:");
readReal(totalPrice);
if(price>MAXPRICE) then
writeString("Invalid price");
end if
for i=1 to rooms do
writeString("Room: ");
writeInteger(i);
end for
end action
\end{verbatim}

En el cas del llenguatge algorísmic, les regles de format i d'estil són arbitràries i fixades per conveni, però cal seguir-les perquè sigui fàcil de llegir i revisar, de la mateixa forma que es fa quan es programa en C o altres llenguatges. En l'exemple anterior, no hi ha aplicada cap indentació i el pseudocodi és molt difícil de llegir. Fixeu-vos com canvia quan apliquem correctament unes mínimes regles.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{action readHotel(out room: }\DataTypeTok{integer}\NormalTok{, out price: }\DataTypeTok{real}\NormalTok{)}
    \KeywordTok{var}
\NormalTok{        i: }\DataTypeTok{integer}\NormalTok{;}
    \KeywordTok{end} \KeywordTok{var}
    
\NormalTok{    writeString("Enter room:");}
\NormalTok{    readInteger(room);}
\NormalTok{    writeString("Enter price:");}
\NormalTok{    readReal(totalPrice);}
    
    \KeywordTok{if}\NormalTok{ (price \textgreater{} MAXPRICE) }\KeywordTok{then}
\NormalTok{        writeString("Invalid price");}
    \KeywordTok{end} \KeywordTok{if}
    
    \KeywordTok{for}\NormalTok{ i:=}\DecValTok{1} \KeywordTok{to}\NormalTok{ rooms }\KeywordTok{do}
\NormalTok{        writeString("Room: ");}
\NormalTok{    writeInteger(i);}
    \KeywordTok{end} \KeywordTok{for}
\KeywordTok{end}\NormalTok{ action}
\end{Highlighting}
\end{Shaded}

Cal esmentar que les \textbf{indentacions} són especialment importants per la lectura dels programes, ja que permeten identificar ràpidament els blocs de codi, les funcions i accions, les estructures iteratives i alternatives, i la seva dependència jeràrquica. Per aquest motiu, l'ús d'indentacions en el pseudocodi es absolutament necessari.

\hypertarget{declaraciuxf3-de-variables-identificadors-no-permesos}{%
\subsection{Declaració de variables: identificadors no permesos}\label{declaraciuxf3-de-variables-identificadors-no-permesos}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    1Hotel_ID: integer;
    2Hotel_ID: integer;
end var
\end{verbatim}

El nom de les variables poden contenir números sempre i quan no estiguin a la primera posició. Utilitzarem el model \href{https://en.wikipedia.org/wiki/Camel_case}{camelCase} per definir el nom de les variables.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    hotelId1: integer;
    hotelId2: integer;
end var
\end{verbatim}

\hypertarget{declaraciuxf3-de-variables-operador-de-declaraciuxf3}{%
\subsection{Declaració de variables: operador de declaració}\label{declaraciuxf3-de-variables-operador-de-declaraciuxf3}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    id:= integer;
    brand:= string;
    name:= string;
end var
\end{verbatim}

El següent error podria semblar un error lleu, però és important respectar el \textbf{Nomenclator} i utilitzar els operadors correctament. En llenguatge algorísmic, l'operador de declaració de tipus és \texttt{:} i no \texttt{:=}, que és l'operador d'assignació de valor.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    id: integer;
    brand: string;
    name: string;
end var
\end{verbatim}

\hypertarget{pac02}{%
\chapter{PAC02}\label{pac02}}

\hypertarget{booleans-en-c}{%
\section{Booleans en C}\label{booleans-en-c}}

Alguns punts a considerar amb els booleans en C:

\begin{itemize}
\tightlist
\item
  Quan utilitzem el tipus \texttt{bool} de C ens cal importar la llibreria \texttt{\textless{}stdbool.h\textgreater{}}, ja que el tipus \texttt{bool} no es va definir a les primeres versions del llenguatge C.
\item
  Els valors que pot prendre una variable booleana en C són \texttt{false} i \texttt{true}. El llenguatge C tracta internament aquests valors com a enters: \texttt{false} correspon a \texttt{0} i \texttt{true} a \texttt{1}.
\item
  Quan vulguem introduïr el valor d'un booleà per teclat o bé mostrar-lo per pantalla, utilitzarem l'enter \texttt{0} per referir-nos a \texttt{false} i \texttt{1} per \texttt{true}.
\item
  L'especificador de tipus dels booleans és \texttt{\%d}.
\item
  Per mostrar el valor d'una variable booleana en C ho podem fer de la següent forma:

  \includegraphics{./img/c.png}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ isVocal;}
\NormalTok{printf(}\StringTok{"La lletra \%c és una vocal (0=false, 1=true) ? \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, lletra, isVocal);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Per llegir un booleà des de teclat, ho faríem de la següent forma:

  \includegraphics{./img/c.png}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ variable;}
\NormalTok{scanf(}\StringTok{"\%d"}\NormalTok{, \&variable);}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La lectura per teclat d'un booleà, feta tal i com s'indica al punt anterior, generarà un \emph{warning} del següent tipus: \texttt{warning:\ format\ \textquotesingle{}\%d\textquotesingle{}\ expects\ argument\ of\ type\ \textquotesingle{}int\ *\textquotesingle{},\ but\ argument\ 2\ has\ type\ \textquotesingle{}\_Bool\ *\textquotesingle{}\ {[}-Wformat={]}}. Aquest avís significa que estem utilitzant un especificador de tipus (\texttt{\%d}) diferent del que li correspondria al tipus \texttt{bool}, el qual treballa únicament amb 1 bit. Com que C no disposa de cap especificador de tipus que treballi només amb 1 bit, podem fer dues coses:

  \begin{itemize}
  \tightlist
  \item
    Utilitzar una variable auxiliar que ens ajudi a fer una conversió intermitja a \texttt{int}, per tal de transformar posteriorment el valor a \texttt{bool}:

    \includegraphics{./img/c.png}
  \end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{bool}\NormalTok{ variable;}
\DataTypeTok{int}\NormalTok{ aux;}
\NormalTok{scanf(}\StringTok{"\%d"}\NormalTok{, \&aux);}
\NormalTok{variable = aux;}
\end{Highlighting}
\end{Shaded}

  \begin{itemize}
  \tightlist
  \item
    Ignorar el warning d'aquesta situació específica: tot i l'avís, el programa es pot compilar i executar.
  \end{itemize}
\end{itemize}

\hypertarget{booleans-definits-com-a-enumeratius}{%
\section{Booleans definits com a enumeratius}\label{booleans-definits-com-a-enumeratius}}

En semestres anteriors de l'assignatura de \textbf{Fonaments de Programació}, s'utilitzava un \textbf{enumeratiu} per definir el tipus booleà:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{FALSE, TRUE\} boolean;}
\end{Highlighting}
\end{Shaded}

Aquesta forma de definir el tipus booleà és \textbf{obsoleta} i \textbf{no s'utilitza} aquest semestre; tal i com s'ha comentat a l'apartat \protect\hyperlink{booleans-en-c}{Booleans en C}, els booleans els definirem mitjançant la llibreria \texttt{\textless{}stdbool.h\textgreater{}}. Tingueu-ho present quan consulteu PAC\footnote{PAC: Prova d'Avaluació Continua}, PR\footnote{PR: Pràctica} i PS \footnote{PS: Prova de Síntesi} de semestres anteriors, en els quals s'utilitzava la nomenclatura ara obsoleta.

\hypertarget{constants-define-vs-const}{%
\section{Constants: define vs const}\label{constants-define-vs-const}}

La definició de constants tant es pot fer amb \texttt{define} com amb \texttt{const}. Tot i això, la forma de comportar-se d'aquestes dues opcions és completament diferent, si ve el resultat final és el mateix:

\begin{itemize}
\tightlist
\item
  \texttt{define}: quan utilitzem aquesta opció no es desa en cap posició de memòria el valor de la constant. El que es fa realment és que en els passos previs a la pròpia compilació del programa, el preprocessador substitueix totes les referencies del define pel valor indicat.
\end{itemize}

Per exemple, si tenim el següent programa amb una constant creada amb \texttt{define} :

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MIDA 8}

\DataTypeTok{char}\NormalTok{ lletres[] = \{}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ vertical, horitzontal;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* font: https://en.wikipedia.org/wiki/Chess */}
    \ControlFlowTok{for}\NormalTok{ (vertical=MIDA; vertical\textgreater{}=}\DecValTok{1}\NormalTok{; vertical{-}{-}) \{}
        \ControlFlowTok{for}\NormalTok{ (horitzontal=}\DecValTok{0}\NormalTok{; horitzontal\textless{}=MIDA{-}}\DecValTok{1}\NormalTok{; horitzontal++) \{}
\NormalTok{            printf(}\StringTok{"\%c\%d "}\NormalTok{, lletres[horitzontal], vertical);}
\NormalTok{        \}}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Abans de la compilació, el preprocessador entre altres accions elimina comentaris i substitueix totes les referències \texttt{MIDA} per \texttt{8}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{char}\NormalTok{ lletres[] = \{}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ vertical, horitzontal;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \ControlFlowTok{for}\NormalTok{ (vertical=}\DecValTok{8}\NormalTok{; vertical\textgreater{}=}\DecValTok{1}\NormalTok{; vertical{-}{-}) \{}
        \ControlFlowTok{for}\NormalTok{ (horitzontal=}\DecValTok{0}\NormalTok{; horitzontal\textless{}=}\DecValTok{8}\NormalTok{{-}}\DecValTok{1}\NormalTok{; horitzontal++) \{}
\NormalTok{            printf(}\StringTok{"\%c\%d "}\NormalTok{, lletres[horitzontal], vertical);}
\NormalTok{        \}}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Per tant la definició de constants amb \texttt{define} es comporta com si d'un \emph{``cercar-reemplaçar''} d'un processador de textos es tractés. No es desa cap constant en memòria, però per contra, el programa ocuparà una mica més per la substitució directa de referències que fa; la substitució la fa en tot el programa, no es pot limitar a un àmbit concret (per exemple només dins d'una funció).

\begin{itemize}
\tightlist
\item
  \texttt{const}: en aquest cas sí que es reserva una posició de memòria. En C es comporta igual com si fos una variable, però la qual únicament funciona en mode lectura: no li podem modificar el valor.
\end{itemize}

A més, \texttt{const} ens permet també dir quin tipus de valor tindrà la constant: si és de tipus \texttt{float}, \texttt{int}, \texttt{char}\ldots{} amb el que aquest fet ens dóna un punt addicional de control, ja que ens assegurem que el tipus de valor assignat serà el correcte pel programa.

Amb aquest tipus de definició de constant, l'exemple anterior quedaria de la següent forma:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ MIDA }\DecValTok{8}

\DataTypeTok{char}\NormalTok{ lletres[] = \{}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}b\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}c\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}d\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}f\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}g\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{\};}
\DataTypeTok{int}\NormalTok{ vertical, horitzontal;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* La constant MIDA està desada en memòria */}
\NormalTok{    printf(}\StringTok{"posició en memòria de la constant MIDA : \%p }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, \&MIDA);}
    \ControlFlowTok{for}\NormalTok{ (vertical=MIDA; vertical\textgreater{}=}\DecValTok{1}\NormalTok{; vertical{-}{-}) \{}
        \ControlFlowTok{for}\NormalTok{ (horitzontal=}\DecValTok{0}\NormalTok{; horitzontal\textless{}=MIDA{-}}\DecValTok{1}\NormalTok{; horitzontal++) \{}
\NormalTok{            printf(}\StringTok{"\%c\%d "}\NormalTok{, lletres[horitzontal], vertical);}
\NormalTok{        \}}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Com es pot veure, és possible obtinir l'adreça en memòria on es desa la constant \texttt{MIDA}. En aquest cas, sí que pots definir una constant amb \texttt{const} i fer que només afecti un àmbit determinat (per exemple, que la constant estigui definida únicament dins d'una funció).

Aquestes són les principals diferències entre \texttt{define} i \texttt{const} a l'hora de definir una constant; \texttt{define} es va crear molt abans que no la sentència \texttt{const}, amb el que és un habit força habitual decantar-se per aquesta opció per temes més històrics.

\hypertarget{com-mostrar-el-valor-duna-constant}{%
\section{Com mostrar el valor d'una constant}\label{com-mostrar-el-valor-duna-constant}}

En C podem mostrar per pantalla el valor d'una constant definida amb \texttt{\#define} mitjançant \texttt{printf()}. Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define WORD "world"}
\PreprocessorTok{\#define YEAR 2021}
\PreprocessorTok{\#define EXCLAMATION \textquotesingle{}!\textquotesingle{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    printf(}\StringTok{"hello \%s and happy \%d \%c}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, PALABRA, YEAR, EXCLAMATION);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El resultat que es mostrarà per pantalla serà:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{hello world and happy }\DecValTok{2021}\NormalTok{ !}
\end{Highlighting}
\end{Shaded}

\hypertarget{precisiuxf3-en-variables-float}{%
\section{Precisió en variables float}\label{precisiuxf3-en-variables-float}}

Hi ha alguns valors decimals determinats que no es poden representar de forma precisa en una variable de tipus \texttt{float}. La millor solució pels casos que tractem és arrodonir al número de decimals que realment necessitem.

Si en canvi volem sí o sí treballar amb tots els decimals, podem optar per utilitzar un tipus de dada que tingui major precisió que \texttt{float}: \texttt{double}.

Per exemple, el següent programa retorna el resultat esperat si es desa en un \texttt{double}, i no així si es fa en un \texttt{float}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{ }
    \DataTypeTok{float}\NormalTok{ num1; }
    \DataTypeTok{float}\NormalTok{ num2;}
    \DataTypeTok{float}\NormalTok{ resultat1; }
    \DataTypeTok{double}\NormalTok{ resultat2; }
    
\NormalTok{    num1 = }\FloatTok{1.3}\NormalTok{; }
\NormalTok{    num2 = }\DecValTok{17}\NormalTok{;}
\NormalTok{    resultat1 = num1 + num2; }
\NormalTok{    printf(}\StringTok{"resultat amb float : \%f}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat1); }
\NormalTok{    resultat2 = num1 + num2; }
\NormalTok{    printf(}\StringTok{"resultat amb double: \%f}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat2); }
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{; }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La sortida que genera és:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{resultat amb }\DataTypeTok{float}\NormalTok{ : }\FloatTok{18.299999}
\NormalTok{resultat amb }\DataTypeTok{double}\NormalTok{: }\FloatTok{18.300000}
\end{Highlighting}
\end{Shaded}

\hypertarget{semuxe0ntica-duna-expressiuxf3}{%
\section{Semàntica d'una expressió}\label{semuxe0ntica-duna-expressiuxf3}}

Si recordem el que es comenta al punt \textbf{3.2. Semàntica d'una expressió} del mòdul de la xWiki \textbf{Tipus bàsics de dades}, hem d'aconseguir que les expressions i comparacions realitzades als algorismes siguin \textbf{semànticament correctes}.

Amb un exemple es veurà més clar: tenim el següent algorisme que indica si una persona és major d'edat. Fixeu-vos que l'expressió realitza una comparació entre dos enters: la variable \texttt{edat} i el número \texttt{17}.

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    edat: int;
    isMajorEdat: boolean;
end var

algorithm serMajorEdat

    writeString("Introdueix edat del conductor :");
    edat := readInteger();

    isMajorEdat := (edat > 17);

    writeString("El conductor és major d'edat? :");
    writeBoolean(isMajorEdat);

end algorithm
\end{verbatim}

Aquesta expressió \textbf{és semànticament correcta}.

En canvi, imaginem ara que el nostre algorisme accepta decimals per l'\texttt{edat}; per exemple, \texttt{19.5} indicaria que l'edat és de 19 anys i 6 mesos. Així tenim el següent plantejament, on ara la variable \texttt{edat} és de tipus \texttt{real}:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    edat: real;
    isMajorEdat: boolean;
end var

algorithm serMajorEdat

    writeString("Introdueix edat del conductor :");
    edat := readReal();

    isMajorEdat := (edat > 17);

    writeString("El conductor és major d'edat? :");
    writeBoolean(isMajorEdat);

end algorithm
\end{verbatim}

L'algorisme ara \textbf{no és correcte} ja que conté una expressió \textbf{semànticament incorrecta}, en la qual es compara \texttt{edat} (real) amb \texttt{17} (enter). Per solucionar-ho, podem utilitzar alguna de les funcions de conversió comentades a l'apartat \textbf{4. Funcions de conversió de tipus del mateix mòdul}:

\includegraphics{./img/alg.png}

\begin{verbatim}
{ opció 1: fem que els dos valors siguin de tipus enter }
isMajorEdat := (realToInteger(edat) > 17);    

{ opció 2: fem que els dos valors siguin de tipus real }
isMajorEdat := (edat > integerToReal(17));
\end{verbatim}

\hypertarget{exemples-dexpressions}{%
\section{Exemples d'expressions}\label{exemples-dexpressions}}

\hypertarget{exemple-1-esparell}{%
\subsection{Exemple 1: esParell}\label{exemple-1-esparell}}

Imaginem que ens demanen un algorisme que indiqui si un número és parell.

Una possible solució seria:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm esParell
    var
        numero: integer;
        isParell: boolean;
    end var

    writeString("Introdueix un número : ");
    numero:= readInteger();
    isParell:= (numero mod 2 = 0);
    
    writeString("El número ");
    writeInteger(numero);
    writeString(" és parell? ");
    writeBoolean(isParell);

end algorithm
\end{verbatim}

La variable \texttt{isParell} prendrà el valor \texttt{TRUE} si el número es parell i \texttt{FALSE} en cas contrari. No ha calgut utilitzar cap estructura \texttt{if-else} per resoldre l'algorisme.

Una possible forma de codificar-ho en llenguatge C és:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ numero;}
    \DataTypeTok{bool}\NormalTok{ isParell;}

\NormalTok{    printf(}\StringTok{"Introdueix un número : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numero);}
\NormalTok{    isParell = (numero \% }\DecValTok{2}\NormalTok{ == }\DecValTok{0}\NormalTok{);}
    
\NormalTok{    printf(}\StringTok{"El número \%d és parell? (0=FALSE, 1=TRUE) : \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero, isParell);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-2-capdesetmana}{%
\subsection{Exemple 2: capDeSetmana}\label{exemple-2-capdesetmana}}

Imaginem que volem fer un programa molt senzill que ens digui si avui és cap de setmana o no. El seu algorisme seria el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
type
    dies = {DILLUNS, DIMARTS, DIMECRES, DIJOUS, DIVENDRES, DISSABTE, DIUMENGE};
end type

algorithm capDeSetmana

    var
        esCapDeSetmana: boolean;
        diaSetmana: dies;
    end var

    writeString("Quin dia de la setmana és avui ?\n");
    writeString("Per DILLUNS tecleja 0\n");
    writeString("Per DIMARTS tecleja 1\n");
    writeString("Per DIMECRES tecleja 2\n");
    writeString("Per DIJOUS tecleja 3\n");
    writeString("Per DIVENDRES tecleja 4\n");
    writeString("Per DISSABTE tecleja 5\n");
    writeString("Per DIUMENGE tecleja 6\n");
 
    diaSetmana:= readInteger();
    esCapDeSetmana:= (diaSetmana = DISSABTE or diaSetmana = DIUMENGE);

    writeString("Avui és cap de setmana?");
    writeBool(esCapDeSetmana);

end algorithm
\end{verbatim}

La variable \texttt{boolean} \texttt{esCapDeSetmana} prendrà el valor de \texttt{true} o \texttt{false} en funció del resultat d'avaluar l'expressió. No és necessari la utilització d'estructures condicionals \texttt{if-else} que veurem més endavant en el curs.

Una possible forma de codificar-ho en llenguatge C és:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{DILLUNS, DIMARTS, DIMECRES, DIJOUS, DIVENDRES, DISSABTE, DIUMENGE\} dies;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{bool}\NormalTok{ esCapDeSetmana;}
\NormalTok{    dies diaSetmana;}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Quin dia de la setmana és avui ?}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DILLUNS tecleja 0}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DIMARTS tecleja 1}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DIMECRES tecleja 2}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DIJOUS tecleja 3}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DIVENDRES tecleja 4}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DISSABTE tecleja 5}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Per DIUMENGE tecleja 6}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}

\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&diaSetmana);}
\NormalTok{    esCapDeSetmana = (diaSetmana == DISSABTE || diaSetmana == DIUMENGE);}

\NormalTok{    printf(}\StringTok{"Avui és cap de setmana (0 == false, 1 == true) ? \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, esCapDeSetmana);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Varis punts a considerar:

\begin{itemize}
\tightlist
\item
  Recordem que inicialment en C no existia el tipus booleà. Per poder utilitzar \texttt{bool}, i els valors \texttt{true} i \texttt{false} ens cal importar prèviament la llibreria \texttt{\textless{}stdbool.h\textgreater{}}.
\item
  L'especificador de tipus d'un \texttt{bool} és \texttt{\%d}.
\item
  Quan definim una variable de tipus \texttt{enum} utilitzem l'especificador de tipus \texttt{\%u}. Ho podríem fer com a \texttt{\%d}, però retornarà un warning tot i que el resultat sigui correcte. El tipus \texttt{\%u} és igual que un enter \texttt{\%d} però sense signe: això significa que amb \texttt{\%d} podem tractar valors negatius com -12 i amb \texttt{\%u} això no és possible, però com que sabem que els valors que pot prendre un \texttt{enum} sempre seran \textgreater= 0 ens convé utilitzar \texttt{\%u}.
\item
  Per les particularitats dels \texttt{bool} en el llenguatge de programació C que ja hem comentat anteriorment, l'entrada i sortida de valors d'un \texttt{boolean} serà numèrica. Per facilitar la comprensió podem mostrar per pantalla un literal que ens indiqui que \texttt{0} equival a \texttt{false} i \texttt{1} a \texttt{true}.
\end{itemize}

\hypertarget{exemple-3-esvocal}{%
\subsection{Exemple 3: esVocal}\label{exemple-3-esvocal}}

Exemple: volem fer un programa que, entrat un caràcter pel canal d'entrada, ens indiqui si es tracta o no d'una vocal.

Una possible solució per l'algorisme és la següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    lletra: char;
    isVocal: boolean;
end var

algorithm esVocal

    writeString("Tecleja una lletra :");
    lletra := readChar();

    { en aquest exemple només tractem les vocals minúscules }
    isVocal := lletra = 'a' or lletra = 'e' or lletra = 'i' or lletra = 'o' or lletra = 'u';

    writeString("La lletra ");
    writeChar(lletra);
    writeString(" és una vocal? ");
    writeBoolean(isVocal);

end algorithm
\end{verbatim}

Com es pot veure el plantejament de l'algorisme és:

\begin{itemize}
\tightlist
\item
  Llegim un caràcter des del canal d'entrada.
\item
  Comparem el caràcter amb \texttt{a}, \texttt{e}, \texttt{i}, \texttt{o}, \texttt{u}.

  \begin{itemize}
  \tightlist
  \item
    Si coincideix amb alguna d'aquestes vocals, la variable \texttt{isVocal\ :=\ true}.
  \item
    Si no coincideix amb cap de les vocals, la variable \texttt{isVocal\ :=\ false}.
  \end{itemize}
\item
  Es mostra el resultat per pantalla.
\end{itemize}

Com ho podem traduir a llenguatge C? Una possible opció és:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ lletra;}
    \DataTypeTok{bool}\NormalTok{ isVocal;}

\NormalTok{    printf(}\StringTok{"Introdueix una lletra : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%c"}\NormalTok{, \&lletra);}

    \CommentTok{/* en aquest exemple només tractem les vocals minúscules */}
\NormalTok{    isVocal = lletra == }\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ || lletra == }\CharTok{\textquotesingle{}e\textquotesingle{}}\NormalTok{ || lletra == }\CharTok{\textquotesingle{}i\textquotesingle{}}\NormalTok{ || lletra == }\CharTok{\textquotesingle{}o\textquotesingle{}}\NormalTok{ || lletra == }\CharTok{\textquotesingle{}u\textquotesingle{}}\NormalTok{;}

\NormalTok{    printf(}\StringTok{"La lletra \%c és una vocal (0=FALSE, 1=TRUE) ? \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, lletra, isVocal);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-4-votacions}{%
\subsection{Exemple 4: votacions}\label{exemple-4-votacions}}

Imaginem que hem de fer un programa que validi si una persona pot anar a votar o no; la condició que ens diuen que cal complir és que la persona sigui major d'edat i a més estigui al cens electoral de la localitat on està votant.

L'algorisme podria ser el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm votacions
    var
        isMajorEdat: boolean;
        isCensat: boolean;
        isVotar: boolean;
    end var
    
    writeString("Ets major d'edat (0=FALSE, 1=TRUE) ? : ");
    isMajorEdat := readBoolean();
    writeString("Estàs al cens electoral (0=FALSE, 1=TRUE) ? : ");
    isCensat := readBoolean();
    
    { expressió }
    isVotar := isMajorEdat and isCensat;

    writeString("Pots anar a votar (0=FALSE, 1=TRUE) :");
    writeBoolean(isVotar);

end algorithm
\end{verbatim}

Una possible implementació en C seria:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{bool}\NormalTok{ isMajorEdat;}
    \DataTypeTok{bool}\NormalTok{ isCensat;}
    \DataTypeTok{bool}\NormalTok{ isVotar;}

\NormalTok{    printf(}\StringTok{"Ets major d\textquotesingle{}edat (0=FALSE, 1=TRUE) ? : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&isMajorEdat);}

\NormalTok{    printf(}\StringTok{"Estàs al cens electoral (0=FALSE, 1=TRUE) ? : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&isCensat);}

\NormalTok{    \{ expressió \}}
\NormalTok{    isVotar = isMajorEdat \&\& isCensat;}

\NormalTok{    printf(}\StringTok{"Pots anar a votar (0=FALSE, 1=TRUE) : \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, isVotar);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució d'aquest exemple seria:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Ets major d\textquotesingle{}edat (}\DecValTok{0}\NormalTok{=FALSE, }\DecValTok{1}\NormalTok{=TRUE) ? : }\DecValTok{1}
\NormalTok{Estàs al cens electoral (}\DecValTok{0}\NormalTok{=FALSE, }\DecValTok{1}\NormalTok{=TRUE) ? : }\DecValTok{0}
\NormalTok{Pots anar a votar (}\DecValTok{0}\NormalTok{=FALSE, }\DecValTok{1}\NormalTok{=TRUE) : }\DecValTok{0}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-5-gintonicpreparation}{%
\subsection{Exemple 5: ginTonicPreparation}\label{exemple-5-gintonicpreparation}}

Imaginem que volem preparar un gintònic. Sabem el volum de ginebra i de tònica que utilitzarem, i quina és la capacitat de la copa de baló que el contindrà.

Hem vist una oferta per internet i hem comprat glaçons metàl·lics d'acer inoxidable\ldots{} però se'ns ha anat una mica el cap i n'hem comprat un total de 20 unitats.

Volem fer un programa que, utilitzant únicament expressions, ens digui si podem preparar o no el gintònic en funció del número de glaçons que li volem posar:

\begin{itemize}
\tightlist
\item
  Si el nombre de glaçons caben dins de la copa, retornarà \texttt{true}.
\item
  En cas contrari, retornarà \texttt{false}.
\end{itemize}

Per tant el que ha de fer el nostre programa bàsicament és validar si el volum de ginebra + tònica + (glaço) * número de glaçons supera o no el volum de la copa.

L'algorisme podria ser el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    GIN: real = 50.0;              { in ml }
    TONIC: real = 200.0;           { in ml }
    GLASS: real = 620.0;           { in ml }
    METAL_ICE_CUBE: real = 42.875; { in ml }
end const

algorithm ginTonicPreparation

    var
        numMetalIceCubes: integer;
        isPossible: boolean;
    end var

    writeString("Number of metal ice cubes ? (integer) : ");
    numMetalIceCubes:= readInteger();

    isPossible:= (GLASS ≥ (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes));

    writeString("Can you make a gin & tonic? : ");
    writeBoolean(isPossible);

end algorithm
\end{verbatim}

L'expressió que dóna valor a \texttt{isPossible} s'ocupa d'avaluar el volum de la copa respecte el resultant de ginebra, tònica i glaçons.

La seva traducció a C podria ser:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\PreprocessorTok{\#define GIN 50.0              }\CommentTok{/* in ml */}
\PreprocessorTok{\#define TONIC 200.0           }\CommentTok{/* in ml */}
\PreprocessorTok{\#define GLASS 620.0           }\CommentTok{/* in ml */}
\PreprocessorTok{\#define METAL\_ICE\_CUBE 42.875 }\CommentTok{/* in ml */}\PreprocessorTok{ }

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ numMetalIceCubes;}
    \DataTypeTok{bool}\NormalTok{ isPossible;}

\NormalTok{    printf(}\StringTok{"Number of metal ice cubes ? (integer) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numMetalIceCubes);}

\NormalTok{    isPossible = GLASS \textgreater{}= (GIN + TONIC + METAL\_ICE\_CUBE * numMetalIceCubes);}

\NormalTok{    printf(}\StringTok{"Can you make a gin \& tonic? (0=FALSE, 1=TRUE) : \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, isPossible);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Per realitzar el càlcul en C també s'ha utilitzat una expressió.

\hypertarget{exemple-6-gintonicfreeml}{%
\subsection{Exemple 6: ginTonicFreeMl}\label{exemple-6-gintonicfreeml}}

Anem a evolucionar l'exemple anterior del gintònic: imaginem ara que volem que el nostre programa ens digui el volum (en mililitres) que queda lliure a la copa una vegada posat un determinat nombre de glaçons.

L'algorisme quedaria de la següent forma:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    GIN: real = 50.0;              { in ml }
    TONIC: real = 200.0;           { in ml }
    GLASS: real = 620.0;           { in ml }
    METAL_ICE_CUBE: real = 42.875; { in ml }
end const

algorithm ginTonicFreeMl

    var
        numMetalIceCubes: integer;
        volumeFree: real;
    end var

    writeString("Number of metal ice cubes ? (integer) : ");
    numMetalIceCubes:= readInteger();

    volumeFree:= GLASS - (GIN + TONIC + METAL_ICE_CUBE * numMetalIceCubes);

    writeString("How many free ml in the glass? : ");
    writeReal(volumeFree);

end algorithm
\end{verbatim}

I la codificació en C :

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define GIN 50.0              }\CommentTok{/* in ml */}
\PreprocessorTok{\#define TONIC 200.0           }\CommentTok{/* in ml */}
\PreprocessorTok{\#define GLASS 620.0           }\CommentTok{/* in ml */}
\PreprocessorTok{\#define METAL\_ICE\_CUBE 42.875 }\CommentTok{/* in ml */}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ numMetalIceCubes;}
    \DataTypeTok{float}\NormalTok{ volumeFree;}

\NormalTok{    printf(}\StringTok{"Number of metal ice cubes ? (integer) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numMetalIceCubes);}

\NormalTok{    volumeFree = GLASS {-} (GIN + TONIC + METAL\_ICE\_CUBE * numMetalIceCubes);}

\NormalTok{    printf(}\StringTok{"How many free ml in the glass ? : \%.3f ml }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, volumeFree);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-7-scoutingbasquet}{%
\subsection{Exemple 7: scoutingBasquet}\label{exemple-7-scoutingbasquet}}

Imaginem que fem tasques d'scouting per les seccions de bàsquet femení i masculí del nostre club, i ens han encarregat cobrir alguna de les tres places següents:

\begin{itemize}
\tightlist
\item
  Per l'equip femení: una pivot que com a mínim faci 195cm d'alçada.
\item
  Per l'equip femení: una base, l'alçada de la qual sigui inferior a 170cm.
\item
  Per l'equip masculí: un base que sigui més alt de 175cm però a la vegada que no superi els 190cm.
\end{itemize}

El nostre programa demanarà per teclat si es tracta d'una jugadora o un jugador, i quina és la seva alçada. A continuació amb expressions avaluarà les condicions introduides i si les compleix per alguna de les tres places disponibles, l'escollirà (\texttt{isDrafted}).

Una possible forma de codificar en C aquest programa seria:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{MALE, FEMALE\} tGender;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{bool}\NormalTok{ isPointGuard; }\CommentTok{/* Point Guard = base */}
    \DataTypeTok{bool}\NormalTok{ isCenter;     }\CommentTok{/* Center = pivot */}
    \DataTypeTok{bool}\NormalTok{ isDrafted;}
    \DataTypeTok{int}\NormalTok{ height;}
\NormalTok{    tGender gender;}

\NormalTok{    printf(}\StringTok{"Gender (0=MALE, 1=FEMALE) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&gender);}
\NormalTok{    printf(}\StringTok{"Heigth (integer value) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&height);}

    \CommentTok{/* Primer mirem si la posició de base femení o masculí la podem cobrir o no */}
\NormalTok{    isPointGuard = }
\NormalTok{        (height \textless{} }\DecValTok{170}\NormalTok{ \&\& (gender == FEMALE)) ||}
\NormalTok{        (height \textless{} }\DecValTok{190}\NormalTok{ \&\& height \textgreater{} }\DecValTok{175}\NormalTok{ \&\& (gender == MALE));}

    \CommentTok{/* A continuació comprovem si es tracta de la pívot femenina que busquem */}
\NormalTok{    isCenter = (height \textgreater{}= }\DecValTok{195}\NormalTok{ \&\& (gender == FEMALE));}

    \CommentTok{/* Només que es compleixi alguna de les dues expressions anteriors }
\CommentTok{       (que isPointGuard sigui TRUE o que isCenter sigui TRUE), el jugador/a }
\CommentTok{       serà escollit per formar part de les nostres seccions de bàsquet */}
\NormalTok{    isDrafted = isPointGuard || isCenter;}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Is drafted (0=FALSE, 1=TRUE) ? : "}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"\%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, isDrafted);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Fixeu-vos que \texttt{isPointGuard} i \texttt{isCenter} són variables de tipus \texttt{bool}, ja que l'avaluació de les expressions també serà de tipus \texttt{bool}.

Hi poden haver altres codificacions igual de vàlides, aquesta no és la única solució possible.

\hypertarget{frequently-made-mistakes-1}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes-1}}

\hypertarget{interfuxedcie-dusuari-absuxe8ncia-de-textos-informatius}{%
\subsection{Interfície d'usuari: absència de textos informatius}\label{interfuxedcie-dusuari-absuxe8ncia-de-textos-informatius}}

El següent no és un error sintàctic o semàntic, sinó un error de disseny molt freqüent.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
writeInteger(room);
writeInteger(totalPrice);
\end{verbatim}

En l'exemple mostrat, sembla que la intenció és mostrar pel canal estàndard dues variables (\texttt{room} i \texttt{totalPrice}), i efectivament les sentències per imprimir-les són correctes. El problema és que l'usuari no té cap informació sobre el significat dels valors que se li mostren. Cal sempre complementar les dades amb missatges informatius, indicant també les unitats quan sigui necessari.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
writeString("Room number: ");
writeInteger(room);
writeString("Total price [€]: ");
writeInteger(totalPrice);
\end{verbatim}

Aquest error de disseny és més greu en el cas (també real), de no posar cap text informatiu a l'hora de demanar a l'usuari que introdueixi dades per teclat.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
readInteger(room);
readReal(totalPrice);
\end{verbatim}

L'usuari no té cap informació sobre els valors a introduir (tipus de dades, intervals vàlids, etc.).

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
writeString("Enter room number [1-100]: ");
readInteger(room);
writeString("Enter total price [€]: ");
readInteger(totalPrice);
\end{verbatim}

\hypertarget{caruxe0cters-uxfas-de-cometes-simples}{%
\subsection{Caràcters: ús de cometes simples}\label{caruxe0cters-uxfas-de-cometes-simples}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    fastpass: char;
    areaMap: char;
    allowsFastPass: boolean;
end var
{...}
fastPass := (allowsFastPass = y or allowsFastPass = Y) and (areaMap = B or areaMap = C);
{...}
\end{verbatim}

En l'algoritme anterior, sembla que es vol comparar la variable \texttt{allowsFastPass} amb els caràcters \texttt{y}, \texttt{Y}, i la variable \texttt{areaMap} amb els caràcters \texttt{B}, \texttt{C}. El problema és que falten les cometes simples per indicar que es tracta de caràcters, i per tant el que fa l'expressió es comparar amb les variables \texttt{y}, \texttt{Y}, \texttt{B} i \texttt{C} respectivament (que a més a més, en aquest algoritme no existeixen. Aquest és un error semàntic greu, que pot no provocar cap error de compilació en llenguatge C, i en canvi comportar comportaments inesperats.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    fastpass: char;
    areaMap: char;
    allowsFastPass: boolean;
end var
{...}
fastPass := (allowsFastPass = 'y' or allowsFastPass = 'Y') and (areaMap = 'B' or areaMap = 'C');
{...}
\end{verbatim}

\hypertarget{sintaxi-pruxf2pia-de-c-funcions-de-lecturaescriptura}{%
\subsection{Sintaxi pròpia de C: funcions de lectura/escriptura}\label{sintaxi-pruxf2pia-de-c-funcions-de-lecturaescriptura}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
writeString("Code value: %d\n", codeValue);
\end{verbatim}

S'ha intentat aplicar a la funció \texttt{writeString()} en llenguatge algorísmic la sintaxi pròpia de la funció \texttt{printf()} de C, la qual cosa evidentment no és correcta. Recordeu que el llenguatge algorísmic és un llenguatge de disseny de propòsit general, que ha de permetre posteriorment codificar en qualsevol llenguatge de programació

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
writeString("Code value");
writeInteger(codeValue);
\end{verbatim}

\hypertarget{conversiuxf3-de-tipus-funcions-inexistents}{%
\subsection{Conversió de tipus: funcions inexistents}\label{conversiuxf3-de-tipus-funcions-inexistents}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
b1:= characterToCode(myChar);
\end{verbatim}

Les funcions de conversió de tipus estan definides al \textbf{Nomenclator} de l'assignatura, i serveixen per assegurar la coherència semàntica entre els tipus de variables d'una expressió. En aquest cas, la funció \texttt{characterToCode()} no existeix, ja que la que hem declarat és \texttt{characterToInteger()}. És habitual trobar errors d'aquest tipus, amb diverses variants de noms de funció. Cal evitar-ho i usar el \textbf{Nomenclator} com a guia.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
b1:= characterToInteger(myChar);
\end{verbatim}

\hypertarget{expressions-variables-intermitges}{%
\subsection{Expressions: variables intermitges}\label{expressions-variables-intermitges}}

Aquest no és un error sintàctic o semàntic, sinó una mala pràctica de disseny.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    bool1: boolean;
    bool2: boolean;
    bool3: boolean;
    bool4: boolean;
end var
bool1:= hasGym or hasPool;
bool2:= closToSubway or distanceFromCityCentre < 5;
bool3:= priceDouble <= 100;
boolFin:= bool1 and bool2 and bool3;
\end{verbatim}

En el codi anterior, el que volem obtenir al final és una variable de tipus booleà que ens indiqui si un objecte (suposem que un hotel), té piscina o gimnàs, i a més està prop del metro o a menys de 5 km del centre de la ciutat, i a més el preu és inferior a 100 (euros). Volem reunir tota aquesta informació en una variable booleana, perquè segurament això ens indica alguna qualitat de l'objecte (per exemple, que és un bon hotel). Ara bé, fixeu-vos com per arribar al resultat final, s'han declarat fins a tres variables auxiliars, que no tenen cap altra finalitat que construir l'expressió final.

Declarar variables auxiliars o temporals no és una mala pràctica sempre que es faci amb mesura, i aplicant el sentit comú (cosa que només s'adquireix amb la pràctica del disseny i la programació). Recordem que les variables ocupen espai de memòria, i per tant cal ser curosos a l'hora de declarar-les. Una alternativa seria la que presentem a continuació.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    bool4: boolean;
end var
boolFin:= hasGym or hasPool and 
          closToSubway or distanceFromCityCentre < 5 and 
          priceDouble <= 100;
\end{verbatim}

Recordem que el delimitador de les sentències és el punt i coma \texttt{;}, i que hi ha flexibilitat a l'hora d'escriure les sentències en diverses línies (també en C). Finalment, recordar un cop més que no hi ha cap norma que ens indiqui quantes variables auxiliars hem d'utilitzar. En la solució alternativa hem optat per no utilitzar-ne cap i donar un format entenedor a l'expressió, però això caldrà decidir-ho en cada cas, en base a la pràctica i l'experiència.

\hypertarget{declaraciuxf3-de-variables-declaraciuxf3-mal-ubicada-bloc-central-de-codi}{%
\subsection{Declaració de variables: declaració mal ubicada (bloc central de codi)}\label{declaraciuxf3-de-variables-declaraciuxf3-mal-ubicada-bloc-central-de-codi}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
for i:= 1 to selectedHotels->nHotels do 
    if selectedHotels[i].city = city then 
        var
            scorePoints: integer;
        end var
        scorePoints := scorePoints + 1;
    end if
end for
\end{verbatim}

Les variables s'han de declarar \textbf{al principi} del \textbf{bloc de pseudocodi}, ja sigui una funció, una acció o bé un algorisme directament. No és correcte obrir un bloc de declaració de variables dins un bloc central de pseudocodi (i encara menys obrir diversos blocs de declaració a mesura que necessitem variables). El mateix passa en C: les variables s'han de declarar sempre al bloc inicial de codi (ja sigui una funció, acció o algorisme).

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    scorePoints: integer;
end var

for i:= 1 to selectedHotels->nHotels do 
    if selectedHotels[i].city = city then 
       scorePoints := scorePoints + 1;  
    end if
end for
\end{verbatim}

\hypertarget{declaraciuxf3-de-variables-declaraciuxf3-mal-ubicada-variables-globals}{%
\subsection{Declaració de variables: declaració mal ubicada (variables globals)}\label{declaraciuxf3-de-variables-declaraciuxf3-mal-ubicada-variables-globals}}

Aquest no és un error sintàctic o semàntic, sinó una mala pràctica de porgramació que cal evitar.

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

float maxPrice;
int bestHotel;

int main(int argc, char **argv) {
    /* ... */
    return 0;
}
\end{verbatim}

Les variables s'han de declarar sempre dins una funció o acció (ja sigui el main o qualsevola altra), i \textbf{al principi} del seu \textbf{bloc de codi}. No és correcte declarar variables fora de qualsevol funció, ja que es converteixen en \textbf{variables globals}, i el seu ús no es considera una bona pràctica de programació. El motiu és que les variables globals dificulten la lectura i la comprensió del codi, i poden provocar errors d'execució inesperats o actualitzacions involuntàries, en no estar protegides dins de funcions o accions.

Codi correcte:

\includegraphics{./img/c.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char **argv) {
    float maxPrice;
    int bestHotel;
    /* ... */
    return 0;
}
\end{verbatim}

\hypertarget{tipus-booleuxe0-valors-numuxe8rics}{%
\subsection{Tipus booleà: valors numèrics}\label{tipus-booleuxe0-valors-numuxe8rics}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char **argv) {
    bool myBool1;
    bool myBool2;
    bool resultBool;
    /* ... */
    resultBool = (myBool == 1) && (myBool2 == 0);
    return 0;
}
\end{verbatim}

Si disposem de la llibreria \texttt{\textless{}stdbool.h\textgreater{}} pel tractament de booleans en C, no té cap sentit que utilizem els seus equivalents numèrics al codi, especialment en el cas de les expressions. En el seu lloc heu d'utilizar les paraules reservades \texttt{true} i \texttt{false}.

Com a regla general, hem de procurar usar el mínim nombre possible de valors numèrics, i fer servir en el seu lloc variables i constants.

Codi correcte:

\includegraphics{./img/c.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char **argv) {
    bool myBool1;
    bool myBool2;
    bool resultBool;
    /* ... */
    resultBool = (myBool == true) && (myBool2 == false);
    return 0;
}
\end{verbatim}

\hypertarget{tipus-booleuxe0-cadenes-de-caruxe0cters}{%
\subsection{Tipus booleà: cadenes de caràcters}\label{tipus-booleuxe0-cadenes-de-caruxe0cters}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char **argv) {
    bool myBool1;
    bool myBool2;
    bool resultBool;
    resultBool = (myBool =="true") && (myBool2 == "false");
    return 0;
}
\end{verbatim}

Si disposem de la llibreria \texttt{\textless{}stdbool.h\textgreater{}} pel tractament de booleans en C, podem utilitzar les paraules reservades \texttt{true} i \texttt{false}, sense cap tipus de modificador ni caràcter. Si afegim les cometes, ``true'' i ``false'' es converteixen en cadenes de caràcters, que són una cosa molt diferent i no tenen res a veure amb els booleans (ni amb els seus possibles valors). Aquest error molt greu també es dóna en llenguatge algorísmic.

Cal afegir a més, que en C qualsevol valor que no sigui 0 és interpretat com a \texttt{true}, per la qual cosa es produiran errors d'execució, ja que les cadenes de caràcters seran interpretades sempre com un valor cert.

Codi correcte:

\includegraphics{./img/c.png}

\begin{verbatim}
#include <stdio.h>
#include <stdbool.h>

int main(int argc, char **argv) {
    bool myBool1;
    bool myBool2;
    bool resultBool;
    resultBool = (myBool == true) && (myBool2 == false);
    return 0;
}
\end{verbatim}

\hypertarget{sintaxi-pruxf2pia-de-c-operadors}{%
\subsection{Sintaxi pròpia de C: operadors}\label{sintaxi-pruxf2pia-de-c-operadors}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
if (acceptable == 1) or (acceptable == 2) then
    writeString("Hotels cannot be compared");
end if
\end{verbatim}

L'operador \texttt{==} és propi del llenguatge C, i el seu ús llenguatge algorísmic no és correcte. L'operador correcte en aquest cas és \texttt{=}.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
if (acceptable) = 1 or (acceptable = 2) then
    writeString("Hotels cannot be compared");
end if
\end{verbatim}

\hypertarget{pac03}{%
\chapter{PAC03}\label{pac03}}

\hypertarget{com-declarar-un-vector-en-llenguatge-algoruxedsmic}{%
\section{Com declarar un vector en llenguatge algorísmic}\label{com-declarar-un-vector-en-llenguatge-algoruxedsmic}}

Quan es declara un vector en llenguatge algorísmic no cal declarar una variable per cadascuna de les posicions d'aquest vector.

Per exemple, si volem un algorisme que sumi tres enters continguts dins d'un vector podem fer el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    NUM_ENTERS: integer = 3;
end const

algorithm sumaEnters

    var
        vectorEnters: vector[NUM_ENTERS] of integer;
        sumaEnters: integer;
    end var

    vectorEnters[1] := 13;
    vectorEnters[2] := 24;
    vectorEnters[3] := 2;

    { Com es pot veure, accedim directament a les posicions del vector }
    { en comptes de definir una variable per cada posició. }

    sumaEnters := vectorEnters[1] + vectorEnters[2] + vectorEnters[3];

    { Cal recordar també que en llenguatge algorísmic, en un vector de mida n }
    { la primera posició del vector és la 1 i la darrera la n; en canvi en llenguatge C }
    { la primera sempre és la 0 i l'última la n-1. }

    writeString("La suma dels 3 enters del vector és : ");
    writeInteger(sumaEnters);

end algorithm
\end{verbatim}

\hypertarget{significat-dels-arguments-del-main}{%
\section{Significat dels arguments del main}\label{significat-dels-arguments-del-main}}

La principal diferència entre la definició \texttt{main(int\ argc,\ char\ **argv)} i \texttt{main()} és que la primera opció està preparada per rebre arguments quan s'executa el programa i no així la segona.

Per exemple, si tenim el següent programa compilat en C i li passem una sèrie d'arguments des de la línia de comandes:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{$\textgreater{} programa a1 a2 a3}
\end{Highlighting}
\end{Shaded}

Amb el main definit com a \texttt{main(int\ argc,\ char\ **argv)} podem accedir des de dins del programa a tots els arguments passats; així haurem de:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{argc = }\DecValTok{4}

\NormalTok{argv[}\DecValTok{0}\NormalTok{] = }\StringTok{"programa"}
\NormalTok{argv[}\DecValTok{1}\NormalTok{] = }\StringTok{"a1"}
\NormalTok{argv[}\DecValTok{2}\NormalTok{] = }\StringTok{"a2"}
\NormalTok{argv[}\DecValTok{3}\NormalTok{] = }\StringTok{"a3"}
\end{Highlighting}
\end{Shaded}

El propi sistema operatiu s'ocupa de donar-li el valor a l'argument int \texttt{argc} (número total d'arguments inclòs el nom del programa), amb el que únicament t'has de preocupar de passar els arguments. D'altra banda, \texttt{argv} és un array de punters on cadascun d'ells apunta a un argument format per una cadena de caràcters; així \texttt{argv} contindrà a cadascuna de les seves posicions els arguments passats des de línia de comandes, i en la posició 0 el propi nom del programa.

Si en canvi tens definit el programa com a \texttt{main()}, simplement no tens forma d'accedir als arguments que li puguis arribar a passar. Hi ha moltes vegades que les dades les pots tenir ja definides dins del propi programa o les vagis a consultar a una font externa, amb el que no tenir la capacitat de processar arguments no suposa cap impediment a l'hora d'executar el teu programa.

\hypertarget{assignar-valors-a-un-vector}{%
\section{Assignar valors a un vector}\label{assignar-valors-a-un-vector}}

La lectura i assignació de valors a un vector es realitza de la següent forma en llenguatge algorísmic:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    MAX_TEMP: integer = 2;
end const

algorithm lecturaTemperatures

    var
        vTemperatures: vector[MAX_TEMP] of float;
    end var

    writeString("Introdueix la lectura 1 : ");
    vTemperatures[1] := readReal();

    writeString("Introdueix la lectura 2 : ");
    vTemperatures[2] := readReal();
    
    writeString("Els valors introduïts han estat : ");
    
    writeString("> Valor de la posició ");
    writeInteger(1);
    writeString(" : ");
    writeReal(vTemperatures[1]);
    
    writeString("> Valor de la posició ");
    writeInteger(2);
    writeString(" : ");
    writeReal(vTemperatures[2]);

end algorithm
\end{verbatim}

I en llenguatge C:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MAX\_TEMP 2}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{float}\NormalTok{ vTemperatures[MAX\_TEMP];}
    \DataTypeTok{int}\NormalTok{ i;}

\NormalTok{    printf(}\StringTok{"Introdueix la lectura 1 : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&vTemperatures[}\DecValTok{0}\NormalTok{]);}

\NormalTok{    printf(}\StringTok{"Introdueix la lectura 2 : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&vTemperatures[}\DecValTok{1}\NormalTok{]);}
    
\NormalTok{    printf(}\StringTok{"\textgreater{} Valor de la posició \%d : \%.1f }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DecValTok{0}\NormalTok{, vTemperatures[}\DecValTok{0}\NormalTok{]);}
\NormalTok{    printf(}\StringTok{"\textgreater{} Valor de la posició \%d : \%.1f }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, }\DecValTok{1}\NormalTok{, vTemperatures[}\DecValTok{1}\NormalTok{]);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Cal remarcar una diferència important:

\begin{itemize}
\tightlist
\item
  En \textbf{llenguatge algorísmic} les posicions del vector van \textbf{des de la 1 fins a la N}.
\item
  En \textbf{llenguatge C}, van des \textbf{de la 0 fins a la N-1}.
\end{itemize}

En tots dos casos \textbf{N} fa referència al número total d'elements del vector.

\hypertarget{stack-smashing-detected}{%
\section{Stack smashing detected}\label{stack-smashing-detected}}

Aquest missatge d'error es produeix quan s'intenta accedir/operar amb una posició d'un vector que no l'hem definit prèviament. Es pot donar per diferents situacions que acaben generant el mateix problema.

\begin{itemize}
\tightlist
\item
  \textbf{Cas 1}: es defineix un vector de N-posicions, però en comptes de començar per la posició 0 ho fem per la 1. Això és incorrecte: recordem que en C la posició inicial d'un vector sempre és la 0, i la final sempre és N-1. Exemple, per un vector de 3 posicions tindrem:

  \includegraphics{./img/c.png}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ vector1[}\DecValTok{3}\NormalTok{];}
\NormalTok{vector1[}\DecValTok{1}\NormalTok{] = }\DecValTok{13}\NormalTok{;  }\CommentTok{/* Posició del vector1 vàlida */}
\NormalTok{vector1[}\DecValTok{2}\NormalTok{] = }\DecValTok{24}\NormalTok{;  }\CommentTok{/* Posició del vector1 vàlida */}
\NormalTok{vector1[}\DecValTok{3}\NormalTok{] = }\DecValTok{48}\NormalTok{;  }\CommentTok{/* Posició del vector1 no vàlida! */}
\CommentTok{/* En canvi la posició 0 del vector, }
\CommentTok{ * que tenim disponible no l\textquotesingle{}hem utilitzat! }
\CommentTok{ */}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Cas 2}: es defineix un vector amb menys posicions de les que necessitem. Per exemple, si tenim:

  \includegraphics{./img/c.png}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ vector2[}\DecValTok{2}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

Significa que les posicions reservades en memòria per aquest vector són:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vector2[}\DecValTok{0}\NormalTok{] = }\DecValTok{10}\NormalTok{;  }\CommentTok{/* Posició del vector2 vàlida */}
\NormalTok{vector2[}\DecValTok{1}\NormalTok{] = }\DecValTok{13}\NormalTok{;  }\CommentTok{/* Posició del vector2 vàlida */}
\NormalTok{vector2[}\DecValTok{2}\NormalTok{] = }\DecValTok{24}\NormalTok{;  }\CommentTok{/* Posició del vector2 no vàlida! */}
\end{Highlighting}
\end{Shaded}

Per tant qualsevol operació amb \texttt{vector2{[}2{]}} ens generarà l'error indicat. Si volem que el vector contingui 3 elements només cal definir correctament la seva mida:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ vector2[}\DecValTok{3}\NormalTok{];}
\end{Highlighting}
\end{Shaded}

\hypertarget{concatenaciuxf3-en-llenguatge-algoruxedsmic}{%
\section{Concatenació en llenguatge algorísmic}\label{concatenaciuxf3-en-llenguatge-algoruxedsmic}}

A diferència del llenguatge C, en notació algorísmica no està contemplat l'ús d'especificadors que permetin fer concatenacions entre cadenes de caràcters, enters, decimals, etc.

Per tant en llenguatge algorísmic cal trencar els strings amb fragments més petits i que facin referència únicament a un tipus de dades. Per exemple, si es vol mostrar per pantalla el missatge \emph{``L'empleat que cobra més és Marta, i la seva nòmina és 4675.30 €.''}, ho farem de la següent forma:

\includegraphics{./img/alg.png}

\begin{verbatim}
writeString("L'empleat que cobra més és ");
writeString(nomEmpleat);
writeString(", i la seva nòmina és ");
writeReal(nomina);
writeString(" €.");
\end{verbatim}

En llenguatge C equivaldria a:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{printf(}\StringTok{"L\textquotesingle{}empleat que cobra més és \%s, i la seva nòmina és \%.2f €."}\NormalTok{, nomEmpleat, nomina);}
\end{Highlighting}
\end{Shaded}

\hypertarget{importuxe0ncia-dels-tipus-utilitzats-en-llenguatge-c}{%
\section{Importància dels tipus utilitzats en llenguatge C}\label{importuxe0ncia-dels-tipus-utilitzats-en-llenguatge-c}}

El resultat de les operacions en llenguatge C depèn del tipus de variable definit i dels tipus de valors utilitzats. A continuació s'exposen tres casos que, segons el tipus que s'hagi definit en les variables utilitzades, donarà un resultat o un altre:

\textbf{Cas 1}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ a;}
    \DataTypeTok{int}\NormalTok{ b;}
    \DataTypeTok{int}\NormalTok{ c;}
    \DataTypeTok{int}\NormalTok{ m;}

\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&a);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&b);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&c);}

\NormalTok{    m=(a+b+c)/}\DecValTok{3}\NormalTok{;}

\NormalTok{    printf(}\StringTok{"\%d"}\NormalTok{, m);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En aquest cas si donem els valors \texttt{a\ =\ 1}, \texttt{b\ =\ 3}, \texttt{c\ =\ 4}, el resultat és \texttt{m\ =\ 2}. El resultat de la divisió serà un enter, ja que tant numerador com denominador estan formats per enters. El resultat enter es desa en una variable entera, i per pantalla obtindrem: \texttt{2}.

\textbf{Cas 2}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ a;}
    \DataTypeTok{int}\NormalTok{ b;}
    \DataTypeTok{int}\NormalTok{ c;}
    \DataTypeTok{float}\NormalTok{ m;}

\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&a);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&b);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&c);}

\NormalTok{    m=(a+b+c)/}\DecValTok{3}\NormalTok{;}

\NormalTok{    printf(}\StringTok{"\%f"}\NormalTok{, m);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Igual que en el cas anterior, el numerador i el denominador de la divisió estan formats per enters, amb el que el resultat serà un enter. En aquest cas el resultat enter el desem en una variable de tipus \texttt{float}, amb el que C mostrarà el resultat amb decimals: \texttt{2.000000}

\textbf{Cas 3}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ a;}
    \DataTypeTok{int}\NormalTok{ b;}
    \DataTypeTok{int}\NormalTok{ c;}
    \DataTypeTok{float}\NormalTok{ m;}

\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&a);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&b);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&c);}

\NormalTok{    m=(a+b+c)/}\FloatTok{3.0}\NormalTok{;}

\NormalTok{    printf(}\StringTok{"\%f"}\NormalTok{, m);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En aquest cas el resultat de la divisió serà un decimal, ja que el denominador conté un decimal (en aquest cas \texttt{3.0}). El resultat amb decimals es guarda en una variable de tipus \texttt{float}, i per pantalla es mostrarà : \texttt{2.666667}.

\hypertarget{exemple-notafinal}{%
\section{Exemple: notaFinal}\label{exemple-notafinal}}

En aquesta PAC03 es comencen a tractar dos nous aspectes: els \textbf{condicionals} i els \textbf{vectors}, dins dels quals hi contemplem també els strings.

El següent exemple contempla bastants punts dels que es comenten als mòduls de teoria per la PAC03, amb el que segurament aquest exemple serà força més dens que no la pròpia PAC03. Per tant, si algun aspecte costa d'entendre inicialment no us preocupeu, és normal.

He afegit comentaris detallats dins del propi exemple, per tal que sigui el més entenedor possible. El següent exemple calcula la nota final d'una assignatura en funció d'una sèrie de condicionals i d'operacions:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Exemple:}
\CommentTok{ *}
\CommentTok{ * Volem un programa que calculi la nota final}
\CommentTok{ * d\textquotesingle{}una assignatura. La nota final es calcula a partir}
\CommentTok{ * de l\textquotesingle{}AC (Avaluació continua) i la nota de la Pràctica:}
\CommentTok{ *}
\CommentTok{ * Nota final = 30\% AC + 70\% Pràctica}
\CommentTok{ *}
\CommentTok{ * Una vegada entrades totes les notes, si se\textquotesingle{}n}
\CommentTok{ * detecta alguna que sigui incorrecta (fora del}
\CommentTok{ * rang [0.0 a 10.0]), es mostrarà un missatge}
\CommentTok{ * informatiu per pantalla i no es realitzarà cap }
\CommentTok{ * més operació.}
\CommentTok{ *}
\CommentTok{ * L\textquotesingle{}AC està formada per 3 PAC: PAC1, PAC2, PAC3. }
\CommentTok{ * La nota de l\textquotesingle{}AC es calcula mitjançant la }
\CommentTok{ * mitjana de les 3 PAC.}
\CommentTok{ *}
\CommentTok{ * Si la nota de l\textquotesingle{}AC és inferior a 4, no cal }
\CommentTok{ * realitzar cap càlcul: l\textquotesingle{}assignatura queda suspesa.}
\CommentTok{ *}
\CommentTok{ * Si la nota de l\textquotesingle{}AC és superior o igual a 4, es }
\CommentTok{ * calcula la nota final juntament amb la nota de }
\CommentTok{ * la Pràctica.}
\CommentTok{ * }
\CommentTok{ * La nota final es mostrarà en format "grade letters", }
\CommentTok{ * segons la següent relació:}
\CommentTok{ *}
\CommentTok{ * MH: 10}
\CommentTok{ * A: de 9.0 a 9.9}
\CommentTok{ * B: de 7.0 a 8.9}
\CommentTok{ * C+: de 5.0 a 6.9 }
\CommentTok{ * C{-}: de 3.0 a 4.9 }
\CommentTok{ * D: de 0.0 a 2.9}
\CommentTok{ *}
\CommentTok{ * Els punts que tracta aquest exemple:}
\CommentTok{ * {-} definició de vectors}
\CommentTok{ * {-} utilització del condicional if{-}else}
\CommentTok{ * {-} condicionals if{-}else aniuats}
\CommentTok{ * {-} assignació d\textquotesingle{}un string a una variable amb strcpy}
\CommentTok{ * {-} reserva espai pel finalitzador \textquotesingle{}\textbackslash{}0\textquotesingle{}}
\CommentTok{ */}

\PreprocessorTok{\#define PAC1 0}
\PreprocessorTok{\#define PAC2 1}
\PreprocessorTok{\#define PAC3 2}
\PreprocessorTok{\#define PRA 3}
\PreprocessorTok{\#define MAX\_ACTIVITATS 4}
\PreprocessorTok{\#define MAX\_CHARS 2+1    /* el +1 correspon al finalitzador \textquotesingle{}\textbackslash{}0\textquotesingle{} */}
\PreprocessorTok{\#define PES\_AC 0.3       }\CommentTok{/* AC 30\% pes de la nota final */}
\PreprocessorTok{\#define PES\_PRA 0.7      }\CommentTok{/* PRA 70\% pes de la nota final */}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* Vector que conté les notes de }
\CommentTok{     * totes les activitats del curs }
\CommentTok{     */}
    \DataTypeTok{float}\NormalTok{ notes[MAX\_ACTIVITATS]; }

    \CommentTok{/* Nota d\textquotesingle{}avaluació continua: equival}
\CommentTok{     * a la mitjana de les 3 PAC }
\CommentTok{     */}
    \DataTypeTok{float}\NormalTok{ notaAC;}
    \DataTypeTok{float}\NormalTok{ notaFinalNumerica;}

    \CommentTok{/* String que conté la nota final }
\CommentTok{     * de l\textquotesingle{}assignatura (MH, A, B...) }
\CommentTok{     */}
    \DataTypeTok{char}\NormalTok{ notaFinal[MAX\_CHARS];}

    \CommentTok{/* Es demana des de teclat les notes}
\CommentTok{     * de les 3 PAC i de la PRA }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Nota PAC1 : "}\NormalTok{);}

    \CommentTok{/* L\textquotesingle{}assignació d\textquotesingle{}un valor es pot}
\CommentTok{     * fer directament sobre una posició}
\CommentTok{     * del vector}
\CommentTok{     */}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&notes[PAC1]);}

    \CommentTok{/* Idem per la resta d\textquotesingle{}activiats */}
\NormalTok{    printf(}\StringTok{"Nota PAC2 : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&notes[PAC2]);}
\NormalTok{    printf(}\StringTok{"Nota PAC3 : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&notes[PAC3]);}
\NormalTok{    printf(}\StringTok{"Nota PRA : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&notes[PRA]);}

    \CommentTok{/* Primer de tot, comprovem que}
\CommentTok{     * totes les notes del vector estiguin}
\CommentTok{     * dins del rang [0.0 .. 10.0]}
\CommentTok{     */}
    \ControlFlowTok{if}\NormalTok{ (notes[PAC1] \textgreater{} }\FloatTok{10.0}\NormalTok{ || notes[PAC2] \textgreater{} }\FloatTok{10.0}\NormalTok{ ||}
\NormalTok{        notes[PAC3] \textgreater{} }\FloatTok{10.0}\NormalTok{ || notes[PRA] \textgreater{} }\FloatTok{10.0}\NormalTok{ ||}
\NormalTok{        notes[PAC1] \textless{} }\FloatTok{0.0}\NormalTok{ || notes[PAC2] \textless{} }\FloatTok{0.0}\NormalTok{ ||}
\NormalTok{        notes[PAC3] \textless{} }\FloatTok{0.0}\NormalTok{ || notes[PRA] \textless{} }\FloatTok{0.0}\NormalTok{) \{}

\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Error detectat en una o més notes:"}\NormalTok{);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} S\textquotesingle{}atura el càlcul de la nota final.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}

\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}

        \CommentTok{/* En aquest punt sabem que totes les notes}
\CommentTok{         * estan dins del rang [0.0 .. 10.0]}
\CommentTok{         */}

        \CommentTok{/* Comprovem ara que la mitjana de les 3 PAC }
\CommentTok{         * no sigui inferior a 4}
\CommentTok{         */}
\NormalTok{        notaAC = (notes[PAC1] + notes[PAC2] + notes[PAC3]) / }\DecValTok{3}\NormalTok{;}

        \ControlFlowTok{if}\NormalTok{ (notaAC \textless{} }\DecValTok{4}\NormalTok{) \{}

           \CommentTok{/* Per donar millor visibilitat, mostrem només}
\CommentTok{            * el primer decimal de les notes numèriques}
\CommentTok{            */}
\NormalTok{           printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Nota mínima d\textquotesingle{}AC insuficient: \%.1f"}\NormalTok{, notaAC);}
\NormalTok{           printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} S\textquotesingle{}atura el càlcul de la nota final.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}

\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}

            \CommentTok{/* En aquest punt totes les notes són correctes,}
\CommentTok{             * per tant es pot començar amb el càlcul de la }
\CommentTok{             * nota final}
\CommentTok{             */}
\NormalTok{            notaFinalNumerica = notaAC * PES\_AC + notes[PRA] * PES\_PRA;}

            \CommentTok{/* Ara falta saber quina "grade letter" correspon}
\CommentTok{             * a la notaFinalNumerica calculada; ho solucionem}
\CommentTok{             * amb nous if{-}else aniuats}
\CommentTok{             */}
            \ControlFlowTok{if}\NormalTok{ (notaFinalNumerica \textless{}= }\FloatTok{2.9}\NormalTok{) \{}

                \CommentTok{/* Per assignar un string a una variable}
\CommentTok{                 * de tipus string, utilitzem la comanda}
\CommentTok{                 * strcpy, no pas \textquotesingle{}=\textquotesingle{}}
\CommentTok{                 */}
\NormalTok{                strcpy(notaFinal, }\StringTok{"D"}\NormalTok{);}

\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{if}\NormalTok{ (notaFinalNumerica \textless{}= }\FloatTok{4.9}\NormalTok{) \{}
\NormalTok{                    strcpy(notaFinal, }\StringTok{"C{-}"}\NormalTok{);}

\NormalTok{                \} }\ControlFlowTok{else}\NormalTok{ \{}
                    \ControlFlowTok{if}\NormalTok{ (notaFinalNumerica \textless{}= }\FloatTok{6.9}\NormalTok{) \{}
\NormalTok{                        strcpy(notaFinal, }\StringTok{"C+"}\NormalTok{);}

\NormalTok{                    \} }\ControlFlowTok{else}\NormalTok{ \{}
                        \ControlFlowTok{if}\NormalTok{ (notaFinalNumerica \textless{}= }\FloatTok{8.9}\NormalTok{) \{}
\NormalTok{                            strcpy(notaFinal, }\StringTok{"B"}\NormalTok{);}

\NormalTok{                        \} }\ControlFlowTok{else}\NormalTok{ \{}
                            \ControlFlowTok{if}\NormalTok{ (notaFinalNumerica \textless{}= }\FloatTok{9.9}\NormalTok{) \{}
\NormalTok{                                strcpy(notaFinal, }\StringTok{"A"}\NormalTok{);}

\NormalTok{                            \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{                                strcpy(notaFinal, }\StringTok{"MH"}\NormalTok{);}
\NormalTok{                            \}}
\NormalTok{                        \}}
\NormalTok{                    \}}
\NormalTok{                \}}
\NormalTok{            \}}

            \CommentTok{/* Per finalitar, mostrem tots els resultats}
\CommentTok{             * calculats per pantalla}
\CommentTok{             */}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Nota AC: \%.1f"}\NormalTok{, notaAC);}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Nota PRA: \%.1f"}\NormalTok{, notes[PRA]);}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Nota final: \%s (\%.1f)}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, notaFinal, notaFinalNumerica);}
\NormalTok{        \}}
\NormalTok{    \}}

    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{frequently-made-mistakes-2}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes-2}}

\hypertarget{strings-declaraciuxf3-com-a-vectors-de-caruxe0cters-en-llenguatge-algoruxedsmic}{%
\subsection{Strings: declaració com a vectors de caràcters en llenguatge algorísmic}\label{strings-declaraciuxf3-com-a-vectors-de-caruxe0cters-en-llenguatge-algoruxedsmic}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    name: vector[MAX_CHAR] of char;
end var
\end{verbatim}

En l'algorisme anterior, s'intenta emular el llenguatge C a l'hora de declarar una variable de tipus \texttt{string}, declarant-la com un vector de caràcters. Això és incorrecte i absolutament innecessari, perquè en llenguatge algorísmic \textbf{sí} que existeix el tipus \texttt{string}, i per tant la seva declaració és molt més senzilla.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    name: string;
end var
\end{verbatim}

\hypertarget{sintaxi-pruxf2pia-de-c-funcions-complexes}{%
\subsection{Sintaxi pròpia de C: funcions complexes}\label{sintaxi-pruxf2pia-de-c-funcions-complexes}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
function hotelCmp(hotel1: tHotel, hotel2: tHotel): boolean;
    if strcmp(hotel1.brand, hotel2.brand) = 0 then
        {...}
    end if
end function
\end{verbatim}

La intenció de l'algorisme és comparar dos camps de tipus string de les variables \texttt{hotel1} i \texttt{hotel2}. No obstant es fa ús de la funció \texttt{strcmp()}, la qual és pròpia de C i no existeix en llenguatge algorísmic.

En llenguatge algorísmic, la comparació de dues cadenes de caràcters és molt més senzilla: es fa directament amb \texttt{=}.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
function hotelCmp(hotel1: tHotel, hotel2: tHotel): boolean;
    if (hotel1.brand = hotel2.brand) then
        { ... }
    end if
\end{verbatim}

\hypertarget{estructura-alternativa-ifs-consecutius}{%
\subsection{Estructura alternativa: if's consecutius}\label{estructura-alternativa-ifs-consecutius}}

Aquest no és un error sintàctic o semàntic, sinó una mala pràctica de disseny.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
if discountHotel >= 0 and discountHotel <= 10 then
    writeString("Invalid data");
end if

if discountHotel > 10 and discountHotel <= 20 then
    writeString("Not bad");
end if

if discountHotel > 20 and discountHotel <= 50 then
    writeString("Good!");
end if
\end{verbatim}

L'algorisme anterior vol mostrar un missatge en pantalla en funció del valor de la variable \texttt{discountData}. Per aquest propòsit, res millor que una estructura alternativa, però no de la manera com està dissenyada.

Fixeu-vos que s'han construit tres blocs \texttt{if}\ldots{}\texttt{end} if independents i consecutius. Això vol dir que durant l'execució, tots els blocs s'avaluaran de forma consecutiva per decidir si cal executar el codi interior o no. Això no és necessari ni desitjable, ja que augmenta el temps d'execució.

Sempre que puguem, cal construir estructures alternatives niades i excloents, de forma que només s'avaluin les condicions estrictament imprescindibles.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
if discountHotel >= 0 and discountHotel <= 10 then
    writeString("Invalid data");
    else if discountHotel > 10 and discountHotel <= 20 then
        writeString("Not bad");
        else if discountHotel > 20 and discountHotel <= 50 then
            writeString("Good!");
        end if    
    end if
end if
\end{verbatim}

\hypertarget{estructura-alternativa-ifs-buits}{%
\subsection{Estructura alternativa: if's buits}\label{estructura-alternativa-ifs-buits}}

Aquest no és un error sintàctic o semàntic, sinó una mala pràctica de disseny.

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
if discountHotel > = 0 then
else
    writeString("Invalid data");
end if
\end{verbatim}

L'algorisme anterior vol mostrar un missatge d'error en pantalla si el valor de la variable discountHotel és negatiu, però l'estructura per fer-ho no és gens apropiada. En cas que es compleixi la condició \texttt{discountHotel\ \textgreater{}=\ 0}, l'estructura alternativa no executa res. Recordem que és possible una estructura \texttt{if} sense \texttt{else}, i de fet sembla que en aquest cas s'hagi afegit únicament perquè es creia el contrari.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
if discountHotel < 0 then
    writeString("Invalid data");
end if
\end{verbatim}

\hypertarget{estructura-alternativa-interrompre-un-algorisme-i}{%
\subsection{Estructura alternativa: interrompre un algorisme (I)}\label{estructura-alternativa-interrompre-un-algorisme-i}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
algorithm nameAlgorithm
    if discountHotel < 0 then
        writeString("Invalid data");
        end algorithm;
    else
        writeString("Continue...");
        { ... }
    end if
\end{verbatim}

Sovint ens demanen d'interrompre l'execució d'un algorisme en cas que es doni alguna situació, per exemple, un error en l'entrada de dades. A nivell de disseny algorísmic, no hi ha cap funció ni sentència pensada per efectuar aquesta acció de forma explícita. En l'agorisme de l'exemple, s'intenta fer-ho utiltzant la sentència \texttt{end\ algorithm}, però això no és correcte.

Senzillament cal muntar l'estructura alternativa de forma que quan es produeixi l'error, no s'executi cap més sentència, per exemple posant \textbf{tot} el codi a executar dins el bloc de l'\texttt{else}. Ens hem d'assegurar, això sí, que un cop sortim del bloc \texttt{if}\ldots{}\texttt{else}, l'algorisme no té res pendent per executar.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm nameAlgorithm
    if discountHotel < 0 then
        writeString("Invalid data");
    else
        writeString("Continue...");
        { ... }
    end if
end algorithm;
\end{verbatim}

\hypertarget{estructura-alternativa-interrompre-un-algorisme-ii}{%
\subsection{Estructura alternativa: interrompre un algorisme (II)}\label{estructura-alternativa-interrompre-un-algorisme-ii}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
algorithm nameAlgorithm
    if discountHotel < 0 then
        writeString("Invalid data");
        exit();
    else
        writeString("Continue...");
        { ... }
    end if
end algorithm
\end{verbatim}

Hi ha vegades que també es vol emular incorrectament en llenguatge algorísmic algunes funcions de C que interrompen l'execució del codi, com per exemple \texttt{exit()}. Això és incorrecte ja que aquesta funció no existeix en llenguatge algorísmic; de fet, en llenguatge C, encara que existeixi, també cal evitar-la, ja que el seu ús no és una bona pràctica de programació.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm nameAlgorithm
    if discountHotel < 0 then
        writeString("Invalid data");
    else
        writeString("Continue...");
        { ... }
    end if
end algorithm;
\end{verbatim}

\hypertarget{constants-i-nombres-valors-numuxe8rics-al-codi-hardcode}{%
\subsection{Constants i nombres: Valors numèrics al codi (hardcode)}\label{constants-i-nombres-valors-numuxe8rics-al-codi-hardcode}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
const 
    NUM_SEATS1: integer = 34;
    NUM_RIDES: integer = 3;
    A1: integer = 1;
    A2: integer = 2;
    A3: integer = 3;
end const

var
    emptySeats[3]: vector of integer;
end var

{ input values }
writeString("EMPTY SEATS  ");
writeString(NAME_RIDE1);
writeString("  >> ");
emptySeats[1] := readInteger();
\end{verbatim}

En l'algoritme anterior, es declara el vector d'enters \texttt{emptySeats} amb una longitud igual a 3 posicions. Posteriorment, es llegeix un enter i es guarda a la primera posició del vector. A l'enunciat de l'exercici es donaven unes constants ja declarades, i es demanava explícitament utilitzar-les per operar amb els vectors.

El motiu no és altre que introduir el (bon) costum de fer servir constants i evitar al màxim els valors numèrics directes al codi (tècnica coneguda com \emph{hardcode}). D'aquesta manera, és molt més fàcil mantenir el codi posteriorment i fer-hi modificacions.

En cas que volguéssim modificar la longitud del vector, o guardar els valors en posicions diferents, només hauríem de modificar la constant al principi del codi, en comptes d'haver de modificar totes les línies on apareixen aquests valors numèrics.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
const 
    NUM_SEATS1: integer = 34;
    NUM_RIDES: integer = 3;
    A1: integer = 1;
    A2: integer = 2;
    A3: integer = 3;
end const

var
    emptySeats[NUM_RIDES]: vector of integer;
end var

{input values}
writeString("EMPTY SEATS  ");
writeString(NAME_RIDE1);
writeString("  >> ");
emptySeats[A1] := readInteger();
\end{verbatim}

\hypertarget{constants-declaraciuxf3-de-constants-mal-ubicada}{%
\subsection{Constants: declaració de constants mal ubicada}\label{constants-declaraciuxf3-de-constants-mal-ubicada}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{verbatim}
#include <stdio.h>

int main(int argc, char **argv) {
    #define MAX_LEN 15
    char brand[MAX_LEN];
    return 0;
}
\end{verbatim}

Les constants s'han de declarar \textbf{al principi del bloc de codi}, i \textbf{fora} de qualsevol funció (sigui el \texttt{main} o una altra), ja que igual que els tipus de dades, les constants s'entenen globals a tot el programa. No és correcte obrir un bloc de declaració de constants dins un bloc central de codi, i encara menys obrir diversos blocs de constants a mesura que les necessitem.

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MAX\_LEN 15}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ brand[MAX\_LEN];}
    \CommentTok{/* ... */}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{strings-comparaciuxf3-directa}{%
\subsection{Strings: comparació directa}\label{strings-comparaciuxf3-directa}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MAX\_LEN 15}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ name1[MAX\_LEN];}
    \DataTypeTok{char}\NormalTok{ name2[MAX\_LEN];}
    \ControlFlowTok{if}\NormalTok{ (name1 == name2) \{}
        \CommentTok{/* ... */}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En C les cadenes de caràcters (així com la resta de vectors) \textbf{no} es poden comparar directament amb l'operador \texttt{==}. En el seu lloc tenim dues opcions:

\begin{itemize}
\tightlist
\item
  En el cas dels vectors, es poden comparar element a element, de forma individual
\item
  En el cas dels strings, el C disposa de funcions específiques, com ara \texttt{strcmp()}.
\end{itemize}

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MAX\_LEN 15}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ name1[MAX\_LEN];}
    \DataTypeTok{char}\NormalTok{ name2[MAX\_LEN];}
    \ControlFlowTok{if}\NormalTok{ (strcmp(name1, name2) == }\DecValTok{0}\NormalTok{) \{}
        \CommentTok{/* ... */}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac04}{%
\chapter{PAC04}\label{pac04}}

\hypertarget{com-tractar-elements-dun-vector-amb-un-bucle}{%
\section{Com tractar elements d'un vector amb un bucle}\label{com-tractar-elements-dun-vector-amb-un-bucle}}

Imaginem que ens demanen un programa que realitzi dues accions:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Llegir des del canal estàndard d'entrada (teclat) 5 números i introduir-los en un vector d'enters.
\item
  Mostrar pel canal estàndard de sortida (pantalla) els 5 números del vector d'enters del punt anterior.
\end{enumerate}

L'algorisme podria ser el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
   MAX_NUMS: integer = 5;
end const

algorithm vectorDeNumeros
   var
      i: integer;
      vectorNumeros: vector[MAX_NUMS] of integer;
   end var

   { Assignar valor a cada posició del vector des de teclat }
   for i := 1 to MAX_NUMS do
      writeString("Introdueix número : ");
      vectorNumeros[i] := readInteger();
   end for

   { Mostrar per pantalla quin valor hi ha a cada posició del vector:}
   { es podria haver utilitzat un bucle for, però ho implemento amb un while }
   { perquè es vegi que també és possible fer-ho }
   i := 1;

   while i ≤ MAX_NUMS do
      writeString("La posició ");
      writeInteger(i);
      writeString(" del vector conté el número ");
      writeInteger(vectorNumeros[i]);

      { És molt important que amb un bucle while incrementem la variable que utilitzem d'índex }
      { abans de finalitzar tot el bloc d'instruccions que executa, ja que en cas contrari el seu }
      { valor sempre seria de i == 1 }
      i := i+1;
   end while

end algorithm
\end{verbatim}

Com es pot veure, per tal d'insertar/llegir els elements d'un vector aprofitem la iteració d'un bucle per recorre'ls tots, un a un, mitjançant una variable que utilitzem d'índex (en aquests casos, la variable \texttt{i}).

La traducció a C de l'algorisme podria ser així:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MAX\_NUMS 5}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ vectorNumeros [MAX\_NUMS];}
    \DataTypeTok{int}\NormalTok{ i;}

    \CommentTok{/* Assignar valor a cada posició del vector des de teclat */}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} MAX\_NUMS; i++) \{}
\NormalTok{        printf(}\StringTok{"Introdueix número : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%d"}\NormalTok{, \&vectorNumeros[i]);}
\NormalTok{    \}}

    \CommentTok{/* Mostrar per pantalla quin valor hi ha a cada posició del vector:}
\CommentTok{     * es podria haver utilitzat un bucle for, però ho implemento amb un while}
\CommentTok{     * perquè es vegi que també és possible fer{-}ho }
\CommentTok{     */}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{while}\NormalTok{ (i \textless{} MAX\_NUMS) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{La posició \%d del vector conté el número \%d"}\NormalTok{, i, vectorNumeros[i]);}
        \CommentTok{/* És molt important que amb un bucle while incrementem la variable que utilitzem d\textquotesingle{}índex}
\CommentTok{         * abans de finalitzar tot el bloc d\textquotesingle{}instruccions que executa, ja que en cas contrari el seu}
\CommentTok{         * valor sempre seria de i == 0 }
\CommentTok{         */}
\NormalTok{        i = i+}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{entrada-contuxednua-de-valors-amb-un-bucle}{%
\section{Entrada contínua de valors amb un bucle}\label{entrada-contuxednua-de-valors-amb-un-bucle}}

Imaginem que hem de fer un programa que vagi demanant números indefinidament i que finalitzi únicament en el cas que el número introduit sigui parell.

Una possible forma de fer-ho utilitzant un únic \texttt{while} seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ numero;}

    \CommentTok{/* Demanem una primera vegada el número a validar}
\CommentTok{     * just abans d\textquotesingle{}entrar al bucle }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Tecleja un número parell : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numero);}

    \ControlFlowTok{while}\NormalTok{ ((numero \% }\DecValTok{2}\NormalTok{) != }\DecValTok{0}\NormalTok{) \{}
        \CommentTok{/* Entra al bucle en el cas que el}
\CommentTok{         * residu de la divisió per 2 sigui }
\CommentTok{         * diferent de 0 (equival a no ser parell) }
\CommentTok{         */}
\NormalTok{        printf(}\StringTok{"El número \%d no és parell !!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero);}
        \CommentTok{/* Tornem a demanar un número, ara ja}
\CommentTok{         * dins del bucle }
\CommentTok{         */}
\NormalTok{        printf(}\StringTok{"Tecleja un número parell : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%d"}\NormalTok{, \&numero);}
\NormalTok{    \}}
\NormalTok{    printf(}\StringTok{"El número \%d és parell}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Abans d'entrar al bucle demanem el valor de la variable \texttt{numero}. A continuació s'utilitza la condició de bucle per validar si es tracta d'un número parell o senar:

\begin{itemize}
\tightlist
\item
  Si el número es parell, no s'entra al bucle.
\item
  Si el número és senar es compleix la condició del bucle i s'hi entra; dins del bucle es torna a demanar un valor per la variable numero i es torna a actuar igual que abans:

  \begin{itemize}
  \tightlist
  \item
    Si és senar, no se surt del bucle.
  \item
    En cas contrari, se surt del bucle.
  \end{itemize}
\end{itemize}

Finalment es mostra per pantalla el missatge \emph{``El número X és parell''}.

\hypertarget{com-tractar-valors-en-muxfaltiples-vectors}{%
\section{Com tractar valors en múltiples vectors}\label{com-tractar-valors-en-muxfaltiples-vectors}}

Imaginem que volem introduir per teclat una sèrie de dades dels treballadors de la nostra empresa: dni, dies d'antiguitat i sou brut anual. Aquestes dades les introduïrem en tres vectors diferents: un pels DNI, l'altre per l'antiguitat i l'últim pel sou brut anual. El valor del sou net menual es calcularà a partir del brut i es desarà també en un vector.

El programa ha de demanar per teclat les dades de 5 empleats, i al finalitzar mostrarà els valors per pantalla de la següent forma:

\includegraphics{./img/play.png}

\begin{verbatim}
>> empleat: 39284019x
   antiguitat (dies): 784
   brut anual (€): 36874.78
   net mensual (€): 1659.36

>> empleat: 31214557m
   antiguitat (dies): 128
   brut anual (€): 20015.30
   net mensual (€): 1086.54
\end{verbatim}

El sou net mensual es calcula aplicant la següent retenció, i posteriorment dividint per 14 pagues:

\begin{longtable}[]{@{}cc@{}}
\toprule
sou brut & retenció\tabularnewline
\midrule
\endhead
sou \textless12450.0€ & 19.0\%\tabularnewline
12450.0€ \textless= sou \textless{} 20200.0€ & 24.0\%\tabularnewline
20200.0€ \textless= sou \textless{} 35200.0€ & 30.0\%\tabularnewline
35200.0€ \textless= sou \textless{} 60000.0€ & 37.0\%\tabularnewline
sou \textgreater{} 60000.0€ & 45.0\%\tabularnewline
\bottomrule
\end{longtable}

L'algorisme podria ser el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    MAX_ELEMS: integer = 5;
    TRAM1: float = 12450.0;
    RETENCIO1: float = 19.0;
    TRAM2: float = 20200.0;
    RETENCIO2: float = 24.0;
    TRAM3: float = 35200.0;
    RETENCIO3: float = 30.0;
    TRAM4: float = 60000.0;
    RETENCIO4: float = 37.0;
    RETENCIO5: float = 45.0;
    NUM_PAGUES: integer = 14;
end const

algorithm vectorsDeVehicles

    var
        vDni: vector[MAX_ELEMS] of string;
        vAntiguitat: vector[MAX_ELEMS] of integer;
        vBrutAnual: vector[MAX_ELEMS] of real;
        vNetMensual: vector[MAX_ELEMS] of real;
        i: integer;
    end var

    { La lectura de dades des del canal d'entrada }
    { S'utilitza un únic índex, 'i', per recórrer tots els vectors }
    for i := 1 to MAX_ELEMS do
        writeString("dades empleat num. ");
        writeInteger(i);
        writeString(":");
        writeString(">> dni : ");
        vDni[i] := readString();
        writeString(">> antiguitat : ");
        vAntiguitat[i] := readInteger();
        writeString(">> brut anual : ");
        vBrutAnual[i] := readReal();
        
        { Càlcul del sou net mensual }
        if (vBrutAnual[i] < TRAM1) then
            vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO1/100)) / NUM_PAGUES;
        else
            if (vBrutAnual[i] < TRAM2) then
                vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO2/100)) / NUM_PAGUES;
            else
                if (vBrutAnual[i] < TRAM3) then
                    vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO3/100)) / NUM_PAGUES;
                else
                    if (vBrutAnual[i] < TRAM4) then
                        vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO4/100)) / NUM_PAGUES;
                    else
                        vNetMensual[i] := (vBrutAnual[i] - (vBrutAnual[i]*RETENCIO5/100)) / NUM_PAGUES;
                    end if
                end if
            end if
        end if
    end for
   
    { Es mostren les dades pel canal de sortida }
    { S'utilitza un únic índex, 'i', per recórrer tots els vectors }
    for i := 1 to MAX_ELEMS do
        writeString(">> empleat: ");
        writeString(vDni[i]);
        writeString("   antiguitat (dies): ");
        writeInteger(vAntiguitat[i]);
        writeString("   brut anual (€): ");
        writeInteger(vBrutAnual[i]);
        writeString("   net mensual (€): ");
        writeInteger(vNetMensual[i]);
    end for

end algorithm
\end{verbatim}

Com ho podem implementar en C? Una possible solució seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MAX\_ELEMS 5}
\PreprocessorTok{\#define TRAM1 12450.0}
\PreprocessorTok{\#define RETENCIO1 19.0}
\PreprocessorTok{\#define TRAM2 20200.0}
\PreprocessorTok{\#define RETENCIO2 24.0}
\PreprocessorTok{\#define TRAM3 35200.0}
\PreprocessorTok{\#define RETENCIO3 30.0}
\PreprocessorTok{\#define TRAM4 60000.0}
\PreprocessorTok{\#define RETENCIO4 37.0}
\PreprocessorTok{\#define RETENCIO5 45.0}
\PreprocessorTok{\#define NUM\_PAGUES 14}
\PreprocessorTok{\#define MAX\_DNI 9+1}

\KeywordTok{typedef} \DataTypeTok{char}\NormalTok{ tDni[MAX\_DNI];}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tDni vDni[MAX\_ELEMS];}
    \DataTypeTok{int}\NormalTok{ vAntiguitat[MAX\_ELEMS];}
    \DataTypeTok{float}\NormalTok{ vBrutAnual[MAX\_ELEMS];}
    \DataTypeTok{float}\NormalTok{ vNetMensual[MAX\_ELEMS];}
    \DataTypeTok{int}\NormalTok{ i;}

    \CommentTok{/* La lectura de dades des del canal d\textquotesingle{}entrada.}
\CommentTok{       S\textquotesingle{}utilitza un únic índex, i, per recórrer tots els vectors */}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} MAX\_ELEMS; i++) \{}
\NormalTok{        printf(}\StringTok{"dades empleat num. \%d : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, i);}
\NormalTok{        printf(}\StringTok{"\textgreater{}\textgreater{} dni : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vDni[i]);}
\NormalTok{        printf(}\StringTok{"\textgreater{}\textgreater{} antiguitat : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%d"}\NormalTok{, \&vAntiguitat[i]);}
\NormalTok{        printf(}\StringTok{"\textgreater{}\textgreater{} brut anual : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&vBrutAnual[i]);}
        
        \CommentTok{/* Càlcul del sou net mensual */}
        \ControlFlowTok{if}\NormalTok{ (vBrutAnual[i] \textless{} TRAM1) \{}
\NormalTok{            vNetMensual[i] = (vBrutAnual[i] {-} (vBrutAnual[i]*RETENCIO1/}\DecValTok{100}\NormalTok{)) / NUM\_PAGUES;}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
            \ControlFlowTok{if}\NormalTok{ (vBrutAnual[i] \textless{} TRAM2) \{}
\NormalTok{                vNetMensual[i] = (vBrutAnual[i] {-} (vBrutAnual[i]*RETENCIO2/}\DecValTok{100}\NormalTok{)) / NUM\_PAGUES;}
\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{if}\NormalTok{ (vBrutAnual[i] \textless{} TRAM3) \{}
\NormalTok{                    vNetMensual[i] = (vBrutAnual[i] {-} (vBrutAnual[i]*RETENCIO3/}\DecValTok{100}\NormalTok{)) / NUM\_PAGUES;}
\NormalTok{                \} }\ControlFlowTok{else}\NormalTok{ \{}
                    \ControlFlowTok{if}\NormalTok{ (vBrutAnual[i] \textless{} TRAM4) \{}
\NormalTok{                        vNetMensual[i] = (vBrutAnual[i] {-} (vBrutAnual[i]*RETENCIO4/}\DecValTok{100}\NormalTok{)) / NUM\_PAGUES;}
\NormalTok{                    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{                        vNetMensual[i] = (vBrutAnual[i] {-} (vBrutAnual[i]*RETENCIO5/}\DecValTok{100}\NormalTok{)) / NUM\_PAGUES;}
\NormalTok{                    \}}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    
    \CommentTok{/* Es mostren les dades pel canal de sortida.}
\CommentTok{       S\textquotesingle{}utilitza un únic índex, i, per recórrer tots els vectors */}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} MAX\_ELEMS; i++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} empleat: \%s }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vDni[i]);}
\NormalTok{        printf(}\StringTok{"   antiguitat (dies): \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vAntiguitat[i]);}
\NormalTok{        printf(}\StringTok{"   brut anual (€): \%.2f }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vBrutAnual[i]);}
\NormalTok{        printf(}\StringTok{"   net mensual (€): \%.2f }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vNetMensual[i]);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dins del bucle utilitzem la variable \texttt{i} com a índex per anar recorrent tots els vectors alhora.

En els dos casos la inserció dels valors en els vectors la fem de la mateixa forma: utilitzem l'índex \texttt{i} per determinar la posició del vector on ubicarem els valors:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* ... */}
\NormalTok{scanf(}\StringTok{"\%s"}\NormalTok{, vDni[i]);}
\CommentTok{/* ... */}
\NormalTok{scanf(}\StringTok{"\%d"}\NormalTok{, \&vAntiguitat[i]);}
\CommentTok{/* ... */}
\NormalTok{scanf(}\StringTok{"\%f"}\NormalTok{, \&vBrutAnual[i]);}
\end{Highlighting}
\end{Shaded}

Al final de l'exemple mostrem tots els empleats introduïts mitjançant un segon bucle, mostrant totes les dades introduïdes anteriorment i les calculades.

\hypertarget{definiciuxf3-chars-vs-strings}{%
\section{Definició chars vs strings}\label{definiciuxf3-chars-vs-strings}}

En el llenguatge C, els caràcters es defineixen sempre amb cometa simple \texttt{\textquotesingle{}}, mentre que pels string s'utilitza la cometa doble \texttt{"}.

Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* Assignació de valor a un string amb cometa doble */}
    \DataTypeTok{char}\NormalTok{ salutacio[]= }\StringTok{"Hi World"}\NormalTok{;}
    \CommentTok{/* Assignació de valor a un char amb cometa simple */}
    \DataTypeTok{char}\NormalTok{ exclamacio = }\CharTok{\textquotesingle{}!\textquotesingle{}}\NormalTok{;}

\NormalTok{    printf(}\StringTok{"\%s \%c}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, salutacio, exclamacio);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-mitjanapes}{%
\section{Exemple: mitjanaPes}\label{exemple-mitjanapes}}

Imaginem que volem fer un programa que ens ajudi a calcular el nostre pes promig setmanal. Afegirem per teclat les mesures diàries del nostre pes al programa i, en cas de trobar algun valor incoherent l'obviarà i el tornarà a demanar.

En llenguatge algorísmic ho podem implementar de la següent forma:

\includegraphics{./img/alg.png}

\begin{verbatim}
const
    NUM_DIES: integer = 7;
    PES_MIN: real = 50.0;
    PES_MAX: real = 110.0;
end const

algorithm mitjanaPes

    var
        i: integer;    { Comptador que utilitzarà el nostre programa }
        aux: real;   { Variable auxiliar per la lectura de pesos }
        vectorPesos: vector[NUM_DIES] of real;   { Pes en Kg: 79.5, ... }
        sumaPesos: real;
    end var

    i := 1;
    sumaPesos := 0;

    { Es llegeix des de teclat els pesos diaris, un a un }
    while i ≤ NUM_DIES do

        { Llegim un valor des del canal standard d'entrada }
        writeString("Introdueix pes (Kg.) : ");
        aux := readReal();

        { A continuació cal revisar que aquest valor sigui coherent. Prenem com a valors
        "possibles" aquells que estiguin entre PES_MIN i PES_MAX. Fixeu-vos que la lectura
        es desa temporalment a la variable aux: quan haguem validat que contingui un valor
        vàlid, l'afegirem dins del vector de pesos }

        if (PES_MIN ≤ aux) and (aux ≤ PES_MAX) then
            { En aquest punt, la variable aux conté un valor correcte, amb el que ja el podem
            afegir al vector de pesos }
            vectorPesos[i] := aux;

            { El següent punt és molt important: com que ja hem afegit el pes correcte,
            incrementarem la variable 'i', la qual ens serveix per accedir a una nova posició
            del vector a la següent iteració del bucle }
            i = i + 1;

        else
            { En cas contrari, el pes es incorrecte amb el que mostrem el corresponent
            missatge d'error }
            writeString("Pes incorrecte!");

            { Important: aquí no incrementem la variable i, ja que el valor no és correcte; volem
            que en la següent iteració del bucle, es continuï intentant afegir el valor llegit dins
            de la posició 'i' del bucle }

        end if

        { En aquest punt tenim el vectorPesos que té 7 (=NUM_DIES) pesos vàlids }

        { Ara utilitzarem un segon bucle per recórrer tots els valors del vector i fer el càlcul
        demanat: la mitjana de tots ells. Si haguéssim volgut, ho hauríem pogut fer tot
        en un únic bucle, però he preferit separar-ho perquè quedi més clar què es fa
        dins de cadascun dels dos bucles}

        for  i := 1 to NUM_DIES do

            { Dins de la variable sumaPesos hi anem sumant cadascun dels pesos
            de les posicions del vector }
            sumaPesos := sumaPesos + vectorPesos[i];
       
        end for

        { Per calcular la mitjana, únicament ens falta dividir el valor sumaPesos pel
        número total de pesos introduïts o, el que és el mateix, NUM_DIES }
        writeString("La mitjana setmanal del pes és : ");
        writeReal(sumaPesos / NUM_DIES);

end algorithm
\end{verbatim}

Una possible implementació en llenguatge C d'aquest algorisme pot ser la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define NUM\_DIES 7}
\PreprocessorTok{\#define PES\_MIN 50.0}
\PreprocessorTok{\#define PES\_MAX 110.0}

\DataTypeTok{int}\NormalTok{ main (}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv)\{}
    \DataTypeTok{float}\NormalTok{ vectorPesos[NUM\_DIES];}
    \DataTypeTok{int}\NormalTok{ i;}
    \DataTypeTok{float}\NormalTok{ aux;}
    \DataTypeTok{float}\NormalTok{ sumaPesos;}

\NormalTok{    i = }\DecValTok{0}\NormalTok{; }\CommentTok{/* Important! en llenguatge C els vectors comencen pel 0 */}
\NormalTok{    sumaPesos = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Primer bucle: introducció i validació de dades */}
    \ControlFlowTok{while}\NormalTok{ (i\textless{}NUM\_DIES) \{}

\NormalTok{        printf(}\StringTok{"Introdueix pes (Kg.) : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&aux);}

        \ControlFlowTok{if}\NormalTok{ (PES\_MIN \textless{}= aux \&\& aux \textless{}= PES\_MAX) \{}
\NormalTok{            vectorPesos[i] = aux;}
\NormalTok{            i = i+}\DecValTok{1}\NormalTok{;}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            printf(}\StringTok{"Pes incorrecte!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        \}}
\NormalTok{    \}}

    \CommentTok{/* Segon bucle: càlcul intermig per la mitjana de pesos */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}NUM\_DIES; i++) \{}
\NormalTok{        sumaPesos = sumaPesos + vectorPesos[i];}
\NormalTok{    \}}

\NormalTok{    printf(}\StringTok{"La mitjana setmanal del pes és : \%.2f"}\NormalTok{, sumaPesos/NUM\_DIES);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{frequently-made-mistakes-3}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes-3}}

\hypertarget{estructura-iterativa-for-vs-while}{%
\subsection{Estructura iterativa: for vs while}\label{estructura-iterativa-for-vs-while}}

Aquest no és un error sintàctic o semàntic, sinó un error de disseny freqüent.

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\PreprocessorTok{\#define NUM 10}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ i;}
    \DataTypeTok{char}\NormalTok{ password[NUM] = \{}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{\};}
    
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; password[i] != }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{; i++)\{}
        \CommentTok{/* ... */}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En el codi anterior, sembla que volem recórrer un vector de caràcters element a element, per executar alguna acció. Per fer-ho, decidim utilitzar un bucle i una condició final: les iteracions s'aturaran en el moment en què ens trobem amb el caràcter especial \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}, finalitzador de cadena de caràcters.

El problema és que el bucle \texttt{for} no és l'estructura més indicada per resoldre aquest algorisme, ja que està pensat per repetir un bloc de codi un nombre de vegades predeterminat, basat gairebé sempre en un índex (\texttt{i}) que s'ha d'incrementar/decrementar des d'un valor inicial a un de final. En aquest cas, la condició final no té res a veure amb el valor numèric de l'índex, i per tant és molt millor utilitzar el bucle \texttt{while}.

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}
\PreprocessorTok{\#define NUM 10}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ i;}
    \DataTypeTok{char}\NormalTok{ password[NUM] = \{}\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}1\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}h\textquotesingle{}}\NormalTok{, }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{\};}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{while}\NormalTok{ (password[i] != }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{)\{}
        \CommentTok{/* ... */}
\NormalTok{    i++;}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

És important recordar que en el cas de l'estructura \texttt{while}, l'índex \texttt{i} \textbf{no s'actualitza automàticament}: cal fer-ho manualment abans de tancar el bloc.

\hypertarget{pac05}{%
\chapter{PAC05}\label{pac05}}

\hypertarget{strcmp}{%
\section{strcmp()}\label{strcmp}}

En què es basa \texttt{strcmp()} per decidir que, per exemple, la lletra \texttt{\textquotesingle{}O\textquotesingle{}} és més gran que la lletra \texttt{\textquotesingle{}A\textquotesingle{}}?

La resposta la tenim en el codi ASCII (numèric) que té associat cada caràcter. Per aquest motiu és normal que interpreti diferent una \texttt{\textquotesingle{}A\textquotesingle{}} i una \texttt{\textquotesingle{}a\textquotesingle{}}, ja que són caràcters diferents; de fet segons els valors ASCII, tenim que \texttt{\textquotesingle{}A\textquotesingle{}} \textless{} \texttt{\textquotesingle{}a\textquotesingle{}}.

Per si volem consultar la taula ASCII per internet, la podem generar nosaltres mateixos de la següent forma:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
    \CommentTok{/* Relació de caràcters ASCII (només és un subconjunt!)}
\CommentTok{       ordenats de més petit a més gran */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{33}\NormalTok{; i\textless{}=}\DecValTok{126}\NormalTok{; i++) \{}
\NormalTok{        printf(}\StringTok{"\%d : \%c}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, i, i);}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{scanf}{%
\section{scanf()}\label{scanf}}

Quan utilitzem \texttt{scanf()} fins ara sempre li hem passat el nom de la variable precedit per \texttt{\&}. Això significa que realmente li estem passant la posició de la memòria on resideix la variable facilitada.

Així, per exemple, quan fem la següent operació \texttt{scanf("\%d",\ \&numero);} estem passant el valor que introduïm per teclat directament a la posició de memòria on tenim desada la variable \texttt{numero}. D'aquí ve utilitzar \texttt{\&numero} en comptes de \texttt{numero}. El mateix comportament tenim pels tipus primitius \texttt{char}, \texttt{float}, etc.

Els vectors de caràcters en llenguatge C tenen una característica: el nom de l'array conté l'adreça de memòria on està desada la primera posició de l'array.

Per exemple, quan executem \texttt{scanf("\%s",\ cadena);} el valor de cadena és l'adreça de memòria inicial on està ubicat l'array. Dit d'una altra manera, cadena conté el mateix valor que \texttt{\&cadena{[}0{]}} (és una altra forma que tenim per referir-nos a la posició inicial en memòria de l'array).

A continuació s'adjunta un exemple amb tots aquests conceptes:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#define MAXIM 10}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ cadena[MAXIM];}
    \DataTypeTok{int}\NormalTok{ numero;}

\NormalTok{    printf(}\StringTok{"Reservada la posició de memòria \%p per la variable numero}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, \&numero);}
\NormalTok{    printf(}\StringTok{"Reservada la posició de memòria \%p per la variable cadena}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cadena);}
\NormalTok{    printf(}\StringTok{"Reservada la posició de memòria \%p per la variable cadena}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, \&cadena[}\DecValTok{0}\NormalTok{]);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Introdueix un número enter: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numero);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Introdueix una cadena: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{,cadena);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Has assignat els següents valors :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"numero = \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero);}
\NormalTok{    printf(}\StringTok{"cadena = \%s }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cadena);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{el-finalitzador-0-i-strcmp}{%
\section{El finalitzador `\textbackslash0' i strcmp()}\label{el-finalitzador-0-i-strcmp}}

Com es va veure al mòdul \textbf{Cadenes de caràcters en C} de la xWiki, \emph{``una cadena de caràcters o string és una seqüència de caràcters finalitzada pel caràcter `\textbackslash0'\,''}. Per tant hem de tenir en compte que el finalitzador \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} càpiga a la nostra variable, ja que aquesta és la forma que té C de saber on s'acaba un string en memòria.

Imaginem que tenim tres cadenes, amb el mateix contingut però de mida diferent (podem tenir posicions buides). Què passa si les comparem? I si comparem amb una cadena de mateix contingut però sense finalitzador \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}?

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ ciutat1[}\DecValTok{7}\NormalTok{] = }\StringTok{"Girona"}\NormalTok{;}
    \DataTypeTok{char}\NormalTok{ ciutat2[}\DecValTok{8}\NormalTok{] = }\StringTok{"Girona"}\NormalTok{;}
    \DataTypeTok{char}\NormalTok{ ciutat3[}\DecValTok{6}\NormalTok{] = }\StringTok{"Girona"}\NormalTok{; }\CommentTok{/* no conté el \textquotesingle{}\textbackslash{}0\textquotesingle{} final */}

    \CommentTok{/* si strcmp retorna 0 significa que les dues cadenes són iguals */}
\NormalTok{    printf (}\StringTok{"Les variables ciutat1 i ciutat2 són iguals? \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, strcmp(ciutat1, ciutat2));}
\NormalTok{    printf (}\StringTok{"Les variables ciutat1 i ciutat3 són iguals? \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, strcmp(ciutat1, ciutat3));}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

La forma que tenim per forçar que una cadena no contingui el finalitzador és limitant la seva mida als caràcters que contindrà, sense tenir en compte reservar-ne un pel \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}}. En aquest cas ho fem amb char \texttt{ciutat3{[}6{]}\ =\ "Girona"}.

La sortida generada és la següent:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Les variables ciutat1 i ciutat2 són iguals? }\DecValTok{0}
\NormalTok{Les variables ciutat1 i ciutat3 són iguals? {-}}\DecValTok{1}
\end{Highlighting}
\end{Shaded}

D'aquí la importància del finalitzador de cadenes de caràcters. Per tant, si per exemple tenim una variable \texttt{x} de tipus string i de mida màxima 15, realment al nostre programa la definirem amb longitud \textbf{15+1}, per tal que hi càpiga el finalitzador \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} en cas que s'ocupin els 15 caràcters anteriors.

\hypertarget{el-finalitzador-0-i-strlen}{%
\section{El finalitzador `\textbackslash0' i strlen()}\label{el-finalitzador-0-i-strlen}}

A continuació s'exposa un exemple en el qual es mostra la importància del finalitzador \texttt{\textquotesingle{}\textbackslash{}0\textquotesingle{}} en la funció \texttt{strlen()} de C, la qual ens retorna la mida d'una cadena de caràcters :

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_LLETRES 8+1}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_LLETRES];}
    \DataTypeTok{int}\NormalTok{ numLletres;}

\NormalTok{    printf(}\StringTok{"Introdueix un nom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, nom);}

    \CommentTok{/* Exemple: si en aquest punt hem teclejat el nom}
\CommentTok{     * Quim, dins de la cadena de caràcters nom[]}
\CommentTok{     * tindrem les següents dades:}
\CommentTok{     *}
\CommentTok{     * nom[0] = \textquotesingle{}Q\textquotesingle{}}
\CommentTok{     * nom[1] = \textquotesingle{}u\textquotesingle{}}
\CommentTok{     * nom[2] = \textquotesingle{}i\textquotesingle{}}
\CommentTok{     * nom[3] = \textquotesingle{}m\textquotesingle{}}
\CommentTok{     * nom[4] = \textquotesingle{}\textbackslash{}0\textquotesingle{} (finalitzador de l\textquotesingle{}string)}
\CommentTok{     * nom[5] = valor aleatori}
\CommentTok{     * nom[6] = valor aleatori}
\CommentTok{     * nom[7] = valor aleatori}
\CommentTok{     * nom[8] = valor aleatori}
\CommentTok{     *}
\CommentTok{     * El finalitzador \textquotesingle{}\textbackslash{}0\textquotesingle{} s\textquotesingle{}afegeix automàticament}
\CommentTok{     * en llegir un string per teclat amb scanf.}
\CommentTok{     * }
\CommentTok{     * La comanda strlen(...) va recorrent l\textquotesingle{}string posició}
\CommentTok{     * a posició per saber la seva longitud. Quan finalitza}
\CommentTok{     * aquest recorregut? hi ha dues opcions possibles:}
\CommentTok{     *}
\CommentTok{     * {-} quan troba el finalitzador \textquotesingle{}\textbackslash{}0\textquotesingle{}}
\CommentTok{     * {-} quan arriba a la darrera posició de l\textquotesingle{}string}
\CommentTok{     *}
\CommentTok{     * Per tant, si com a nom hem entrat Quim, el valor que }
\CommentTok{     * retornarà strlen(...) serà 4.}
\CommentTok{     */}

\NormalTok{    numLletres = strlen(nom);}

\NormalTok{    printf(}\StringTok{"El nom }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ té \%d lletres.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, nom, numLletres);}

    \CommentTok{/* Què passa si sobreescrivim el finalitzador \textquotesingle{}\textbackslash{}0\textquotesingle{} amb}
\CommentTok{     * un caràcter qualsevol? per exemple \textquotesingle{}X\textquotesingle{}}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Sobreescrivim el finalitzador \textquotesingle{}}\SpecialCharTok{\textbackslash{}\textbackslash{}}\StringTok{0\textquotesingle{}."}\NormalTok{);}
\NormalTok{    nom[numLletres] = }\CharTok{\textquotesingle{}X\textquotesingle{}}\NormalTok{;}

    \CommentTok{/* Tornem a calcular la longitud de l\textquotesingle{}string */}
\NormalTok{    numLletres = strlen(nom);}

    \CommentTok{/* Per quin motiu ara ha canviat la longitud de la}
\CommentTok{     * variable nom, si no l\textquotesingle{}hem tornat a redefinir?}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Ara el nom }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ té \%d lletres.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, nom, numLletres);}

    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Si s'executa el programa, la sortida obtinguda serà similar a la següent:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix un nom: Quim}
\NormalTok{El nom }\StringTok{"Quim"}\NormalTok{ té }\DecValTok{4}\NormalTok{ lletres.}

\NormalTok{Sobreescrivim el finalitzador }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{.}
\NormalTok{Ara el nom }\StringTok{"QuimX�!��"}\NormalTok{ té }\DecValTok{9}\NormalTok{ lletres.}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-comparaciostrings}{%
\section{Exemple: comparacioStrings}\label{exemple-comparaciostrings}}

La forma com comparem strings amb llenguatge algorísmic és diferent que no en llenguatge C:

\begin{itemize}
\tightlist
\item
  Llenguatge algorísmic: la comparació entre strings es fa amb \texttt{=}.
\item
  Llenguatge C: la comparació entre strings es fa amb la funció \texttt{strcmp()}, la qual realitza una comparació caràcter a caràcter de les dues cadenes i com a resultat:

  \begin{itemize}
  \tightlist
  \item
    Retorna \texttt{0}: si les dues cadenes són \textbf{iguals}.
  \item
    Retorna \texttt{-1}: si la primera cadena \textbf{\textless{}} segona cadena.
  \item
    Retorna \texttt{1}: si la primera cadena \textbf{\textgreater{}} segona cadena.
  \end{itemize}
\end{itemize}

Un exemple on realitza una comparació de dos strings pot ser el següent:

\includegraphics{./img/alg.png}

\begin{verbatim}
algorithm comparacioStrings

    var
        cadena1: string;
        cadena2: string;
    end var

    cadena1:= "UOC";
    cadena2:= "UAB";

    if (cadena1 = cadena2) then
        writeString(cadena1);
        writeString(" = ");
        writeString(cadena2);
    else
        if (cadena1 > cadena2) then
            writeString(cadena1);
            writeString(" > ");
            writeString(cadena2);
        else
            writeString(cadena1);
            writeString(" < ");
            writeString(cadena2);
        end if
    end if

end algorithm
\end{verbatim}

En llenguatge C, la comparació caràcter a caràcter entre els string \texttt{"UOC"} i \texttt{"UAB"} que realitza la funció \texttt{strcmp} és la següent:

\begin{itemize}
\tightlist
\item
  Caràcters de la posició 0 dels dos string: \textbf{U}OC vs \textbf{U}AB. Són iguals, amb el que passa a comparar el següent caràcter.
\item
  Caràcters de la posició 1 dels dos string: U\textbf{O}C vs U\textbf{A}B. Són diferents (\texttt{\textquotesingle{}O\textquotesingle{}} \textgreater{} \texttt{\textquotesingle{}A\textquotesingle{}}), finalitza la comparació i la funció \texttt{strcmp()} retorna el valor 1.
\end{itemize}

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_STRING 3+1}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}

    \DataTypeTok{char}\NormalTok{ cadena1[MAX\_STRING] = }\StringTok{"UOC"}\NormalTok{;}
    \DataTypeTok{char}\NormalTok{ cadena2[MAX\_STRING] = }\StringTok{"UAB"}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ resultatComparacio = }\DecValTok{0}\NormalTok{;}
    
\NormalTok{    resultatComparacio = strcmp(cadena1, cadena2);}
    
\NormalTok{      printf(}\StringTok{"Comparació strings }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ i }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cadena1, cadena2, resultatComparacio);}
    
      \ControlFlowTok{if}\NormalTok{ (resultatComparacio == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{            printf(}\StringTok{"El resultat \%d significa que l\textquotesingle{}string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ == string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"\textbackslash{}n}\StringTok{"}\NormalTok{, resultatComparacio, cadena1, cadena2);}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (resultatComparacio == {-}}\DecValTok{1}\NormalTok{) \{}
\NormalTok{            printf(}\StringTok{"El resultat \%d significa que l\textquotesingle{}string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ \textless{} string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"\textbackslash{}n}\StringTok{"}\NormalTok{, resultatComparacio, cadena1, cadena2);}
\NormalTok{    \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (resultatComparacio == }\DecValTok{1}\NormalTok{) \{}
\NormalTok{            printf(}\StringTok{"El resultat \%d significa que l\textquotesingle{}string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"}\StringTok{ \textgreater{} string }\SpecialCharTok{\textbackslash{}"}\StringTok{\%s}\SpecialCharTok{\textbackslash{}"\textbackslash{}n}\StringTok{"}\NormalTok{, resultatComparacio, cadena1, cadena2);     }
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El resultat de l'execució del programa en C és:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Comparació strings }\StringTok{"UOC"}\NormalTok{ i }\StringTok{"UAB"}\NormalTok{ = }\DecValTok{1}
\NormalTok{El resultat }\DecValTok{1}\NormalTok{ significa que l\textquotesingle{}string }\StringTok{"UOC"}\NormalTok{ \textgreater{} string }\StringTok{"UAB"}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-nuxf2mines}{%
\section{Exemple: nòmines}\label{exemple-nuxf2mines}}

Imaginem que volem un programa que ens permeti entrar les nòmines de tots els empleats de la nostra empresa. Un empleat el definim com a nom (cadena de caràcters) + nòmina (real). El programa ha de mostrar al final de tot la relació de nòmines de tots els empleats, la mitjana de totes les nòmines de l'empresa, i qui cobra més i menys a l'empresa.

Una possible forma de programa-ho seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_EMPLEATS 5}
\PreprocessorTok{\#define MAX\_NOM 20+1}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{float}\NormalTok{ nomina;}
\NormalTok{\} tEmpleat;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tEmpleat vEmpleats[MAX\_EMPLEATS];}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ maxNomina = }\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ minNomina = }\DecValTok{0}\NormalTok{;}
    \DataTypeTok{float}\NormalTok{ sumaNomines = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nom empleat : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].nom);}
\NormalTok{        printf(}\StringTok{"Nòmina : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&vEmpleats[i].nomina);}
\NormalTok{     \}}

\NormalTok{     printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Llistat de nòmines d\textquotesingle{}empleats : }\SpecialCharTok{\textbackslash{}n\textbackslash{}n}\StringTok{"}\NormalTok{);}

     \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
\NormalTok{        sumaNomines = sumaNomines + vEmpleats[i].nomina;}
        \ControlFlowTok{if}\NormalTok{ (vEmpleats[i].nomina \textgreater{} vEmpleats[maxNomina].nomina) \{}
\NormalTok{            maxNomina = i;}
\NormalTok{        \}}
        \ControlFlowTok{if}\NormalTok{ (vEmpleats[i].nomina \textless{} vEmpleats[minNomina].nomina) \{}
\NormalTok{            minNomina = i;}
\NormalTok{        \}}
\NormalTok{        printf(}\StringTok{"\%s {-}{-}\textgreater{} \%.2f €}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vEmpleats[i].nom, vEmpleats[i].nomina);}
\NormalTok{    \}}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Mitjana nònimes : \%.2f €"}\NormalTok{, sumaNomines/MAX\_EMPLEATS);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nòmina més alta : \%.2f € (\%s)"}\NormalTok{, vEmpleats[maxNomina].nomina, vEmpleats[maxNomina].nom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nòmina més baixa : \%.2f € (\%s)"}\NormalTok{, vEmpleats[minNomina].nomina, vEmpleats[minNomina].nom);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Com es pot veure, s'utilitza un vector de \texttt{tEmpleat} de forma que, donada una longitud màxima del vector, anirem introduint els \texttt{tEmpleat} un a un dins d'ell. Una vegada fet, tornem a recórrer el vector de \texttt{tEmpleat} i realitzar tots els càlculs que ens demanen, així com mostrar per pantalla les nòmines de tots els empleats.

En aquest exemple la variable i fa d'índex per recórrer el vector, i les variables \texttt{maxNomina} i \texttt{minNomina} també són índexos: indiquen en quina posició estàn els empleats amb la nòmina més alta i més baixa respectivament.

\hypertarget{exemple-brisca}{%
\section{Exemple: brisca}\label{exemple-brisca}}

Exemple amb diferents recorreguts realitzat sobre tuples guardades en un vector, utilitzant el joc de cartes de la brisca. Per tal d'explicar millor el plantejament de cada implementació, s'han afegit comentaris detallats dins del codi.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Punt de partida: sabem jugar perfectament}
\CommentTok{ * a la brisca (https://ca.wikipedia.org/wiki/Brisca), }
\CommentTok{ * però en canvi som un desastre havent de comptar}
\CommentTok{ * la puntuació de totes les cartes guanyades. Per}
\CommentTok{ * aquest motiu volem fer un programa que ens ajudi}
\CommentTok{ * en aquesta tasca (i també per practicar diferents}
\CommentTok{ * iteracions amb bucles). El programa demanarà per }
\CommentTok{ * teclat carta a carta i finalitzarà quan s\textquotesingle{}introdueixi}
\CommentTok{ * un tipus de coll diferent dels definits.}
\CommentTok{ * Haurà de generar les següents sortides:}
\CommentTok{ * 1. Llistar totes les cartes introduïdes.}
\CommentTok{ * 2. Mostrar la carta amb una puntuació més alta.}
\CommentTok{ * 3. Mostrar la puntuació total aconseguida.}
\CommentTok{ * 4. Comparar parelles de cartes (1a vs 2a, 2a vs 3a,}
\CommentTok{ *    3a vs 4a,...) i indicar si són del mateix coll.}
\CommentTok{ */}

\PreprocessorTok{\#define MAX\_NUM\_CARTES 48}
\PreprocessorTok{\#define NUM\_VALORS 13}
\PreprocessorTok{\#define MAX\_NUM\_COLLS 4}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{MONEDES, COPES, BASTOS, ESPASES, FINALITZAR\} tColl;}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tColl coll;}
    \DataTypeTok{int}\NormalTok{ numero;}
    \DataTypeTok{int}\NormalTok{ valor;}
\NormalTok{\} tCarta;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tCarta cartaAux;}
\NormalTok{    tCarta cartaDeMajorValor;}
\NormalTok{    tCarta vCartes[MAX\_NUM\_CARTES];}
    \DataTypeTok{bool}\NormalTok{ isFinalitzat;}
    \DataTypeTok{int}\NormalTok{ puntuacio;}
    \DataTypeTok{int}\NormalTok{ i, j;}
    \DataTypeTok{bool}\NormalTok{ isMateixColl;}
    
    \CommentTok{/* S\textquotesingle{}inicialitza el vector vValors amb les}
\CommentTok{     * puntuacions de totes les cartes. El nom}
\CommentTok{     * de la carta fa d\textquotesingle{}índex del vector, i el}
\CommentTok{     * valor desat en aquella posició és la seva}
\CommentTok{     * puntuació. Exemple: }
\CommentTok{     * {-} una carta amb un 1 retornarà 11 punts,}
\CommentTok{     *   corresponents al valor de la posició 1.}
\CommentTok{     * {-} una carta amb un 5 retornarà 0 punts,}
\CommentTok{     *   corresponents al valor de la posició 5.}
\CommentTok{     */}
    \DataTypeTok{int}\NormalTok{ vValors[NUM\_VALORS] = \{}\DecValTok{0}\NormalTok{, }\DecValTok{11}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{0}\NormalTok{, }\DecValTok{2}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{\};}

    \CommentTok{/* El següent vector ens ajudarà a mostrar}
\CommentTok{     * per pantalla de forma automàtica la descripció }
\CommentTok{     * associada a cadascun dels valors definits a }
\CommentTok{     * l\textquotesingle{}enumeratiu tColl}
\CommentTok{     */}
    \DataTypeTok{char}\NormalTok{* vNoms[MAX\_NUM\_COLLS] = \{}\StringTok{"Monedes"}\NormalTok{, }\StringTok{"Copes"}\NormalTok{, }\StringTok{"Bastos"}\NormalTok{, }\StringTok{"Espases"}\NormalTok{\};}

    \CommentTok{/* La variable booleana s\textquotesingle{}utilitzarà per}
\CommentTok{     * finalitzar el primer bucle d\textquotesingle{}introducció}
\CommentTok{     * de cartes des de teclat}
\CommentTok{     */}
\NormalTok{    isFinalitzat = false;}
    
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}
\NormalTok{    j = }\DecValTok{0}\NormalTok{;}
\NormalTok{    puntuacio = }\DecValTok{0}\NormalTok{;}
    
\NormalTok{    printf(}\StringTok{"Tipus carta: 0=MONEDES, 1=COPES, 2=BASTOS, 3=ESPASES.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}

    \ControlFlowTok{while}\NormalTok{ (!isFinalitzat) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Introdueix tipus carta: "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%u"}\NormalTok{, \&cartaAux.coll);}
        
        \CommentTok{/* Si el coll introduit no correspon a cap dels}
\CommentTok{         * quatre definits, significa que no es vol }
\CommentTok{         * entrar cap més carta des de teclat}
\CommentTok{         */}
        \ControlFlowTok{if}\NormalTok{ (cartaAux.coll != MONEDES \&\& cartaAux.coll != COPES}
\NormalTok{            \&\& cartaAux.coll != BASTOS \&\& cartaAux.coll != ESPASES) \{}
\NormalTok{            isFinalitzat = true;}

\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            printf(}\StringTok{"Introdueix número carta: "}\NormalTok{);}
\NormalTok{            scanf(}\StringTok{"\%d"}\NormalTok{, \&cartaAux.numero);}
            
            \CommentTok{/* Es valida que el número de la carta}
\CommentTok{             * introduïda sigui vàlid: valor comprès}
\CommentTok{             * entre 1 i 12}
\CommentTok{             */}
            \ControlFlowTok{if}\NormalTok{ (cartaAux.numero \textless{} }\DecValTok{1}\NormalTok{ || cartaAux.numero \textgreater{} }\DecValTok{12}\NormalTok{) \{}
\NormalTok{                printf(}\StringTok{"Error: número de la carta incorrecte!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
                
\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \CommentTok{/* Es calcula el valor de la carta i }
\CommentTok{                 * s\textquotesingle{}assigna al camp valor de la tupla}
\CommentTok{                 * cartaAux (de tipus tCarta)}
\CommentTok{                 */}
\NormalTok{                cartaAux.valor = vValors[cartaAux.numero];}
\NormalTok{                vCartes[i] = cartaAux;}
                
                \CommentTok{/* La variable \textquotesingle{}i\textquotesingle{} contindrà el número}
\CommentTok{                 * de cartes vàlides introduïdes per}
\CommentTok{                 * teclat.}
\CommentTok{                 */}
\NormalTok{                i = i + }\DecValTok{1}\NormalTok{;}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
    
    \CommentTok{/* Sortida 1:}
\CommentTok{     * Recorrem el vector de cartes per mostrar}
\CommentTok{     * per pantalla tots els elements (cartes)}
\CommentTok{     * que conté.}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Relació de cartes introduïdes: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{ (j = }\DecValTok{0}\NormalTok{; j \textless{} i; j++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\%d de \%s (\%d punts) }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vCartes[j].numero, vNoms[vCartes[j].coll], vCartes[j].valor);}
\NormalTok{    \}}
    
    \CommentTok{/* Sortida 2:}
\CommentTok{     * Recorrem el vector de cartes i busquem}
\CommentTok{     * la que té una major puntuació. En cas }
\CommentTok{     * d\textquotesingle{}empat, mostrem l\textquotesingle{}última introduïda.}
\CommentTok{     */}

    \CommentTok{/* Inicialitzem el valor de cartaDeMajorValor}
\CommentTok{     * a valor = 0}
\CommentTok{     */}
\NormalTok{    cartaDeMajorValor.valor = }\DecValTok{0}\NormalTok{;}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Carta de major puntuació: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{ (j = }\DecValTok{0}\NormalTok{; j \textless{} i; j++) \{}
        \CommentTok{/* En cada iteració del bucle ens assegurem}
\CommentTok{         * que cartaDeMajorValor sigui la carta}
\CommentTok{         * amb un valor més gran. Comparem la carta}
\CommentTok{         * que estem tractant actualment amb la carta}
\CommentTok{         * que fins ara hem trobat de major valor.}
\CommentTok{         */}
        \ControlFlowTok{if}\NormalTok{ (vCartes[j].valor \textgreater{}= cartaDeMajorValor.valor) \{}
\NormalTok{            cartaDeMajorValor.coll = vCartes[j].coll;}
\NormalTok{            cartaDeMajorValor.numero = vCartes[j].numero;}
\NormalTok{            cartaDeMajorValor.valor = vCartes[j].valor;}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\%d de \%s (\%d punts) }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaDeMajorValor.numero, vNoms[cartaDeMajorValor.coll], cartaDeMajorValor.valor);}

    \CommentTok{/* Sortida 3:}
\CommentTok{     * Recorrem el vector de cartes i anem sumant}
\CommentTok{     * tots els valors, per tal d\textquotesingle{}obtenir la }
\CommentTok{     * puntuació total.}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Puntuació total: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{for}\NormalTok{ (j = }\DecValTok{0}\NormalTok{; j \textless{} i; j++) \{}
\NormalTok{        puntuacio = puntuacio + vCartes[j].valor;}
\NormalTok{    \}}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\%d punts }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, puntuacio);}
    
    \CommentTok{/* Sortida 4:}
\CommentTok{     * Recorrem el vector de cartes i anem comparant}
\CommentTok{     * parelles de carta: la que estem tractant amb}
\CommentTok{     * la que ve a continuació. Mostrem per pantalla}
\CommentTok{     * si són del mateix coll o no.}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Comparació de cartes: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    
    \CommentTok{/* Important: en aquest recorregut del vector}
\CommentTok{     * de cartes anem comparant la carta de la }
\CommentTok{     * posició actual j amb la carta que està}
\CommentTok{     * a la següent posició j+1. Això significa}
\CommentTok{     * que el límit de les iteracions del }
\CommentTok{     * bucle passa a ser i{-}1 (un element abans}
\CommentTok{     * del final), ja que quan tractem aquest}
\CommentTok{     * element el compararem amb el següent,}
\CommentTok{     * que és l\textquotesingle{}últim del vector. Si en comptes}
\CommentTok{     * de tenir i{-}1 tinguéssim només i, en }
\CommentTok{     * la darrera iteració donaria error, ja }
\CommentTok{     * que s\textquotesingle{}estaria accedint a una posició}
\CommentTok{     * incorrecta del vector de cartes (i+1).}
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (j = }\DecValTok{0}\NormalTok{; j \textless{} i{-}}\DecValTok{1}\NormalTok{; j++) \{}
        
        \CommentTok{/* Per comparar la carta de la posició actual}
\CommentTok{         * amb la que hi ha a la següent posició,}
\CommentTok{         * utilitzem els índex j i j+1 respectivament.}
\CommentTok{         */}
\NormalTok{        isMateixColl = (vCartes[j].coll == vCartes[j+}\DecValTok{1}\NormalTok{].coll);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\%d de \%s vs \%d de \%s: "}\NormalTok{, vCartes[j].numero, vNoms[vCartes[j].coll], vCartes[j+}\DecValTok{1}\NormalTok{].numero, vNoms[vCartes[j+}\DecValTok{1}\NormalTok{].coll]);}
        \ControlFlowTok{if}\NormalTok{ (isMateixColl) \{}
\NormalTok{            printf(}\StringTok{"són del mateix coll!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            printf(}\StringTok{"són de colls diferents!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Un exemple d'execució pot ser el següent:

\includegraphics{./img/play.png}

\begin{verbatim}
Tipus carta: 0=MONEDES, 1=COPES, 2=BASTOS, 3=ESPASES.

Introdueix tipus carta: 0
Introdueix número carta: 1

Introdueix tipus carta: 0
Introdueix número carta: 10

Introdueix tipus carta: 0
Introdueix número carta: 5

Introdueix tipus carta: 2
Introdueix número carta: 10

Introdueix tipus carta: 2
Introdueix número carta: 1

Introdueix tipus carta: 3
Introdueix número carta: 4

Introdueix tipus carta: 9

Relació de cartes introduïdes: 
    1 de Monedes (11 punts) 
    10 de Monedes (2 punts) 
    5 de Monedes (0 punts) 
    10 de Bastos (2 punts) 
    1 de Bastos (11 punts) 
    4 de Espases (0 punts) 

Carta de major puntuació: 
    1 de Bastos (11 punts) 

Puntuació total: 
    26 punts 

Comparació de cartes: 
    1 de Monedes vs 10 de Monedes: són del mateix coll!
    10 de Monedes vs 5 de Monedes: són del mateix coll!
    5 de Monedes vs 10 de Bastos: són de colls diferents!
    10 de Bastos vs 1 de Bastos: són del mateix coll!
    1 de Bastos vs 4 de Espases: són de colls diferents!
\end{verbatim}

\hypertarget{frequently-made-mistakes-4}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes-4}}

\hypertarget{definiciuxf3-de-tipus-definiciuxf3-de-tuples-mal-ubicada}{%
\subsection{Definició de tipus: definició de tuples mal ubicada}\label{definiciuxf3-de-tipus-definiciuxf3-de-tuples-mal-ubicada}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \KeywordTok{typedef} \KeywordTok{struct}\NormalTok{\{}
        \DataTypeTok{int}\NormalTok{ id;}
        \DataTypeTok{char}\NormalTok{ brand[MAX\_LEN];}
        \DataTypeTok{float}\NormalTok{ price;}
\NormalTok{    \} tHotel;}

\NormalTok{    tHotel myHotel;}
    \CommentTok{/* ... */}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Els tipus de dades s'han de declarar \textbf{al principi del bloc de codi}, i fora de qualsevol funció (sigui el \texttt{main} o una altra), ja que els tipus són globals a tot el programa, i les variables associades als tipus es declaren posteriorment en cada una de les funcions on es necessiten.

Les tuples (\texttt{structs}) no en són una excepció, i per tant no és correcte obrir un bloc de definició de tuples dins un bloc central de codi (i encara menys obrir diversos blocs de definició de tuples a mesura que els necessitem).

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{\{}
    \DataTypeTok{int}\NormalTok{ id;}
    \DataTypeTok{char}\NormalTok{ brand[MAX\_LEN];}
    \DataTypeTok{float}\NormalTok{ price;}
\NormalTok{\} tHotel;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tHotel myHotel;}
    \CommentTok{/* ... */}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{definiciuxf3-de-tipus-definiciuxf3-mal-ubicada}{%
\subsection{Definició de tipus: definició mal ubicada}\label{definiciuxf3-de-tipus-definiciuxf3-mal-ubicada}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{BUDGET, INN, RESORT\} tTypeHotel;}
    \KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{STANDARD, SUITE\} tTypeRoom;}

\NormalTok{    tTypeHotel myHotelType = BUDGET;}
\NormalTok{    tTypeRoom myRoomType = STANDARD;}
    \CommentTok{/* ... */}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Els tipus de dades s'han de declarar \textbf{al principi del bloc de codi}, i fora de qualsevol funció (sigui el \texttt{main} o una altra), ja que els tipus són globals a tot el programa, i les variables associades als tipus es declaren posteriorment en cada una de les funcions on es necessiten. No és correcte obrir un bloc de definició de tipus dins un bloc central de codi (i encara menys obrir diversos blocs de definició de tipus a mesura que els necessitem).

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{BUDGET, INN, RESORT\} tTypeHotel;}
\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{STANDARD, SUITE\} tTypeRoom;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
 
\NormalTok{    tTypeHotel myHotelType = BUDGET;}
\NormalTok{    tTypeRoom myRoomType = STANDARD;}
    \CommentTok{/* ... */}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac06}{%
\chapter{PAC06}\label{pac06}}

\hypertarget{diferuxe8ncies-entre-funcions-i-accions}{%
\section{Diferències entre funcions i accions}\label{diferuxe8ncies-entre-funcions-i-accions}}

A continuació s'expliquen les diferències entre una \textbf{funció} i una \textbf{acció}, quins tipus de paràmetres utilitzen, com s'implementen en llenguatge C, i finalment què passa quan un paràmetre és una tupla. És important que es vagin consolidant tots aquests conceptes.

Les principals diferències són:

\begin{longtable}[]{@{}lll@{}}
\toprule
\begin{minipage}[b]{0.50\columnwidth}\raggedright
\strut
\end{minipage} & \begin{minipage}[b]{0.22\columnwidth}\raggedright
Funcions\strut
\end{minipage} & \begin{minipage}[b]{0.19\columnwidth}\raggedright
Accions\strut
\end{minipage}\tabularnewline
\midrule
\endhead
\begin{minipage}[t]{0.50\columnwidth}\raggedright
Retornen un valor?\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
sí\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
no\strut
\end{minipage}\tabularnewline
\begin{minipage}[t]{0.50\columnwidth}\raggedright
Tipus de paràmetres\strut
\end{minipage} & \begin{minipage}[t]{0.22\columnwidth}\raggedright
entrada (in)\strut
\end{minipage} & \begin{minipage}[t]{0.19\columnwidth}\raggedright
entrada (in), sortida (out), entrada/sortida (inout)\strut
\end{minipage}\tabularnewline
\bottomrule
\end{longtable}

El retorn de valor de les funcions permet que aquest es pugui assignar a una variable, cosa que no es pot fer amb les accions.

Per exemple, imaginem que volem implementar en llenguatge C la funció \texttt{suma()}; una possible implementació podria ser:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de la funció */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1 = }\DecValTok{3}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ num2 = }\DecValTok{2}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ resultat = }\DecValTok{0}\NormalTok{;}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"Valor de num2 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num2);}
\NormalTok{    printf(}\StringTok{"Valor de resultat = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Inici execució funció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    resultat = suma(num1, num2);}
\NormalTok{    printf(}\StringTok{"Suma = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Fi execució funció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Valor de resultat = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de la funció */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2) \{}
    \ControlFlowTok{return}\NormalTok{ (n1+n2);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució generarà la següent sortida:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Valor de num1 = }\DecValTok{3}
\NormalTok{Valor de num2 = }\DecValTok{2}
\NormalTok{Valor de resultat = }\DecValTok{0}
\NormalTok{\textgreater{}\textgreater{} Inici execució funció}
\NormalTok{Suma = }\DecValTok{5}
\NormalTok{\textgreater{}\textgreater{} Fi execució funció}
\NormalTok{Valor de resultat = }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

Com es pot veure, el valor de retorn de la funció \texttt{suma()} l'assignem a la variable resultat.

En una funció, els paràmetres passats sempre seran \textbf{d'entrada} (in): això significa que dins de la funció únicament seran valors de consulta, no els modificarem per res.

Per entendre bé com s'implementa una acció, relacionarem exemples similars amb els diferents tipus de paràmetres que pot tenir una acció: \textbf{entrada} (in), \textbf{sortida} (out) i \textbf{entrada/sortida} (inout).

\hypertarget{paruxe0metres-dentrada-in}{%
\subsection{Paràmetres d'entrada (in)}\label{paruxe0metres-dentrada-in}}

Són aquells paràmetres que es passen a una \textbf{acció} i dels quals únicament utilitzarem el seu contingut. Això significa que treballarem amb ells en \emph{mode lectura}: obtindrem els seus valors per tal de realitzar càlculs, però mai modificarem el seu contingut. Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1 = }\DecValTok{3}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ num2 = }\DecValTok{2}\NormalTok{;}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"Valor de num2 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num2);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Inici execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    suma(num1, num2);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Fi execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"Valor de num2 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num2);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}   }

\CommentTok{/* Implementació de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2) \{}
    \DataTypeTok{int}\NormalTok{ resultat = n1 + n2;}
\NormalTok{    printf(}\StringTok{"Suma = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució generarà la següent sortida:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Valor de num1 = }\DecValTok{3}
\NormalTok{Valor de num2 = }\DecValTok{2}
\NormalTok{\textgreater{}\textgreater{} Inici execució acció}
\NormalTok{Suma = }\DecValTok{5}
\NormalTok{\textgreater{}\textgreater{} Fi execució acció}
\NormalTok{Valor de num1 = }\DecValTok{3}
\NormalTok{Valor de num2 = }\DecValTok{2}
\end{Highlighting}
\end{Shaded}

Com es pot observar, ni \texttt{num1} ni \texttt{num2} han modificat el seu valor després de l'execució de l'acció: son \textbf{paràmetres d'entrada}.

Aquest tipus de paràmetre també es referencia com a paràmetre per valor, o pas per valor, ja que el que estem passant és un valor (no pas un punter).

\hypertarget{paruxe0metres-de-sortida-out}{%
\subsection{Paràmetres de sortida (out)}\label{paruxe0metres-de-sortida-out}}

A diferencia dels paràmetres d'entrada, els de sortida s'utilitzen únicament per guardar valors. Poden contenir qualsevol valor inicial, que aquest no serà utilitzat dins de l'acció. Una vegada realitzats tots els càlculs de l'acció, el resultat final es guardarà en el paràmetre de sortida. Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2, }\DataTypeTok{int}\NormalTok{ *res);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1 = }\DecValTok{3}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ num2 = }\DecValTok{2}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ resultat = }\DecValTok{0}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ *pResultat = \&resultat;}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"Valor de num2 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num2);}
\NormalTok{    printf(}\StringTok{"Valor de resultat = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Inici execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{); }
\NormalTok{    suma(num1, num2, pResultat);}
\NormalTok{    printf(}\StringTok{"Suma = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Fi execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Valor de resultat = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, resultat);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2, }\DataTypeTok{int}\NormalTok{ *res) \{}
\NormalTok{    *res = n1 + n2;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució generarà la següent sortida:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Valor de num1 = }\DecValTok{3}
\NormalTok{Valor de num2 = }\DecValTok{2}
\NormalTok{Valor de resultat = }\DecValTok{0}
\NormalTok{\textgreater{}\textgreater{} Inici execució acció}
\NormalTok{Suma = }\DecValTok{5}
\NormalTok{\textgreater{}\textgreater{} Fi execució acció}
\NormalTok{Valor de resultat = }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

De moment ignorarem que es tracta d'un punter: independientement del valor que tingui res al pasar-se per paràmetre, quan finalitzi l'acció contindrà la suma dels altres dos paràmetres d'entrada \texttt{num1} i \texttt{num2}.

El valor resultat ha canviat, de \texttt{0} a \texttt{5}. Es considera un \textbf{paràmetre de sortida} perquè, independientement del valor inicial que tingui aquest, no s'utilitza per res i en finalitzar l'acció contindrà el resultat de l'operació \texttt{suma()}.

Ara sí comentem el fet d'utilitzar el punter: la manera que tenim a C per modificar una variable definida fora d'una acció des de dins de la mateixa és treballant precisament amb la seva direcció de memòria.

Aquest tipus de paràmetre també es referencia com a paràmetre per referència, o pas per referència, ja que passem un punter.

\hypertarget{paruxe0metres-dentradasortida-inout}{%
\subsection{Paràmetres d'entrada/sortida (inout)}\label{paruxe0metres-dentradasortida-inout}}

Aquest tipus de paràmetre és una suma dels dos comportaments anteriors: d'una banda el seu valor importa a l'hora de realitzar els càlculs de l'acció, i a la vegada en finalitzar l'execució de l'acció tindrà un valor diferent, també significatiu per tractar-se del resultat final del càlcul. Exemple:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ *pN1, }\DataTypeTok{int}\NormalTok{ n2);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1 = }\DecValTok{3}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ num2 = }\DecValTok{2}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ *pNum1 = \&num1;}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"Valor de num2 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num2);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Inici execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{); }
\NormalTok{    suma(pNum1, num2);}
\NormalTok{    printf(}\StringTok{"Suma = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Fi execució acció}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"Valor de num1 = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, num1);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ *pN1, }\DataTypeTok{int}\NormalTok{ n2) \{}
\NormalTok{    *pN1 = *pN1 + n2;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució generarà la següent sortida:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Valor de num1 = }\DecValTok{3}
\NormalTok{Valor de num2 = }\DecValTok{2}
\NormalTok{\textgreater{}\textgreater{} Inici execució acció}
\NormalTok{Suma = }\DecValTok{5}
\NormalTok{\textgreater{}\textgreater{} Fi execució acció}
\NormalTok{Valor de num1 = }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

En aquest cas s'ha realitzat la suma com a \texttt{num1\ =\ num1\ +\ num2} : el resultat de la suma de les dues variables es guarda a la primera d'elles. Així doncs el valor de la variable \texttt{num1} importa tant a l'entrada com a la sortida de l'acció, amb el que es tracta d'un \textbf{paràmetre d'entrada/sortida}.

Aquest tipus de paràmetre també es referencia com a paràmetre per referència, o pas per referència, ja que passem un punter.

\hypertarget{tuples-com-a-paruxe0metres}{%
\subsection{Tuples com a paràmetres}\label{tuples-com-a-paruxe0metres}}

Quan un paràmetre d'una acció/funció és una tupla , la forma com accedirem als seus atributs dins de l'acció/funció variarà en funció del tipus de paràmetre:

\begin{itemize}
\tightlist
\item
  Paràmetres d'\textbf{entrada}: l'accessor als atributs és el \texttt{.} (un punt). Per tant dins de la funció/acció, accedirem als atributs de la tupla passada per paràmetre de la següent forma: \texttt{nomTupla.nomAtribut}.
\item
  Paràmetres de \textbf{sortida} i d'\textbf{entrada/sortida}: en aquest cas l'accessor als atributs de la tupla és \texttt{-\textgreater{}}. Així, dins de l'acció podrem fer referència als atributs de la tupla passada per paràmetre de la forma: \texttt{nomTupla-\textgreater{}nomAtribut}.
\end{itemize}

\hypertarget{exemple-uxfas-daccions}{%
\section{Exemple: ús d'accions}\label{exemple-uxfas-daccions}}

A continuació s'adjunta un exemple inventat de com es poden definir accions que permetin modificar els atributs d'una tupla passada com a punter. Dins del codi hi ha comentaris addicionals per tal que quedi el més clar possible:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\PreprocessorTok{\#define MAX\_CHAR 10+1}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_CHAR];}
    \DataTypeTok{float}\NormalTok{ nomina;}
\NormalTok{\} tEmpleat;}

\CommentTok{/* Predeclaració de les accions */}

\DataTypeTok{void}\NormalTok{ printEmpleat(tEmpleat empleat);}
\DataTypeTok{void}\NormalTok{ setNominaEmpleat(tEmpleat *empleat, }\DataTypeTok{float}\NormalTok{ nomina);}
\DataTypeTok{void}\NormalTok{ setNomEmpleat(tEmpleat *empleat, }\DataTypeTok{char}\NormalTok{ nom[MAX\_CHAR]);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* Declarem nouEmpleat de tipus tEmpleat,}
\CommentTok{     * però no li donarem cap valor directament}
\CommentTok{     * als seus dos atributs (nom i nomina): ho }
\CommentTok{     * farem mitjançant dues accions }
\CommentTok{     */}
\NormalTok{    tEmpleat nouEmpleat;}
   
    \CommentTok{/* Els valors dels atributs nom i nomina els}
\CommentTok{     * llegirem des de teclat i els desarem inicialment}
\CommentTok{     * en les següents dues variables }
\CommentTok{     */}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_CHAR];}
    \DataTypeTok{float}\NormalTok{ nomina;}
   
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nom empleat : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, nom);}
      
\NormalTok{    printf(}\StringTok{"Nòmina empleat : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&nomina);}
   
    \CommentTok{/* Assignem el nom i la nòmina al tEmpleat nouEmpleat}
\CommentTok{     * utilitzant les accions definides. Fixeu{-}vos}
\CommentTok{     * que el paràmetre nouEmpleat el passem com a punter}
\CommentTok{     * (passem la seva adreça en memòria, ja que va }
\CommentTok{     * precedit per \&) }
\CommentTok{     */}
\NormalTok{    setNomEmpleat(\&nouEmpleat, nom);}
\NormalTok{    setNominaEmpleat(\&nouEmpleat, nomina);}
   
    \CommentTok{/* Mostrem les dades de la tupla tEmpleat nouEmpleat}
\CommentTok{     * per pantalla }
\CommentTok{     */}
\NormalTok{    printEmpleat(nouEmpleat);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les accions */}

\DataTypeTok{void}\NormalTok{ printEmpleat(tEmpleat empleat) \{}
    \CommentTok{/* El paràmetre empleat és d\textquotesingle{}entrada, amb el}
\CommentTok{     * que l\textquotesingle{}accés als seus atributs ho farem}
\CommentTok{     * amb un punt : empleat.nom, empleat.nomina }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Dades de l\textquotesingle{}empleat: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nom: \%s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, empleat.nom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nòmina: \%.2f €}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, empleat.nomina);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ setNominaEmpleat(tEmpleat *empleat, }\DataTypeTok{float}\NormalTok{ nomina) \{}
    \CommentTok{/* El paràmetre empleat (de tipus inout) és un punter,}
\CommentTok{     * per tal que des de dins de l\textquotesingle{}acció sigui possible}
\CommentTok{     * modificar el valor (d\textquotesingle{}un atribut) de l\textquotesingle{}empleat}
\CommentTok{     * definit al main del nostre programa, fora de l\textquotesingle{}àmbit}
\CommentTok{     * de l\textquotesingle{}acció.}
\CommentTok{     * L\textquotesingle{}accés a un atribut d\textquotesingle{}un element referenciat amb}
\CommentTok{     * un punter es fa amb \textquotesingle{}{-}\textgreater{}\textquotesingle{} : empleat{-}\textgreater{}nomina. }
\CommentTok{     */}
\NormalTok{    empleat{-}\textgreater{}nomina = nomina;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ setNomEmpleat(tEmpleat *empleat, }\DataTypeTok{char}\NormalTok{ nom[MAX\_CHAR]) \{}
    \CommentTok{/* Idem que en l\textquotesingle{}acció setNominaEmpleat. En aquest cas}
\CommentTok{     * a més a més cal recordar que l\textquotesingle{}assignació d\textquotesingle{}strings}
\CommentTok{     * la fem amb la funció strcpy de C, en comptes }
\CommentTok{     * d\textquotesingle{}utilitzar l\textquotesingle{}assignació habitual \textquotesingle{}=\textquotesingle{} dels tipus }
\CommentTok{     * primitius (char, int, float, ...) }
\CommentTok{     */}
\NormalTok{    strcpy(empleat{-}\textgreater{}nom, nom);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Un exemple d'execució seria:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Nom empleat : Laura}
\NormalTok{Nòmina empleat : }\FloatTok{1850.32}

\NormalTok{Dades de l\textquotesingle{}empleat: }
\NormalTok{    Nom: Laura}
\NormalTok{    Nòmina: }\FloatTok{1850.32}\NormalTok{ €}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-uxfas-de-funcions}{%
\section{Exemple: ús de funcions}\label{exemple-uxfas-de-funcions}}

Si necessitem un mètode que com a resultat retorni un string, en comptes d'utilitzar una funció farem servir una acció amb un paràmetre de sortida o d'entrada/sortida. Les funcions les farem servir per retornar valors de \textbf{tipus primitiu} (enter, decimal, caràcter), i deixarem els \textbf{tipus compostos} (vectors, tuples, etc.) per les accions.

A continuació s'exposa un exemple perquè quedi més clar:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Programa que, donada una hora, indica}
\CommentTok{ * a quina part del dia correspon.}
\CommentTok{ * Per "part del dia" s\textquotesingle{}entèn: matinada,}
\CommentTok{ * matí, migdia, tarda, vespre i nit.}
\CommentTok{ * L\textquotesingle{}hora s\textquotesingle{}aconsegueix mitjançant una}
\CommentTok{ * funció, la qual retorna un valor}
\CommentTok{ * enter en format HHMM (on HH=hora i}
\CommentTok{ * MM=minut).}
\CommentTok{ * D\textquotesingle{}altra banda, el càlcul de la part}
\CommentTok{ * del dia es realitza amb una acció,}
\CommentTok{ * la qual rep dos paràmetres: un d\textquotesingle{}entrada}
\CommentTok{ * corresponent a l\textquotesingle{}hora en format HHMM, }
\CommentTok{ * i un altre de sortida que contindrà}
\CommentTok{ * la part del dia (string) que correspon}
\CommentTok{ * a l\textquotesingle{}hora.}
\CommentTok{ */}

\PreprocessorTok{\#define MAX\_CHARS 8+1}

\CommentTok{/* Predeclaració de funcions i accions */}
\DataTypeTok{void}\NormalTok{ calcularPartDelDia(}\DataTypeTok{int}\NormalTok{ hora, }\DataTypeTok{char}\NormalTok{ *part);}
\DataTypeTok{int}\NormalTok{ demanarHora();}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ hora;}
    \DataTypeTok{char}\NormalTok{ partDelDia[MAX\_CHARS];}
\NormalTok{    hora = demanarHora();}
\NormalTok{    calcularPartDelDia(hora, partDelDia);}
\NormalTok{    printf(}\StringTok{"L\textquotesingle{}hora \%d correspon a: \%s }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, hora, partDelDia);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions i accions */}

\CommentTok{/* Funció que retorna un enter, corresponent}
\CommentTok{ * a l\textquotesingle{}hora introduïda per teclat, en format}
\CommentTok{ * HHMM}
\CommentTok{ */}
\DataTypeTok{int}\NormalTok{ demanarHora() \{}
    \DataTypeTok{int}\NormalTok{ hora;}
\NormalTok{    printf(}\StringTok{"Tecleja hora (format HHMM) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&hora);}
    \ControlFlowTok{return}\NormalTok{ hora;}
\NormalTok{\}}

\CommentTok{/* Acció que, donada una hora (paràmetre}
\CommentTok{ * d\textquotesingle{}entrada), calcula quina part del dia}
\CommentTok{ * correspon (paràmetre de sortida). La}
\CommentTok{ * part del dia és de tipus string. El}
\CommentTok{ * paràmetre de sortida ha de ser un }
\CommentTok{ * punter, per tal que des de dins de}
\CommentTok{ * l\textquotesingle{}acció es pugui modificar el valor}
\CommentTok{ * de la variable definida fora de }
\CommentTok{ * l\textquotesingle{}acció, dins del main.}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ calcularPartDelDia(}\DataTypeTok{int}\NormalTok{ hora, }\DataTypeTok{char}\NormalTok{ *part) \{}

    \CommentTok{/* Particionat horari extret de}
\CommentTok{     * https://www.parlament.cat/document/intrade/6698}
\CommentTok{     */}

    \CommentTok{/* 0 correspon a 0000 */}
    \CommentTok{/* 14 correspon a 0014 */}
    \ControlFlowTok{if}\NormalTok{ (hora \textgreater{}= }\DecValTok{0}\NormalTok{ \&\& hora \textless{}= }\DecValTok{14}\NormalTok{) \{}
\NormalTok{        strcpy(part, }\StringTok{"nit"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \CommentTok{/* 414 correspon a 0414 */}
        \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{14}\NormalTok{ \&\& hora \textless{}= }\DecValTok{414}\NormalTok{) \{}
\NormalTok{            strcpy(part, }\StringTok{"matinada"}\NormalTok{);}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
            \CommentTok{/* 0500 correspon a 500 */}
            \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{414}\NormalTok{ \&\& hora \textless{}= }\DecValTok{1114}\NormalTok{) \{}
\NormalTok{                strcpy(part, }\StringTok{"matí"}\NormalTok{);}
\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{1114}\NormalTok{ \&\& hora \textless{}= }\DecValTok{1414}\NormalTok{) \{}
\NormalTok{                    strcpy(part, }\StringTok{"migdia"}\NormalTok{);}
\NormalTok{                \} }\ControlFlowTok{else}\NormalTok{ \{}
                    \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{1414}\NormalTok{ \&\& hora \textless{}= }\DecValTok{1814}\NormalTok{) \{}
\NormalTok{                        strcpy(part, }\StringTok{"tarda"}\NormalTok{);}
\NormalTok{                    \} }\ControlFlowTok{else}\NormalTok{ \{}
                        \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{1814}\NormalTok{ \&\& hora \textless{}= }\DecValTok{2214}\NormalTok{) \{}
\NormalTok{                            strcpy(part, }\StringTok{"vespre"}\NormalTok{);}
\NormalTok{                        \} }\ControlFlowTok{else}\NormalTok{ \{}
                            \ControlFlowTok{if}\NormalTok{ (hora \textgreater{} }\DecValTok{2214}\NormalTok{ \&\& hora \textless{}= }\DecValTok{2359}\NormalTok{) \{}
\NormalTok{                                strcpy(part, }\StringTok{"vespre"}\NormalTok{);}
\NormalTok{                            \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{                                strcpy(part, }\StringTok{"unknown!"}\NormalTok{);}
\NormalTok{                            \}}
\NormalTok{                        \}}
\NormalTok{                    \}}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Un exemple d'execució:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Tecleja hora (format HHMM) : }\DecValTok{1906}
\NormalTok{L\textquotesingle{}hora }\DecValTok{1906}\NormalTok{ correspon a: vespre}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-nuxf2mines-1}{%
\section{Exemple: nòmines}\label{exemple-nuxf2mines-1}}

Imaginem que treballem amb els empleats d'una empresa. Posem per cas que després d'introduir n-empleats al nostre sistema, volem una funció que ens retorni l'empleat que té la nòmina més petita.
Com que esperem un valor de retorn, estem davant d'una funció. A la funció li passarem un vector d'empleats amb tots els empleats que prèviament hem introduit a la nostra empresa.

Sense entrar en la codificació de la funció, el main del nostre programa pot ser similar al següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_EMPLEATS 2}
\PreprocessorTok{\#define MAX\_CARACTERS 20+1}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_CARACTERS];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS];}
    \DataTypeTok{float}\NormalTok{ nomina;}
\NormalTok{\} tEmpleat;}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tEmpleat vEmpleats[MAX\_EMPLEATS];}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].nom);}
\NormalTok{        printf(}\StringTok{"Cognom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].cognom);}
\NormalTok{        printf(}\StringTok{"Nòmina empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&vEmpleats[i].nomina);}
\NormalTok{    \}}
\NormalTok{    tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{L\textquotesingle{}empleat amb la nòmina més baixa és \%s, \%s (\%.2f €)"}\NormalTok{, empleat.cognom, empleat.nom, empleat.nomina);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Fins aquest punt no hi ha res nou: utilitzem un vector de \texttt{tEmpleat} per tal d'anar introduint els empleats per teclat, i per cada empleat demanem el nom, el cognom i la seva nòmina.

El que cal fer ara és implementar la funció \texttt{cercaEmpleatNominaMinima}, que rep com a paràmetre el vector d'empleats de l'empresa.

De moment oblidem-nos que estem davant d'una funció, simplement centrem-nos en quina és l'acció que volem fer. En aquest cas, volem fer un programa que recorri un a un tots els elements d'un vector, i trobi l'empleat que cobra menys.

Una possible codificació seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; }
\DataTypeTok{int}\NormalTok{ minNomina = }\DecValTok{0}\NormalTok{;}
\ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
    \ControlFlowTok{if}\NormalTok{ (vector[i].nomina \textless{} vector[minNomina].nomina) \{}
\NormalTok{        minNomina = i;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aquest fragment de codi simplement recorre un a un tots els \texttt{tEmpleat} d'un vector, comparant la nòmina més baixa trobada fins el moment amb la de l'empleat que està tractant en qüestió, i si aquesta segona és més baixa, ens quedem amb la seva posició dins del vector com a empleat amb la nòmina més baixa.

Ara convertim aquest fragment de codi en una funció:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX\_EMPLEATS]) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; }
    \DataTypeTok{int}\NormalTok{ minNomina = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
        \ControlFlowTok{if}\NormalTok{ (vector[i].nomina \textless{} vector[minNomina].nomina) \{}
\NormalTok{            minNomina = i;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ vector[minNomina];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Com es pot veure, l'única diferència és que ara el codi té la capçalera de la funció, la qual ens diu que rep com a paràmetre un element de tipus vector de \texttt{tEmpleat}, i que retornarà un element de tipus \texttt{tEmpleat}.

D'aquesta forma el programa complet queda de la següent manera:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_EMPLEATS 2}
\PreprocessorTok{\#define MAX\_CARACTERS 20+1}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_CARACTERS];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS];}
    \DataTypeTok{float}\NormalTok{ nomina;}
\NormalTok{\} tEmpleat;}

\CommentTok{/* Predeclaració de funcions/accions */}
\NormalTok{tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX\_EMPLEATS]);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tEmpleat vEmpleats[MAX\_EMPLEATS];}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].nom);}
\NormalTok{        printf(}\StringTok{"Cognom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].cognom);}
\NormalTok{        printf(}\StringTok{"Nòmina empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&vEmpleats[i].nomina);}
\NormalTok{    \}}
\NormalTok{    tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{L\textquotesingle{}empleat amb la nòmina més baixa és \%s, \%s (\%.2f €)"}\NormalTok{, empleat.cognom, empleat.nom, empleat.nomina);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions/accions */}
\NormalTok{tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX\_EMPLEATS]) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; }
    \DataTypeTok{int}\NormalTok{ minNomina = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
        \ControlFlowTok{if}\NormalTok{ (vector[i].nomina \textless{} vector[minNomina].nomina) \{}
\NormalTok{            minNomina = i;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ vector[minNomina];}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Aquest exemple pot semblar senzill perquè el tipus de comparació que estem fent és numèrica: comparem dos camps de tipus \texttt{float} (les nòmines de dos empleats).

Ampliem ara la funcionalitat del nostre programa: volem que pugui fer una cerca per cognom entre els nostres empleats. Per fer aquesta cerca, caldrà comparar una cadena de caràcters amb el cognom de cada empleat.

Per no fer la funció més complexa del necessari, imaginarem que cap cognom es pot repetir i que sempre trobarem un cognom com el que busquem (l'objectiu és veure com funciona \texttt{strcmp()}). Així doncs la nostra funció rebrà un vector d'empleats i un cognom a cercar, i retornarà l'empleat amb aquell cognom.

Poso tot el codi complet, comentant la part de l'\texttt{strcmp()} detalladament:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\PreprocessorTok{\#define MAX\_EMPLEATS 2}
\PreprocessorTok{\#define MAX\_CARACTERS 20+1}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_CARACTERS];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS];}
    \DataTypeTok{float}\NormalTok{ nomina;}
\NormalTok{\} tEmpleat;}

\CommentTok{/* Predeclaració de funcions/accions */}
\NormalTok{tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX\_EMPLEATS]);}
\NormalTok{tEmpleat cercaEmpleatPerCognom(tEmpleat vector[MAX\_EMPLEATS], }\DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS]);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tEmpleat vEmpleats[MAX\_EMPLEATS];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS];}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Nom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].nom);}
\NormalTok{        printf(}\StringTok{"Cognom empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, vEmpleats[i].cognom);}
\NormalTok{        printf(}\StringTok{"Nòmina empleat \%d : "}\NormalTok{, i);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&vEmpleats[i].nomina);}
\NormalTok{    \}}
\NormalTok{    tEmpleat empleat = cercaEmpleatNominaMinima(vEmpleats);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{L\textquotesingle{}empleat amb la nòmina més baixa és \%s, \%s (\%.2f €)"}\NormalTok{, empleat.cognom, empleat.nom, empleat.nomina);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Cognom de l\textquotesingle{}empleat a cercar : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, cognom);}

\NormalTok{    tEmpleat empleatCognom = cercaEmpleatPerCognom(vEmpleats, cognom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Dades de l\textquotesingle{}empleat: \%s, \%s {-}\textgreater{} \%f"}\NormalTok{, empleatCognom.cognom, empleatCognom.nom, empleatCognom.nomina);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions/accions */}
\NormalTok{tEmpleat cercaEmpleatNominaMinima(tEmpleat vector[MAX\_EMPLEATS]) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; }
    \DataTypeTok{int}\NormalTok{ minNomina = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
        \ControlFlowTok{if}\NormalTok{ (vector[i].nomina \textless{} vector[minNomina].nomina) \{}
\NormalTok{            minNomina = i;}
\NormalTok{        \}}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ vector[minNomina];}
\NormalTok{\}}

\NormalTok{tEmpleat cercaEmpleatPerCognom(tEmpleat vector[MAX\_EMPLEATS], }\DataTypeTok{char}\NormalTok{ cognom[MAX\_CARACTERS]) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; }
\NormalTok{    tEmpleat empleat;}

    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_EMPLEATS; i++) \{}
        \CommentTok{/* Per comparar strings utilitzarem la funció}
\CommentTok{         *  strcmp() de C. Aquesta funció compara dues}
\CommentTok{         *  cadenes de caràcters, i retorna un valor}
\CommentTok{         *  com a resultat de la comparació:}
\CommentTok{         *  {-} si el valor és 0: les dues cadenes són iguals}
\CommentTok{         *  {-} si el valor és {-}1: la primera cadena \textless{} segona cadena}
\CommentTok{         *  {-} si el valor és 1: la primera cadena \textgreater{} segona cadena}
\CommentTok{         *  En el nostre cas ens interessa detectar que}
\CommentTok{         *  els cognoms siguin iguals, amb el que }
\CommentTok{         *  volem controlar que el valor que retorna}
\CommentTok{         *  la funció strcmp() sigui 0. }
\CommentTok{         */}
        \ControlFlowTok{if}\NormalTok{ (strcmp(vector[i].cognom, cognom) == }\DecValTok{0}\NormalTok{) \{}
            \ControlFlowTok{return}\NormalTok{ vector[i];}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-pivotdefensiu}{%
\section{Exemple: pivotDefensiu}\label{exemple-pivotdefensiu}}

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Rebem una petició d\textquotesingle{}un equip femení de bàsquet,}
\CommentTok{ * en el qual ens demanen un programa que els permeti}
\CommentTok{ * seleccionar la millor pivot defensiu d\textquotesingle{}entre una }
\CommentTok{ * sèrie de candidates.}
\CommentTok{ * La millor pivot defensiu és aquella que captura}
\CommentTok{ * més rebots; en cas d\textquotesingle{}empat, s\textquotesingle{}escollirà la que}
\CommentTok{ * faci més taps.}
\CommentTok{ * Caldrà implementar 3 accions i 1 funció:}
\CommentTok{ * {-} acció llegirJugadora(j): llegeix de teclat i}
\CommentTok{ *   guarda tots els atributs de la jugadora a la}
\CommentTok{ *   tupla j.}
\CommentTok{ * {-} acció mostrarJugadora(j): mostra per pantalla}
\CommentTok{ *   el valor dels atributs de la tupla j.}
\CommentTok{ * {-} acció copiarJugadores(j1, j2): copia el valor}
\CommentTok{ *   de tots els atributs de j2 cap a j1.}
\CommentTok{ * {-} funció compararJugadores(j1, j2): retorna {-}1 en }
\CommentTok{ *   cas que la millor pivot sigui j1, i 1 en cas }
\CommentTok{ *   que la millor sigui j2.}
\CommentTok{ */}
\PreprocessorTok{\#define MAX\_NOM 20+1}
\PreprocessorTok{\#define MAX\_COGNOM 20+1}
\PreprocessorTok{\#define MAX\_JUGADORES 3}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_COGNOM];}
    \DataTypeTok{float}\NormalTok{ rebots;}
    \DataTypeTok{float}\NormalTok{ taps;}
\NormalTok{\} tJugadora;}

\CommentTok{/* Predeclaracions de funcions/accions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j);}
\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j);}
\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen);}
\DataTypeTok{int}\NormalTok{ compararJugadores(tJugadora j1, tJugadora j2);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tJugadora vJugadores[MAX\_JUGADORES];}
    \DataTypeTok{int}\NormalTok{ i, resultat;}

    \CommentTok{/* Es crea la tJugadora fictícia }
\CommentTok{     * millorPivot que ens ajudarà a trobar }
\CommentTok{     * la millor opció d\textquotesingle{}entre totes les }
\CommentTok{     * candidates}
\CommentTok{     */}
\NormalTok{    tJugadora millorPivot; }
\NormalTok{    millorPivot.rebots = }\DecValTok{0}\NormalTok{;}
\NormalTok{    millorPivot.taps = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Llegim totes les jugadores amb }
\CommentTok{     * l\textquotesingle{}acció llegirJugadora(). Aquesta}
\CommentTok{     * acció rep un paràmetre de sortida}
\CommentTok{     * (out), el qual contindrà la }
\CommentTok{     * jugadora llegit per teclat. Com que}
\CommentTok{     * es tracta d\textquotesingle{}un paràmetre de tipus }
\CommentTok{     * out, es realitzarà un pas per }
\CommentTok{     * referència (= passarem un punter)}
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_JUGADORES; i++) \{}
\NormalTok{        tJugadora jugadora;}
\NormalTok{        llegirJugadora(\&jugadora);}
\NormalTok{        vJugadores[i] = jugadora;}
\NormalTok{    \}}

    \CommentTok{/* Mostrem per pantalla quina}
\CommentTok{     * és la millor jugadora amb perfil}
\CommentTok{     * pivot defensiu. La idea és anar}
\CommentTok{     * recorrent una a una les jugadores}
\CommentTok{     * del vector i comparar{-}les amb millorPivot:}
\CommentTok{     * 1. Si la jugadora del vector és millor}
\CommentTok{     *    que millorPivot, copiarem les dades}
\CommentTok{     *    de la jugadora cap a millorPivot.}
\CommentTok{     * 2. Si millorPivot és millor que la}
\CommentTok{     *    jugadora del vector, no farem res.}
\CommentTok{     * En finalitzar el recorregut de totes}
\CommentTok{     * les jugadores del vector, tindrem que}
\CommentTok{     * millorPivot contindrà la jugadora}
\CommentTok{     * que estem buscant.}
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_JUGADORES; i++) \{}
\NormalTok{        resultat = compararJugadores(millorPivot, vJugadores[i]);}
        \ControlFlowTok{if}\NormalTok{ (resultat == }\DecValTok{1}\NormalTok{) \{}
\NormalTok{            copiarJugadora(\&millorPivot, vJugadores[i]);}
\NormalTok{        \}}
\NormalTok{    \}}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Millor opció com a pivot defensiu : "}\NormalTok{);}
\NormalTok{    mostrarJugadora(millorPivot);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j) \{}
\NormalTok{    printf(}\StringTok{"Introdueix les dades de la nova jugadora: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}nom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Cognom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}cognom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\textgreater{}\textgreater{} Promigs per partit:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Rebots: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&j{-}\textgreater{}rebots);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Taps: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&j{-}\textgreater{}taps);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j) \{}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\%s, \%s: \%.1f rebots, \%.1f taps }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, j.cognom, j.nom, j.rebots, j.taps);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen) \{}
    \CommentTok{/* Recordem: }
\CommentTok{     * {-} si el paràmetre és un punter, l\textquotesingle{}accessor }
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}{-}\textgreater{}\textquotesingle{}}
\CommentTok{     * {-} si el paràmetre és un valor, l\textquotesingle{}accessor}
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}.\textquotesingle{}}
\CommentTok{     */}
\NormalTok{    strcpy(desti{-}\textgreater{}nom, origen.nom);}
\NormalTok{    strcpy(desti{-}\textgreater{}cognom, origen.cognom);}
\NormalTok{    desti{-}\textgreater{}rebots = origen.rebots;}
\NormalTok{    desti{-}\textgreater{}taps = origen.taps;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ compararJugadores(tJugadora j1, tJugadora j2) \{}
    \CommentTok{/* Estem buscant una jugadora que }
\CommentTok{     * tingui un perfil de pivot defensiu, }
\CommentTok{     * amb el que agafarem:}
\CommentTok{     * 1. Aquella que tingui més rebots per partit}
\CommentTok{     * 2. En cas d\textquotesingle{}empat de rebots, aquella que}
\CommentTok{     *    faci més taps per partit}
\CommentTok{     */} 
    \ControlFlowTok{if}\NormalTok{ (j1.rebots \textgreater{} j2.rebots) \{}
        \ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{if}\NormalTok{ (j1.rebots \textless{} j2.rebots) \{}
            \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
            \CommentTok{/* En aquest punt tenim que }
\CommentTok{             * j1.rebots == j2.rebots,}
\CommentTok{             * amb el que anem a comparar el següent}
\CommentTok{             * atribut segons la prioritat definida}
\CommentTok{             * del perfil pivot defensiu}
\CommentTok{             */}
            \ControlFlowTok{if}\NormalTok{ (j1.taps \textgreater{} j2.taps) \{}
                \ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{if}\NormalTok{ (j1.taps \textless{} j2.taps) \{}
                    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{                \} }\ControlFlowTok{else}\NormalTok{ \{}
                    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Exemple d'execució:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Introdueix les dades de la nova jugadora: }
\NormalTok{    Nom: Julia}
\NormalTok{    Cognom: Sanz}
\NormalTok{    \textgreater{}\textgreater{} Promigs per partit:}
\NormalTok{    Rebots: }\FloatTok{7.9}
\NormalTok{    Taps: }\FloatTok{0.9}
\NormalTok{Introdueix les dades de la nova jugadora: }
\NormalTok{    Nom: Nuria}
\NormalTok{    Cognom: Gutierrez}
\NormalTok{    \textgreater{}\textgreater{} Promigs per partit:}
\NormalTok{    Rebots: }\FloatTok{7.9}
\NormalTok{    Taps: }\FloatTok{1.4}
\NormalTok{Introdueix les dades de la nova jugadora: }
\NormalTok{    Nom: Mireia}
\NormalTok{    Cognom: Mateu}
\NormalTok{    \textgreater{}\textgreater{} Promigs per partit:}
\NormalTok{    Rebots: }\FloatTok{6.8}
\NormalTok{    Taps: }\FloatTok{2.1}

\NormalTok{Millor opció com a pivot defensiu : }
\NormalTok{Gutierrez, Nuria: }\FloatTok{7.9}\NormalTok{ rebots, }\FloatTok{1.4}\NormalTok{ taps }
\end{Highlighting}
\end{Shaded}

\hypertarget{explicaciuxf3-sobre-lacciuxf3-copiarjugadora}{%
\subsection{Explicació sobre l'acció copiarJugadora()}\label{explicaciuxf3-sobre-lacciuxf3-copiarjugadora}}

L'acció \texttt{copiarJugadora(tJugadora\ *desti,\ tJugadora\ origen)} de l'exemple rep dos paràmetres:

\begin{itemize}
\tightlist
\item
  El primer d'ells és \texttt{desti}, un punter a una tupla de tipus \texttt{tJugadora}; una altra forma de dir-ho és que el valor de \texttt{desti} el \textbf{passem per referència}. Aquest paràmetre és de tipus \texttt{out}, ja que no utilitzem per res el valor inicial que té i només ens interessa el valor final que tindrà en executar l'acció.
\item
  El segon és \texttt{origen}, una tupla que \textbf{passem per valor}. Per tant en aquest cas no estem passant el punter a una \texttt{tJugadora}, sinó directament una \texttt{tJugadora}.
\end{itemize}

Quan tenim un punter a una tupla, accedim a l'element mitjançant l'operador \texttt{-\textgreater{}}. En canvi, si estem tractant una tupla accedirem a un atribut seu amb l'operador \texttt{.} (punt).

La codificació de l'acció és:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen) \{}
    \CommentTok{/* Recordem: }
\CommentTok{     * {-} si el paràmetre és un punter, l\textquotesingle{}accessor }
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}{-}\textgreater{}\textquotesingle{}}
\CommentTok{     * {-} si el paràmetre és un valor, l\textquotesingle{}accessor}
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}.\textquotesingle{}}
\CommentTok{     */}
\NormalTok{    strcpy(desti{-}\textgreater{}nom, origen.nom);}
\NormalTok{    strcpy(desti{-}\textgreater{}cognom, origen.cognom);}
\NormalTok{    desti{-}\textgreater{}rebots = origen.rebots;}
\NormalTok{    desti{-}\textgreater{}taps = origen.taps;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

No utilitzarem el prefix \texttt{\&} davant de la \texttt{tJugadora\ origen}, de la mateixa forma que no utilitzem l'\texttt{\&} quan anem a imprimir per pantalla amb \texttt{printf()} el valor d'una variable: com que estem tractant amb un valor, simplement hi accedim a ell i l'utilitzem. Per tant aquestes accions serien \textbf{incorrectes}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    strcpy(desti{-}\textgreater{}nom, \&origen.nom);}
\NormalTok{    strcpy(desti{-}\textgreater{}cognom, \&origen.cognom);}
\NormalTok{    desti{-}\textgreater{}rebots = \&origen.rebots;}
\NormalTok{    desti{-}\textgreater{}taps = \&origen.taps;}
\end{Highlighting}
\end{Shaded}

Sí que tenim una alternativa possible a l'operador \texttt{-\textgreater{}}, segons s'indica a la xWiki:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{    strcpy((*desti).nom, origen.nom);}
\NormalTok{    strcpy((*desti).cognom, origen.cognom);}
\NormalTok{    (*desti).rebots = origen.rebots;}
\NormalTok{    (*desti).taps = origen.taps;}
\end{Highlighting}
\end{Shaded}

Per tant aquest darrer bloc de codi es pot substituir a l'exemple i tot continua funcionant correctament, ja que són equivalents. Es pot utilitzar una forma o l'altra, tot i que l'operador \texttt{-\textgreater{}} sembla més fàcil d'entendre visualment.

\hypertarget{frequently-made-mistakes-5}{%
\section{Frequently Made Mistakes}\label{frequently-made-mistakes-5}}

\hypertarget{definiciuxf3-daccionsfuncions-noms-de-paruxe0metres}{%
\subsection{Definició d'accions/funcions: noms de paràmetres}\label{definiciuxf3-daccionsfuncions-noms-de-paruxe0metres}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action hotelCmp(in tHotel, in tHotel)
    { ... }
end action
\end{verbatim}

En l'exemple mostrat, sembla que la intenció és definir dos paràmetres, però falta indicar l'identificador (nom) per a cada un d'ells. Recordem que en la declaració de la capçalera d'una acció/funció, cal indicar, per a cada paràmetre:

\begin{itemize}
\tightlist
\item
  El tipus de paràmetre que rep l'acció o funció, (in, out o inout)
\item
  El tipus de dades del paràmetre (tHotel en l'exemple)
\item
  L'identificador associat al paràmetre (no definit en l'exemple).
\end{itemize}

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
action hotelCmp(in hotel1: tHotel, in hotel2: tHotel)
    { ... }
end action
\end{verbatim}

\hypertarget{definiciuxf3-daccionsfuncions-tipus-de-paruxe0metres}{%
\subsection{Definició d'accions/funcions: tipus de paràmetres}\label{definiciuxf3-daccionsfuncions-tipus-de-paruxe0metres}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action hotelCmp(in hotel1: tHotel, out hotel2: tHotel)
    hotel1.id = hotel2.id;
end action
\end{verbatim}

En la \textbf{declaració de la capçalera} d'una acció/funció cal indicar per a cada paràmetre el tipus de paràmetre que rep l'acció o funció: \texttt{in}, \texttt{out} o \texttt{inout}. Els paràmetres de tipus \texttt{in} no es poden modificar a l'interior de l'acció, mentre sí que podem fer-ho en el cas dels paràmetres de tipus \texttt{out} o \texttt{inout}. En l'exemple, s'està modificant el paràmetre \texttt{hotel1} actualitzant el valor d'un dels seus camps. O bé es tracta d'una confusió entre els dos paràmetres, o bé \texttt{hotel1} ha de ser de tipus \texttt{out}.

Pseudocodis correctes:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{action hotelCmp(in hotel1: tHotel, out hotel2: tHotel)}
\NormalTok{    hotel2.id = hotel1.id;}
\NormalTok{end action}
\end{Highlighting}
\end{Shaded}

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{action hotelCmp(out hotel1: tHotel, in hotel2: tHotel)}
\NormalTok{    hotel1.id = hotel2.id;}
\NormalTok{end action}
\end{Highlighting}
\end{Shaded}

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{action hotelCmp(out hotel1: tHotel, inout hotel2: tHotel)}
\NormalTok{    hotel1.id = hotel2.id;}
\NormalTok{end action}
\end{Highlighting}
\end{Shaded}

Fixeu-vos que si el paràmetre \texttt{hotel1} és de tipus \texttt{out} i hem de llegir el paràmetre \texttt{hotel2}, aquest segon paràmetre ha de ser forçosament de tipus \texttt{in} o \texttt{inout}, per la qual cosa n'hem modificat el tipus a la capçalera de la funció.

\hypertarget{definiciuxf3-de-funcions-tipus-de-dades-de-retorn}{%
\subsection{Definició de funcions: tipus de dades de retorn}\label{definiciuxf3-de-funcions-tipus-de-dades-de-retorn}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
function hotelCmp(h1: tHotel, h2: tHotel)
    { ... }
end function
\end{verbatim}

En l'exemple mostrat, \texttt{hotelCmp} està definida com a funció, amb els paràmetres d'entrada \texttt{h1} i \texttt{h2}, però les funcions sempre retornen un valor, i cal indicar-ne sempre el tipus de dades a la mateixa capçalera.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
function hotelCmp(h1: tHotel, h2: tHotel): integer
    { ... }
end function
\end{verbatim}

Observeu que en aquest cas, no cal indicar el tipus de paràmetres d'entrada (\texttt{in}, \texttt{out} o \texttt{inout}), perquè en les funcions els paràmetres sempre són d'entrada i no es poden modificar.

\hypertarget{definiciuxf3-daccions-retorn-de-valor}{%
\subsection{Definició d'accions: retorn de valor}\label{definiciuxf3-daccions-retorn-de-valor}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action hoteTableInit(inout tHotelTable: tabHotels): void
    { ... }
end action
\end{verbatim}

Aquí s'ha definit una acció anomenada \texttt{hotelTableInit}, que rep un paràmetre d'entrada/sortida (\texttt{inout}) de tipus \texttt{tHotelTable}, amb l'identificador \texttt{tabHotels}. Les accions mai retornen un valor, però erròniament s'ha interpretat que cal indicar aquest fet afegint \texttt{:void} al final de la capçalera de l'acció.

Aquest cas és doblement incorrecte degut a que \texttt{:void} és un identificador propi de C que no existeix en llenguatge algorísmic.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
action hoteTableInit(inout tHotelTable: tabHotels)
    { ... }
end action
\end{verbatim}

Observeu que en aquest cas, en tractar-se d'una \textbf{acció} cal indicar el tipus de paràmetres d'entrada: \texttt{in}, \texttt{out} o \texttt{inout}.

\hypertarget{definiciuxf3-daccionsfuncions-accions-obertes}{%
\subsection{Definició d'accions/funcions: accions obertes}\label{definiciuxf3-daccionsfuncions-accions-obertes}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action hotelCmp(in hotel1: tHotel, out hotel2: tHotel)
    hotel1.id = hotel2.id;
    { ... }
action readHotel(out hotel1: tHotel)
    hotel1.id = readInteger();
end action
\end{verbatim}

Les \textbf{funcions} i \textbf{accions} constitueixen \textbf{blocs de codi} amb unes funcionalitats i característiques especials, i com a tal han d'estar ben delimitades, mitjançant les paraules reservades \texttt{function} \ldots{} \texttt{end\ function} i \texttt{action} \ldots{} \texttt{end\ action}. Deixar una acció sense tancar pot semblar un tema menor, però en C això comportarà amb tota seguretat un error de compilació (sovint difícil de detectar).

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
action hotelCmp(in hotel1: tHotel, out hotel2: tHotel)
    hotel1.id = hotel2.id;
    { ... }
end action
action readHotel(out hotel1: tHotel)
    hotel1.id = readInteger();
end action
\end{verbatim}

\hypertarget{crida-a-funcionsaccions-tipus-de-paruxe0metres}{%
\subsection{Crida a funcions/accions: tipus de paràmetres}\label{crida-a-funcionsaccions-tipus-de-paruxe0metres}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
hotelRead(out h1: tHotel);
hotelRead(out h2: tHotel);

action hotelRead(out h: tHotel)
    { ... }
end action
\end{verbatim}

El tipus de paràmetre que rep una acció/funció, així com el tipus de dades i l'identificador del paràmetre, cal indicar-los únicament en la \textbf{definició de la capçalera} de l'\textbf{acció}. En el cas de \textbf{funcions}, no indicarem el tipus de dades perquè sempre són de tipus \texttt{in}.

En la \textbf{crida} a una acció/funció únicament cal indicar els paràmetres.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
hotelRead(h1);
hotelRead(h2);

action hotelRead(out h: tHotel)
    { ... }
end action
\end{verbatim}

\hypertarget{crida-a-accionsfuncions-paraules-reservades}{%
\subsection{Crida a accions/funcions: paraules reservades}\label{crida-a-accionsfuncions-paraules-reservades}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
action hotelRead(h1);
action hotelRead(h2);

action hotelRead(out h: tHotel)
    { ... }
end action
\end{verbatim}

La paraula reservada \texttt{action} cal indicar-la únicament en la \textbf{definició de la capçalera} de l'acció.

En la \textbf{crida} a una acció únicament cal indicar el nom de l'acció i els paràmetres; es incorrecto afegir novament la paraula reservada \texttt{action}.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
hotelRead(h1);
hotelRead(h2);

action hotelRead(out h: tHotel)
    { ... }
end action
\end{verbatim}

\hypertarget{crida-a-funcions-crida-buida}{%
\subsection{Crida a funcions: crida buida}\label{crida-a-funcions-crida-buida}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
bestHotel: integer;

compareHotels(h1,h2);

if (bestHotel = 1) then
    { ... }
end if  

function hotelRead(h1: tHotel, h2: tHotel): integer
    { ... }
    return bestHotel;
end function
\end{verbatim}

Com passa en totes les funcions, \texttt{hotelRead()} retorna un valor: en aquest cas, la variable \texttt{bestHotel}. No obstant, la \textbf{crida} que es fa de la funció no és correcta, perquè el retorn de la funció no es guarda enlloc, i la variable \texttt{bestHotel} del programa principal segueix sense haver-se actualitzat.

En el cas de C aquest codi no provocaria un error, però si no fem res més des del programa principal no tindrem accés al resultat que retorna la funció (que és el que se suposa que volíem fer).

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
bestHotel: integer;

bestHotel:= compareHotels(h1,h2);

if (bestHotel = 1) then
    {...}
end if  

function hotelRead(h1: tHotel, h2: tHotel): integer
    {...}
    return bestHotel;
end function
\end{verbatim}

El retorn d'una funció també es pot utilitzar en una expressió, en aquest cas sense assignar-lo a cap variable, ja que en la mateixa expressió, el compilador calcularà el retorn de la funció i el substituirà el valor corresponent dins la funció:

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
bestHotel: integer;

if (compareHotels(h1,h2) = 1) then
    { ... }
end if  

function hotelRead(h1: tHotel, h2: tHotel): integer
    { ... }
    return bestHotel;
end function
\end{verbatim}

\hypertarget{crida-a-funcions-absuxe8ncia-de-paruxe0metres}{%
\subsection{Crida a funcions: absència de paràmetres}\label{crida-a-funcions-absuxe8ncia-de-paruxe0metres}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    myReal: real;
    myInteger: integer;
end var

myInteger:= integerToReal();
\end{verbatim}

La funció \texttt{integerToReal} retorna un valor i el guardem a la variable \texttt{myInteger}. El problema és que la funció necessita que li passem un \textbf{paràmetre} quan la cridem: en aquest cas, el nombre real a convertir a enter.

En cas de dubte, cal que consultem sempre la \textbf{capçalera de declaració} de la funció, ja que ens indicarà en cada cas el nombre i tipus de paràmetres que espera.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    myReal: real;
    myInteger: integer;
end var

myInteger:= integerToReal(myReal);
\end{verbatim}

\hypertarget{crida-a-funcions-errors-de-sintaxi-muxfaltiples}{%
\subsection{Crida a funcions: errors de sintaxi múltiples}\label{crida-a-funcions-errors-de-sintaxi-muxfaltiples}}

Pseudocodi incorrecte:

\includegraphics{./img/alg_err.png}

\begin{verbatim}
var
    hotel1: tHotel;
end var

hotelRead(in: &myHotel);

action hotelRead(in myHotel: tHotel)
    { ... }
end action
\end{verbatim}

El pseudocodi anterior mostra una barreja d'errors de sintaxi diversos en la crida a la funció (n'és només un exemple):
- S'indica el tipus \texttt{in}.
- S'inclou l'operador \texttt{:}.
- S'afegeix sintaxi pròpia de C amb l'operador \texttt{\&}, per passar el paràmetre \texttt{myHotel} per referència. En llenguatge algorísmic el pas d'un paràmetre per referència es determina mitjançant la capçalera de la funció.

Pseudocodi correcte:

\includegraphics{./img/alg.png}

\begin{verbatim}
var
    hotel1: tHotel;
end var

hotelRead(myHotel);

action hotelRead(in myHotel: tHotel)
    { ... }
end action
\end{verbatim}

\hypertarget{definiciuxf3-de-funcions-funcions-dins-el-main}{%
\subsection{Definició de funcions: funcions dins el main}\label{definiciuxf3-de-funcions-funcions-dins-el-main}}

Codi incorrecte:

\includegraphics{./img/c_err.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\PreprocessorTok{\#define MAX\_LEN 15}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1;}
    \DataTypeTok{int}\NormalTok{ num2;}
    \DataTypeTok{bool}\NormalTok{ myBool;}

    \DataTypeTok{bool}\NormalTok{ compareNumbers(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2)\{}
       \ControlFlowTok{return}\NormalTok{ (n1 \textgreater{} n2); }
\NormalTok{    \}}
    
\NormalTok{    myBool = compareNumbers(num1, num2);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Les funcions i accions cal definir-les de forma individual i separada. No és correcte definir funcions niades o incloses dins d'altres (com per exemple el \texttt{main}), entre altres coses perquè aquestes funcions no estaran disponibles des de l'exterior de la funció on són creades.

Codi correcte:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\PreprocessorTok{\#define MAX\_LEN 15}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ num1;}
    \DataTypeTok{int}\NormalTok{ num2;}
    \DataTypeTok{bool}\NormalTok{ myBool;}
\NormalTok{    myBool = compareNumbers(num1, num2);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ compareNumbers(}\DataTypeTok{int}\NormalTok{ n1, }\DataTypeTok{int}\NormalTok{ n2)\{}
    \ControlFlowTok{return}\NormalTok{ (n1 \textgreater{} n2); }
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac07}{%
\chapter{PAC07}\label{pac07}}

\hypertarget{quan-utilitzar-dins-de-funcionsaccions}{%
\section{Quan utilitzar \& dins de funcions/accions}\label{quan-utilitzar-dins-de-funcionsaccions}}

De vegades quan fem crides a \textbf{accions} dins d'\textbf{accions}, veiem que si passem un paràmetre amb \texttt{\&} els resultats no són correctes, però en canvi passant el paràmetre sense l'\texttt{\&} tot funciona. I a l'inrevés.

Per tal d'aclarir aquests dubtes utilitzarem el següent exemple: és un programa senzill que treballa amb tipus \texttt{tPac}. Un element \texttt{tPac} conté dos atributs: un \texttt{nom} (cadena de caràcters) i una \texttt{nota} (decimal). El programa realitza la lectura de valors des de teclat amb l'acció \texttt{pacRead(...)}, la modificació del nom de la PAC amb \texttt{nomToUpperCase(...)}, i la seva posterior impressió per pantalla mitjançant \texttt{pacWrite(...)}.

Amb l'objectiu de deixar-ho tot el més clar possible s'han afegit comentaris extensos dins del programa, explicant en cada situació què es fa i per quin motiu.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Definició de constants */}
\PreprocessorTok{\#define MAX\_NOM 5+1}

\CommentTok{/* Definició de la tupla tPac */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{float}\NormalTok{ nota;}
\NormalTok{\} tPac;}

\CommentTok{/* Predeclaració de funcions i accions */}

\CommentTok{/* Acció que llegeix per teclat els atributs d\textquotesingle{}un }
\CommentTok{ * tipus tPac i li assigna els valors. En aquest}
\CommentTok{ * cas el paràmetre pac és de tipus \textquotesingle{}out\textquotesingle{}, donat que }
\CommentTok{ * el seu valor abans i després d\textquotesingle{}executar l\textquotesingle{}acció}
\CommentTok{ * haurà canviat. A més, com que el valor inicial}
\CommentTok{ * de pac no ens interessa per res (recordem que}
\CommentTok{ * l\textquotesingle{}objectiu d\textquotesingle{}aquesta acció és llegir de teclat}
\CommentTok{ * i donar valor a pac, per tant sobreescriurem }
\CommentTok{ * qualsevol valor previ que tingui), podem }
\CommentTok{ * descartar que sigui de tipus \textquotesingle{}inout\textquotesingle{}.}
\CommentTok{ * Quan un paràmetre és de tipus out/inout, el }
\CommentTok{ * passem per referència o, el que és el mateix,}
\CommentTok{ * passem un punter a un tipus d\textquotesingle{}element; com }
\CommentTok{ * es pot veure, aquí pac és un punter a un }
\CommentTok{ * element de tipus tPac, ja que va precedit per *.}
\CommentTok{ * Utilitzem un punter perquè és l\textquotesingle{}única manera}
\CommentTok{ * que tenim de modificar un element definit}
\CommentTok{ * fora de l\textquotesingle{}àmbit de l\textquotesingle{}acció, des de dins de }
\CommentTok{ * la pròpia acció.}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ pacRead(tPac *pac);}

\CommentTok{/* Acció que, donat un tipus tPac, mostra el seu }
\CommentTok{ * contingut (nom i nota) per pantalla. Aquí el }
\CommentTok{ * paràmetre pac és de tipus \textquotesingle{}in\textquotesingle{}: el seu valor}
\CommentTok{ * abans i després d\textquotesingle{}executar l\textquotesingle{}acció no variarà.}
\CommentTok{ * Un paràmetre de tipus \textquotesingle{}in\textquotesingle{} el passem per valor: }
\CommentTok{ * en aquest cas és un element de tipus tPac. }
\CommentTok{ * Com es pot veure, no ha d\textquotesingle{}anar precedit per *.}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ pacWrite(tPac pac);}

\CommentTok{/* Acció que, donat un tipus tPac, agafa el seu}
\CommentTok{ * nom i el passa a majúscules. Per exemple, si}
\CommentTok{ * el nom és "pAc01" el modificarà a "PAC01".}
\CommentTok{ * El paràmetre és de tipus \textquotesingle{}inout\textquotesingle{}: el seu valor}
\CommentTok{ * abans i després d\textquotesingle{}executar l\textquotesingle{}acció haurà canviat}
\CommentTok{ * i a més a més, el valor inicial que té és}
\CommentTok{ * important, ja que el necessitem per calcular el}
\CommentTok{ * valor final ("pAc01" {-}{-}\textgreater{} "PAC01"). En ser un}
\CommentTok{ * paràmetre de tipus \textquotesingle{}inout\textquotesingle{}, passarem el seu}
\CommentTok{ * valor per referència: necessitem que pugui ser}
\CommentTok{ * modificat des de dins de l\textquotesingle{}acció, amb el que}
\CommentTok{ * és necessari treballar amb un punter a l\textquotesingle{}element}
\CommentTok{ * pac, d\textquotesingle{}aquí que vagi precedit amb *.}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ nomToUpperCase(tPac *pac);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* Definim les variables */}
\NormalTok{    tPac pac1, pac2, pac3;}

    \CommentTok{/* Donem valor als atributs de cadascuna}
\CommentTok{     * de les 3 PAC. Fixeu{-}vos que estem passant}
\CommentTok{     * punters a elements de tipus tPac: el \&}
\CommentTok{     * previ indica que agafem la direcció de }
\CommentTok{     * memòria on resideix l\textquotesingle{}element de tipus }
\CommentTok{     * tPac. Com que passem punters a memòria, }
\CommentTok{     * des de dins de l\textquotesingle{}acció podrem modificar}
\CommentTok{     * el contingut de pac1, pac2 i pac3, tot}
\CommentTok{     * i que aquestes tres variables han estat}
\CommentTok{     * definides fora de l\textquotesingle{}àmbit de l\textquotesingle{}acció.}
\CommentTok{     */}
\NormalTok{    pacRead(\&pac1);}
\NormalTok{    pacRead(\&pac2);}
\NormalTok{    pacRead(\&pac3);}
    
    \CommentTok{/* Mostrem per pantalla els atributs de}
\CommentTok{     * cadascuna de les 3 PAC. En aquest cas}
\CommentTok{     * el pas de paràmetres es fa per valor:}
\CommentTok{     * passem directament els elements de tipus}
\CommentTok{     * tPac, ja que aquests no seran modificats}
\CommentTok{     * des de dins de l\textquotesingle{}acció (són de tipus \textquotesingle{}in\textquotesingle{}).}
\CommentTok{     */}
\NormalTok{    pacWrite(pac1);}
\NormalTok{    pacWrite(pac2);}
\NormalTok{    pacWrite(pac3);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions i accions */}

\DataTypeTok{void}\NormalTok{ pacRead(tPac *pac) \{}
    \CommentTok{/* Llegim des de teclat el valor}
\CommentTok{     * corresponent al nom de la PAC}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Introdueix nom : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, pac{-}\textgreater{}nom);}

    \CommentTok{/* Llegim des de teclat el valor}
\CommentTok{     * corresponent a la nota de la PAC}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Introdueix nota: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&pac{-}\textgreater{}nota);}
    
    \CommentTok{/* Ara arribem en un punt on, dins d\textquotesingle{}una}
\CommentTok{     * acció, cridem a un altra acció. Hem de }
\CommentTok{     * passar com a atribut pac? o bé \&pac?. }
\CommentTok{     * Davant d\textquotesingle{}aquest dubte, ens hem de }
\CommentTok{     * preguntar quin tipus de valor conté ara}
\CommentTok{     * mateix (abans d\textquotesingle{}executar la següent acció)}
\CommentTok{     * el paràmetre pac. Si recordem com està }
\CommentTok{     * definida l\textquotesingle{}acció pacRead(tPac *pac), pac}
\CommentTok{     * és un punter a memòria, ja que va precedit}
\CommentTok{     * per *. Això significa que en aquest precís}
\CommentTok{     * moment pac continua sent un punter.}
\CommentTok{     * D\textquotesingle{}altra banda, si ens fixem amb la definició}
\CommentTok{     * de l\textquotesingle{}acció nomToUpperCase(tPac *pac), veiem}
\CommentTok{     * que també espera rebre un punter. Així com }
\CommentTok{     * que pac és un punter i nomToUpperCase(...)}
\CommentTok{     * espera rebre un punter, simplement li passem}
\CommentTok{     * pac com a paràmetre (i no pas \&pac!)}
\CommentTok{     */}
\NormalTok{    nomToUpperCase(pac);}
\NormalTok{    printf(}\StringTok{"{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}{-}}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ pacWrite(tPac pac) \{}
    \CommentTok{/* Mostrem per pantalla els valors}
\CommentTok{     * dels atributs de la PAC}
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} \%s amb nota \%.1f }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, pac.nom, pac.nota);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ nomToUpperCase(tPac *pac) \{}
    \CommentTok{/* Hi ha llibreries que ja implementen els canvis}
\CommentTok{     * a majúscules o minúscules. En aquest cas però}
\CommentTok{     * hem optat per no utilitzar{-}ne cap, i implementar{-}la}
\CommentTok{     * nosaltres mateixos, tractant l\textquotesingle{}string nom de pac}
\CommentTok{     * com a un recorregut caràcter a caràcter.}
\CommentTok{     */}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; pac{-}\textgreater{}nom[i] != }\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{; i++) \{}
        \ControlFlowTok{if}\NormalTok{ (pac{-}\textgreater{}nom[i] \textgreater{}= }\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{ \&\& pac{-}\textgreater{}nom[i] \textless{}= }\CharTok{\textquotesingle{}z\textquotesingle{}}\NormalTok{) \{}
\NormalTok{            pac{-}\textgreater{}nom[i] = pac{-}\textgreater{}nom[i] + (}\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{ {-} }\CharTok{\textquotesingle{}a\textquotesingle{}}\NormalTok{);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-com-modular-un-programa-amb-codelite}{%
\section{Exemple: com modular un programa amb CodeLite}\label{exemple-com-modular-un-programa-amb-codelite}}

A continuació explicaré detalladament com modular el programa típic \texttt{HelloWorld} d'una forma diferent de com s'explica als vídeos de la xWiki, que pot ser més entenedora. L'explicació és una mica extensa per tal que quedi el més clar possible.

\hypertarget{funcionament-per-defecte-dun-projecte-a-codelite}{%
\subsection{Funcionament per defecte d'un projecte a CodeLite:}\label{funcionament-per-defecte-dun-projecte-a-codelite}}

Quan a CodeLite creem un nou projecte, per exemple \texttt{Modularitat}, amb el típic \texttt{main.c} inicial que conté el programa \texttt{HelloWorld}, tenim la següent distribució d'arxius

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l}
\NormalTok{total }\DecValTok{12}
\NormalTok{{-}rw{-}r{-}{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{93}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ main.c}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4274}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ Modularitat.project}
\end{Highlighting}
\end{Shaded}

Si compilem aquest programa a CodeLite, veiem que ens ha generat una carpeta nova anomenada \texttt{Debug}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l}
\NormalTok{total }\DecValTok{24}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ Debug}
\NormalTok{{-}rw{-}r{-}{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{93}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ main.c}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{3249}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ Modularitat.mk}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4274}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ Modularitat.project}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{17}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ Modularitat.txt}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$}
\end{Highlighting}
\end{Shaded}

El contingut de la carpeta \texttt{Debug} és el programa executable final juntament amb els arxius objecte intermitjos:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ cd Debug}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/Debug$ ls {-}l}
\NormalTok{total }\DecValTok{24}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4620}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ main.c.o}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{23}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ main.c.o.d}
\NormalTok{{-}rwxrwxr{-}x }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{9708}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ Modularitat}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/Debug$}
\end{Highlighting}
\end{Shaded}

Si es vol, des d'un terminal de Lubuntu es pot executar el programa resultant \texttt{Modularitat} de la següent forma:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/Debug$ ./Modularitat}
\NormalTok{hello world}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/Debug$}
\end{Highlighting}
\end{Shaded}

\hypertarget{executable-dins-de-bin.}{%
\subsection{Executable dins de /bin.}\label{executable-dins-de-bin.}}

Anem ara a modificar CodeLite per tal que l'executable ens el guardi sempre dins de la carpeta \texttt{./bin}.

El primer video de la xWiki indica com canviar la carpeta on es desa l'arxiu executable resultant de compilar el nostre programa. L'objectiu és que en comptes d'utilitzar la carpeta \texttt{./Debug} l'arxiu executable es desi dins de la nova carpeta \texttt{./bin}

Atenció: aquest apartat no es demana explícitament a la PAC07 (únicament es parla de les carpetes \texttt{./src} i \texttt{./include}), amb el que no cal aplicar-ho a la PAC.

Per fer aquest canvi, fem clic botó dret del ratolí sobre el nom del projecte, \textbf{Modularitat} -\textgreater{} \textbf{Settings\ldots{}} -\textgreater{} \textbf{General} -\textgreater{} \textbf{Output File}: hi posem el valor \texttt{./bin/\$(ProjectName)}. Això significa que l'executable es desarà dins de la carpeta \texttt{./bin} i que el seu nom serà el mateix que el nom del projecte (en el cas que tractem, s'anomenarà \texttt{Modularitat})

A més, sense sortir d'aquesta mateixa pantalla, canviem el valor del \textbf{Working Directory} per : \texttt{./bin}. Aquest valor és el que té en consideració CodeLite a l'hora de buscar l'executable del projecte, per quan fem el \texttt{Run}.

Guardem els canvis i si ara compilem novament el programa, veiem que ha creat la carpeta \texttt{./bin} dins del nostre projecte:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l}
\NormalTok{total }\DecValTok{28}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{11}\NormalTok{ bin}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{58}\NormalTok{ Debug}
\NormalTok{{-}rw{-}r{-}{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{93}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ main.c}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{3230}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{11}\NormalTok{ Modularitat.mk}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4350}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{10}\NormalTok{ Modularitat.project}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{17}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{11}\NormalTok{ Modularitat.txt}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ }
\end{Highlighting}
\end{Shaded}

Igual que en el cas anterior, si volem podem executar el programa des del propi terminal:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ cd ./bin}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/bin$ ls {-}l}
\NormalTok{total }\DecValTok{12}
\NormalTok{{-}rwxrwxr{-}x }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{9708}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{11}\NormalTok{ Modularitat}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/bin$ ./Modularitat }
\NormalTok{hello world}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat/bin$}
\end{Highlighting}
\end{Shaded}

A partir d'aquest moment, sempre que compilem el nostre programa, guardarà l'executable dins de la carpeta \texttt{./bin}.

\hypertarget{modularitzaciuxf3-del-programa-en-un-arxiu-de-capuxe7aleres-i-un-de-funcions.}{%
\subsection{Modularització del programa en un arxiu de capçaleres i un de funcions.}\label{modularitzaciuxf3-del-programa-en-un-arxiu-de-capuxe7aleres-i-un-de-funcions.}}

Centrarem ara l'explicació amb l'estructura que es demana a la PAC07 i treballant sobre el mateix exemple \texttt{Modularitat}.

El que volem aconseguir és la següent estructura:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{projecte Modularitat}
\NormalTok{   |}
\NormalTok{   |{-}{-} /include/}
\NormalTok{   |     |}
\NormalTok{   |     \textbackslash{}{-}{-} helloWorld.h}
\NormalTok{   |}
\NormalTok{   \textbackslash{}{-}{-} /src/}
\NormalTok{         |}
\NormalTok{         |{-}{-} helloWorld.c}
\NormalTok{         \textbackslash{}{-}{-} main.c}
\end{Highlighting}
\end{Shaded}

L'objectiu és dividir (modularitzar) l'arxiu únic \texttt{main.c} que tenim fins ara en tres arxius:

\begin{itemize}
\tightlist
\item
  \texttt{helloWorld.h} : aquest arxiu contindrà la predeclaració de totes les funcions i accions del nostre programa, així com la definició de tots els tipus necessaris (enumeratius, tuples, etc) i constants que requereixi el nostre programa C. Aquest arxiu l'ubicarem dins de la carpeta \texttt{./include} del nostre projecte
\item
  \texttt{helloWorld.c} : dins d'ell s'implementaran totes les accions i funcions del programa. Bàsicament contindrà el codi de tot allò que hem predeclarat a l'arxiu \texttt{helloWorld.h}.
\item
  \texttt{main.c} : contindrà el codi del programa principal, identificat per la funció \texttt{main()}.
\end{itemize}

El primer pas que podem fer és crear les dues carpetes que necessitarà el nostre projecte modularitzat, \texttt{src} i \texttt{include} :

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ mkdir src}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ mkdir include}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l}
\NormalTok{total }\DecValTok{36}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{14}\NormalTok{ bin}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{14}\NormalTok{ Debug}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{18}\NormalTok{ include}
\NormalTok{{-}rw{-}r{-}{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{93}\NormalTok{ nov }\DecValTok{17} \DecValTok{23}\NormalTok{:}\DecValTok{56}\NormalTok{ main.c}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{3230}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{14}\NormalTok{ Modularitat.mk}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4350}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{10}\NormalTok{ Modularitat.project}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{17}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{14}\NormalTok{ Modularitat.txt}
\NormalTok{drwxrwxr{-}x }\DecValTok{2}\NormalTok{ uoc uoc }\DecValTok{4096}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{18}\NormalTok{ src}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ }
\end{Highlighting}
\end{Shaded}

El següent pas és transformar el programa \texttt{HelloWorld} típic en un programa modularitzat: per aquest motiu ens cal la definició d'algunes funcions o accions que ens permetin separar un únic arxiu en un de capçaleres (\texttt{helloWorld.h}), un d'implementació de funcions/accions (\texttt{helloWorld.c}) i un principal (\texttt{main.c}). Per tant, l'objectiu és passar del següent programa\ldots{} :

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\ldots{} al següent codi modularitzat:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage();}

\CommentTok{/* Codi principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    showHelloMessage();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage() \{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

Si s'executa el nou codi dins d'un únic \texttt{main.c}, aquest seguirà mostrant correctament el missatge de \emph{``hello world''}. L'objectiu és acabant-lo dividint en tres blocs:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Inici contingut de l\textquotesingle{}arxiu helloWorld.h */}
\CommentTok{/* Predeclaració de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage();}
\CommentTok{/* Fi contingut de l\textquotesingle{}arxiu helloWorld.h */}

\CommentTok{/* Inici contingut de l\textquotesingle{}arxiu main.c */}
\CommentTok{/* Codi principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    showHelloMessage();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\CommentTok{/* Fi contingut de l\textquotesingle{}arxiu main.c */}

\CommentTok{/* Inici contingut de l\textquotesingle{}arxiu helloWorld.c */}
\CommentTok{/* Implementació de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage() \{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\};}
\CommentTok{/* Fi contingut de l\textquotesingle{}arxiu helloWorld.c */}
\end{Highlighting}
\end{Shaded}

El primer pas que farem serà eliminar des de CodeLite el programa vell; per tant, \textbf{CodeLite} -\textgreater{} projecte \textbf{Modularitat} -\textgreater{} \textbf{src} -\textgreater{} botó dret sobre el nom de l'arxiu \texttt{main.c} -\textgreater{} \textbf{Remove} -\textgreater{} confirmem l'esborrat -\textgreater{} confirmem l'esborrat de l'arxiu \texttt{main.c} del disc.

En aquest punt, a CodeLite, dins del projecte \texttt{Modularitat} únicament hi tenim una carpeta \emph{virtual} anomenada \texttt{src}. Atenció: la carpeta \emph{virtual} anomenada \texttt{src} del nostre projecte de CodeLite en aquests moments no té cap relació amb la carpeta \texttt{./src} que hem creat fa un moment.

Creem el programa principal main.c fent: \textbf{CodeLite} -\textgreater{} projecte \textbf{Modularitat} -\textgreater{} botó dret sobre carpeta \textbf{src} -\textgreater{} \textbf{Add New File} -\textgreater{} seleccionem el tipus \textbf{C Source File (.c)} -\textgreater{} indiquem com a \textbf{Name}: \texttt{main.c}, i com a \textbf{Location} seleccionem la carpeta \texttt{./src} que hem creat abans.

Anem a crear el segon arxiu, \texttt{helloWorld.c}, exactament de la mateixa forma: \textbf{CodeLite} -\textgreater{} projecte \textbf{Modularitat} -\textgreater{} botó dret sobre carpeta \textbf{src} -\textgreater{} \textbf{Add New File} -\textgreater{} seleccionem el tipus \textbf{C Source File (.c)} -\textgreater{} indiquem com a \textbf{Name}: \texttt{helloWorld.c}, i com a \textbf{Location} seleccionem la carpeta \texttt{./src} creada anteriorment.

Creem ara una carpeta \emph{virtual} dins del nostre projecte amb \textbf{CodeLite} -\textgreater{} botó dret sobre el projecte \textbf{Modularitat} -\textgreater{} \textbf{New Virtual Folder} -\textgreater{} li posem per nom: \texttt{include}

Per finalitzar, creem el tercer arxiu requerit: \texttt{helloWorld.h}. Els passos seran: \textbf{CodeLite} -\textgreater{} projecte \textbf{Modularitat} -\textgreater{} botó dret sobre carpeta \textbf{include} -\textgreater{} \textbf{Add New File} -\textgreater{} seleccionem el tipus \textbf{Header File (.h)} -\textgreater{} indiquem com a \textbf{Name}: \texttt{helloWorld.h}, i com a \textbf{Location} seleccionem la carpeta \texttt{./include} creada anteriorment.

En aquest punt el nostre projecte \texttt{Modularitat} a CodeLite tindrà l'estructura desitjada:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{projecte Modularitat}
\NormalTok{   |}
\NormalTok{   |{-}{-} /include/}
\NormalTok{   |     |}
\NormalTok{   |     \textbackslash{}{-}{-} helloWorld.h}
\NormalTok{   |}
\NormalTok{   \textbackslash{}{-}{-} /src/}
\NormalTok{         |}
\NormalTok{         |{-}{-} helloWorld.c}
\NormalTok{         \textbackslash{}{-}{-} main.c}
\end{Highlighting}
\end{Shaded}

Ara només cal donar contingut als 3 arxius buits que hem creat.

Comencem per l'arxiu de capçaleres \texttt{helloWorld.h}. L'editem com ho fem habitualment a CodeLite, i li copiem el fragment de codi que hem dit abans que li corresponia:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage();}
\end{Highlighting}
\end{Shaded}

Editem l'arxiu \texttt{helloWorld.c} i li afegim el codi corresponent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* Implementació de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage() \{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

I per finalitzar editem el contingut de l'arxiu \texttt{main.c} amb el codi comentat anteriorment:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* Codi principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    showHelloMessage();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En aquest punt tenim el programa modularitzat, però ens falta dues qüestions:

\begin{itemize}
\tightlist
\item
  Configurar CodeLite per tal que tingui presents on buscar l'arxiu de capçaleres \texttt{.h} quan hi fem referència.
\item
  Fer que els arxius estiguin enllaçats entre ells: ara mateix són completament independents.
\end{itemize}

Anem pel primer punt: per indicar a CodeLite on trobarà tots els arxius \texttt{.h} d'un programa, només cal fer \textbf{CodeLite} -\textgreater{} clic botó dret sobre \textbf{Modularitat} -\textgreater{} \textbf{Settings\ldots{}} -\textgreater{} \textbf{Compiler} -\textgreater{} dins de l'opció \textbf{Include Paths} afegir el valor \texttt{.;./include}

Pel segon punt: tenim que l'arxiu \texttt{main.c} en aquests moments fa referència a una acció anomenada \texttt{showHelloMessage()}, de la qual no en sabem res. El que ens cal és importar l'arxiu de capçaleres; com que és un arxiu que hem creat nosaltres, l'\texttt{include} va entre cometes dobles:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{"helloWorld.h"}

\CommentTok{/* Codi principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    showHelloMessage();}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El següent pas serà afegir l'\texttt{include} habitual de la llibreria \texttt{stdio.h} dins de l'arxiu \texttt{helloWorld.c}, ja que en ell utilitzem la funció \texttt{printf()} inclosa en aquesta llibreria:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Implementació de les funcions/accions */}
\DataTypeTok{void}\NormalTok{ showHelloMessage() \{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{\};}
\end{Highlighting}
\end{Shaded}

En aquest punt ja podem executar el nostre programa modularitzat correctament.

L'estructura resultant i el contingut de cada carpeta és el desitjat:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l ./bin}
\NormalTok{total }\DecValTok{12}
\NormalTok{{-}rwxrwxr{-}x }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{10172}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ Modularitat}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l ./include/}
\NormalTok{total }\DecValTok{4}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{70}\NormalTok{ nov }\DecValTok{18} \BaseNTok{00}\NormalTok{:}\DecValTok{54}\NormalTok{ helloWorld.h}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l ./src}
\NormalTok{total }\DecValTok{8}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{122}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ helloWorld.c}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{113}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\BaseNTok{07}\NormalTok{ main.c}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ ls {-}l ./Debug/}
\NormalTok{total }\DecValTok{20}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{4544}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ src\_helloWorld.c.o}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{43}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ src\_helloWorld.c.o.d}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc }\DecValTok{2440}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ src\_main.c.o}
\NormalTok{{-}rw{-}rw{-}r{-}{-} }\DecValTok{1}\NormalTok{ uoc uoc   }\DecValTok{75}\NormalTok{ nov }\DecValTok{18} \BaseNTok{01}\NormalTok{:}\ErrorTok{09}\NormalTok{ src\_main.c.o.d}
\NormalTok{uoc@fp:\textasciitilde{}/Documents/codelite/workspaces/Test/Modularitat$ }
\end{Highlighting}
\end{Shaded}

Ni per la realització d'aquest exemple ni per la PAC07 cal crear llibreries pròpies, amb el que aquest punt no el comento: únicament tractarem amb arxius de capçalera \texttt{.h}, arxius d'implementació \texttt{.c}, i l'arxiu corresponent al codi principal \texttt{main.c}.

\hypertarget{tipus-de-paruxe0metres-en-accions-i-funcions}{%
\section{Tipus de paràmetres en accions i funcions}\label{tipus-de-paruxe0metres-en-accions-i-funcions}}

En les \textbf{accions} els paràmetres poden ser de tipus \textbf{in}, \textbf{out} o \textbf{inout}. Cal especificar-ho en el moment de definir l'acció al nostre algorisme.

Exemple: tres formes d'implementar una suma de dos enters amb diferents accions segons els tipus \textbf{in}, \textbf{out} o \textbf{inout} dels paràmetres:

\includegraphics{./img/alg.png}

\begin{verbatim}
action suma1(in num1: integer, in num2: integer)
    var
        resultat: integer;
    end var

    resultat := num1 + num2;
    writeString("Resultat de la suma = ");
    writeInteger(resultat);
end action

action suma2(in num1: integer, in num2: integer, out resultat: integer)
    resultat := num1 + num2;
end action

action suma3(inout num1: integer, in num2: integer)
    num1 := num1 + num2;
end action
\end{verbatim}

A les funcions en canvi tots els paràmetres són d'entrada, amb el que no cal indicar l'\textbf{in}.

Exemple:

\includegraphics{./img/alg.png}

\begin{verbatim}
function suma4(num1: integer, num2: integer): integer
    var
        resultat: integer;
    end var

    resultat := num1 + num2;
    return resultat;
end function
\end{verbatim}

\hypertarget{scanf-acciuxf3-o-funciuxf3}{%
\section{scanf(): acció o funció?}\label{scanf-acciuxf3-o-funciuxf3}}

El que ens indica la signatura de \texttt{scanf()} és que estem davant d'una funció:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\DataTypeTok{int}\NormalTok{ scanf(}\DataTypeTok{const} \DataTypeTok{char}\NormalTok{ *format, type* var1, ...);}
\end{Highlighting}
\end{Shaded}

El segon argument no és de tipus \textbf{out}, ja que el que li passem no és la variable que guardarà el valor llegit, sinó el punter a la variable que guardarà el valor llegit, i aquest punter no varia en cap moment.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{/* Per exemple, el valor de \&numero és 0xbfb86c40 */}
\NormalTok{scanf(}\StringTok{"\%d"}\NormalTok{, \&numero)}
\CommentTok{/* una vegada executada la funció scanf(), el valor de \&numero continua sent 0xbfb86c40 */}
\end{Highlighting}
\end{Shaded}

La funció \texttt{scanf()} com a tal retorna un valor, tot i que nosaltres no l'utilitzem habitualment: el número d'elements processats correctament. Dit d'una altra forma: que una funció retorni un valor no ens obliga a recuperar-lo i tractar-lo, tot i que habitualment sí que ho farem.

D'altra banda, el fet de definir un paràmetre d'una funció/acció com a \texttt{const} significa que aquest paràmetre dins de l'acció/funció es comportarà com a una constant. Per tant dins de l'àmbit de la funció/acció no es podrà modificar.

Aquest fet ens pot interessar o no. Per exemple, imaginem que creem la següent funció per sumar dos enters:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de funcions/acions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ a = }\DecValTok{10}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ b = }\DecValTok{13}\NormalTok{;}

    \DataTypeTok{int}\NormalTok{ resultat = suma(a, b);}
\NormalTok{    printf(}\StringTok{"Resultat: \%d + \%d = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, b, resultat);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions/accions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB) \{}
\NormalTok{    numA = numA + numB;}
    \ControlFlowTok{return}\NormalTok{ (numA);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Dins de l'àmbit de la funció, ens interessa per exemple que el paràmetre \texttt{numA} sigui constant? No, ja que si ho definim d'aquesta forma la compilació ens fallarà:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de funcions/acions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ a = }\DecValTok{10}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ b = }\DecValTok{13}\NormalTok{;}

    \DataTypeTok{int}\NormalTok{ resultat = suma(a, b);}
\NormalTok{    printf(}\StringTok{"Resultat: \%d + \%d = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, b, resultat);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions/accions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{const} \DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB) \{}
\NormalTok{    numA = numA + numB;}
    \ControlFlowTok{return}\NormalTok{ (numA);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'error que obtindrem en intentar compilar el programa serà \emph{``error: assignment of read-only parameter `numA'\,''}, ja que dins de la funció suma estem modificant el valor de \texttt{numA}.

Molt important: que dins de la funció modifiquem el valor de \texttt{numA} no significa que fora de l'àmbit de la funció el valor de la variable a variï (ho podem comprovar al \texttt{printf()} que es fa posteriorment).

Per tant l'ús de const en un paràmetre s'hauria de limitar a aquells valors que s'hagin de tractar realment com a constants: per exemple, si passem la constant \texttt{PI\ =\ 3.14159...} com a paràmetre, dins de la funció segur que no tenim la necessitat de modificar aquesta constant matemàtica, amb el que en aquest cas és més adient utilitzar \texttt{const} en el paràmetre de la funció.

Com a darrer punt, no s'ha de confondre el fet de definir un paràmetre d'una funció com a \texttt{const}, a fer que fora de l'àmbit de la funció el paràmetre corresponent es defineixi com a constant:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\CommentTok{/* Predeclaració de funcions/acions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{const} \DataTypeTok{int}\NormalTok{ a = }\DecValTok{10}\NormalTok{;}
    \DataTypeTok{int}\NormalTok{ b = }\DecValTok{13}\NormalTok{;}

    \DataTypeTok{int}\NormalTok{ resultat = suma(a, b);}
\NormalTok{    printf(}\StringTok{"Resultat: \%d + \%d = \%d}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, a, b, resultat);}

    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de funcions/accions */}
\DataTypeTok{int}\NormalTok{ suma(}\DataTypeTok{int}\NormalTok{ numA, }\DataTypeTok{int}\NormalTok{ numB) \{}
\NormalTok{    numA = numA + numB;}
    \ControlFlowTok{return}\NormalTok{ (numA);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

En aquest cas quan compilem no obtindrem cap error, ja que la variable \texttt{a} és una constant fora de la funció \texttt{suma}, però el seu valor passat com a paràmetre dins de la funció no és una constant.

\hypertarget{pas-per-valor-vs-pas-per-referuxe8ncia}{%
\section{Pas per valor vs pas per referència}\label{pas-per-valor-vs-pas-per-referuxe8ncia}}

El clàssic \textbf{pas per valor} correspon als paràmetres de tipus \textbf{in}, en els quals passem la variable/valor.

D'altra banda el \textbf{pas per referència} consisteix en passar com a paràmetre de tipus \textbf{out} o \textbf{inout} la direcció de memòria de la variable (punter).

\hypertarget{exemple-capgirarparaula}{%
\section{Exemple: capgirarParaula}\label{exemple-capgirarparaula}}

Imagina que tenim una tupla \texttt{tParaula} la qual té dos camps:

\begin{itemize}
\tightlist
\item
  \texttt{cadena} : conté l'string amb el valor de la \texttt{tParaula}
\item
  \texttt{numeroCaractersCadena} : conté el número de caracters de la cadena
\end{itemize}

Implementem l'acció \texttt{capgirar()}, la qual fa dues operacions:

\begin{itemize}
\tightlist
\item
  Capgira el camp cadena de la \texttt{tParaula}; per exemple, si entrem ``Fonaments'' el resultat serà ``stnemanoF''.
\item
  Calcula el valor de \texttt{numeroCaractersCadena}; si tenim com a cadena ``Fonaments'', el valor serà 9.
\end{itemize}

Volem que per teclat es demani el valor pel camp \texttt{cadena} de dues \texttt{tParaula}, i en totes dues volem aplicar l'acció \texttt{capgirar()}. Una possible forma d'implementar-ho tot plegat seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\PreprocessorTok{\#define MAX\_CHAR 20+1}
\PreprocessorTok{\#define MAX\_PARAULES 2}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ cadena[MAX\_CHAR];}
    \DataTypeTok{int}\NormalTok{ numeroCaractersCadena;}
\NormalTok{\} tParaula;}

\CommentTok{/* Predeclaració de l\textquotesingle{}acció.}
\CommentTok{ * Aquesta acció reb un paràmetre inout de tipus tParaula,}
\CommentTok{ * el qual capgira el camp cadena, i calcula el valor}
\CommentTok{ * corresponent pel camp numeroCaractersCadena }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ capgirar(tParaula *mot);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
    
    \CommentTok{/* Introduim per teclat un total de MAX\_PARAULES */}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} MAX\_PARAULES; i++) \{}
\NormalTok{        tParaula paraula;}
    
\NormalTok{        printf(}\StringTok{"Introdueix una paraula : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, paraula.cadena);}
    
\NormalTok{        capgirar(\&paraula);}
\NormalTok{        printf(}\StringTok{"La paraula capgirada és : \%s, de \%d lletres.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, paraula.cadena, paraula.numeroCaractersCadena);}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{/* Implementació de l\textquotesingle{}acció */}
\DataTypeTok{void}\NormalTok{ capgirar(tParaula *mot) \{}
    
    \DataTypeTok{int}\NormalTok{ i;}
\NormalTok{    tParaula motCapgirat;}
    \DataTypeTok{int}\NormalTok{ midaMot = strlen(mot{-}\textgreater{}cadena);}
 
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}midaMot; i++ ) \{}
\NormalTok{        motCapgirat.cadena[(midaMot{-}}\DecValTok{1}\NormalTok{){-}i] = mot{-}\textgreater{}cadena[i];}
\NormalTok{    \}}
    
    \CommentTok{/* Indiquem el finalitzador de l\textquotesingle{}string */}
\NormalTok{    motCapgirat.cadena[midaMot] =}\CharTok{\textquotesingle{}\textbackslash{}0\textquotesingle{}}\NormalTok{;}
    
\NormalTok{    strcpy(mot{-}\textgreater{}cadena, motCapgirat.cadena);}
\NormalTok{    mot{-}\textgreater{}numeroCaractersCadena = midaMot;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'acció només rep un paràmetre \texttt{tParaula}, ja que únicament s'executa sobre una \texttt{tParaula}. Com la volem executar per a cadascuna de les dues \texttt{tParaula}, repetim la crida dues vegades dins del bucle, una per cada\texttt{tParaula}.

\hypertarget{exemple-isparell}{%
\section{Exemple: isParell}\label{exemple-isparell}}

Exemple de funció que retorna un booleà:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Predeclaració de la funció isParell, la qual retorna un}
\CommentTok{ * booleà que indica si el número passat per paràmetre és}
\CommentTok{ * parell (true) o no (false). }
\CommentTok{ */}
\DataTypeTok{bool}\NormalTok{ isParell(}\DataTypeTok{int}\NormalTok{ numero);}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \DataTypeTok{int}\NormalTok{ numero;}
    
\NormalTok{    printf(}\StringTok{"Tecleja un número : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numero);}

    \ControlFlowTok{if}\NormalTok{ (!isParell(numero)) \{}
\NormalTok{        printf(}\StringTok{"El número \%d és senar.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        printf(}\StringTok{"El número \%d és parell.}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, numero);}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{/* Implementació de la funció */}
\DataTypeTok{bool}\NormalTok{ isParell(}\DataTypeTok{int}\NormalTok{ numero) \{}
    \ControlFlowTok{if}\NormalTok{ (numero \% }\DecValTok{2}\NormalTok{ == }\DecValTok{0}\NormalTok{) \{}
        \ControlFlowTok{return}\NormalTok{ true;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{return}\NormalTok{ false;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-pivotdefensiutirslliures}{%
\section{Exemple: pivotDefensiuTirsLliures}\label{exemple-pivotdefensiutirslliures}}

S'afegeix a l'exemple de les jugadores de bàsquet un nou factor de comparació: en cas d'empat de les comparacions anteriors, escollirem la que tingui un millor percentatge de tirs lliures.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Rebem una petició d\textquotesingle{}un equip femení de bàsquet,}
\CommentTok{ * en el qual ens demanen un programa que els permeti}
\CommentTok{ * seleccionar la millor pivot defensiu d\textquotesingle{}entre una }
\CommentTok{ * sèrie de candidates.}
\CommentTok{ * La millor pivot defensiu és aquella que captura}
\CommentTok{ * més rebots; en cas d\textquotesingle{}empat, s\textquotesingle{}escollirà la que}
\CommentTok{ * faci més taps. En cas d\textquotesingle{}empat ens interessarà}
\CommentTok{ * escollir la que tingui millor percentatge}
\CommentTok{ * de tirs lliures.}
\CommentTok{ * Caldrà implementar 3 accions i 2 funcions:}
\CommentTok{ * {-} acció llegirJugadora(j): llegeix de teclat i}
\CommentTok{ *   guarda tots els atributs de la jugadora a la}
\CommentTok{ *   tupla j.}
\CommentTok{ * {-} acció mostrarJugadora(j): mostra per pantalla}
\CommentTok{ *   el valor dels atributs de la tupla j.}
\CommentTok{ * {-} acció copiarJugadores(j1, j2): copia el valor}
\CommentTok{ *   de tots els atributs de j2 cap a j1.}
\CommentTok{ * {-} funció compararJugadores(j1, j2): retorna {-}1 en }
\CommentTok{ *   cas que la millor pivot sigui j1, i 1 en cas }
\CommentTok{ *   que la millor sigui j2.}
\CommentTok{ * {-} funció percentatgeTirsLliures(intentats, encertats):}
\CommentTok{ *   retorna el percentatge d\textquotesingle{}encert en tirs lliures }
\CommentTok{ *   en funció dels valors passats per paràmetre.}
\CommentTok{ */}
 
\PreprocessorTok{\#define MAX\_NOM 20+1}
\PreprocessorTok{\#define MAX\_COGNOM 20+1}
\PreprocessorTok{\#define MAX\_JUGADORES 3}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_COGNOM];}
    \DataTypeTok{float}\NormalTok{ rebots;}
    \DataTypeTok{float}\NormalTok{ taps;}
    \DataTypeTok{float}\NormalTok{ tirsLliures; }\CommentTok{/* en percentatge */}
\NormalTok{\} tJugadora;}

\CommentTok{/* Predeclaracions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j);}
\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j);}
\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen);}
\DataTypeTok{int}\NormalTok{ compararJugadores(tJugadora j1, tJugadora j2);}
\DataTypeTok{float}\NormalTok{ percentatgeTirsLliures(}\DataTypeTok{int}\NormalTok{ intentats, }\DataTypeTok{int}\NormalTok{ encertats);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tJugadora vJugadores[MAX\_JUGADORES];}
    \DataTypeTok{int}\NormalTok{ i, resultat;}

    \CommentTok{/* Es crea la tJugadora fictícia }
\CommentTok{     * millorPivot que ens ajudarà a trobar }
\CommentTok{     * la millor opció d\textquotesingle{}entre totes les }
\CommentTok{     * candidates}
\CommentTok{     */}
\NormalTok{    tJugadora millorPivot;    }
\NormalTok{    millorPivot.rebots = }\DecValTok{0}\NormalTok{;}
\NormalTok{    millorPivot.taps = }\DecValTok{0}\NormalTok{;}
\NormalTok{    millorPivot.tirsLliures = }\FloatTok{0.0}\NormalTok{;}

    \CommentTok{/* Llegim totes les jugadores amb }
\CommentTok{     * l\textquotesingle{}acció llegirJugadora(). Aquesta}
\CommentTok{     * acció rep un paràmetre de sortida}
\CommentTok{     * (out), el qual contindrà la }
\CommentTok{     * jugadora llegit per teclat. Com que}
\CommentTok{     * es tracta d\textquotesingle{}un paràmetre de tipus }
\CommentTok{     * out, es realitzarà un pas per }
\CommentTok{     * referència (= passarem un punter)}
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_JUGADORES; i++) \{}
\NormalTok{        tJugadora jugadora;}
\NormalTok{        llegirJugadora(\&jugadora);}
\NormalTok{        vJugadores[i] = jugadora;}
\NormalTok{    \}}
    
    \CommentTok{/* Mostrem per pantalla quina}
\CommentTok{     * és la millor jugadora amb perfil}
\CommentTok{     * pivot defensiu. La idea és anar}
\CommentTok{     * recorrent una a una les jugadores}
\CommentTok{     * del vector i comparar{-}les amb millorPivot:}
\CommentTok{     * 1. Si la jugadora del vector és millor}
\CommentTok{     *    que millorPivot, copiarem les dades}
\CommentTok{     *    de la jugadora cap a millorPivot.}
\CommentTok{     * 2. Si millorPivot és millor que la}
\CommentTok{     *    jugadora del vector, no farem res.}
\CommentTok{     * En finalitzar el recorregut de totes}
\CommentTok{     * les jugadores del vector, tindrem que}
\CommentTok{     * millorPivot contindrà la jugadora}
\CommentTok{     * que estem buscant.}
\CommentTok{     * */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_JUGADORES; i++) \{}
\NormalTok{        resultat = compararJugadores(millorPivot, vJugadores[i]);}
        \ControlFlowTok{if}\NormalTok{ (resultat != {-}}\DecValTok{1}\NormalTok{) \{}
\NormalTok{            copiarJugadora(\&millorPivot, vJugadores[i]);}
\NormalTok{        \}}
\NormalTok{    \}}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Millor opció com a pivot defensiu : "}\NormalTok{);}
\NormalTok{    mostrarJugadora(millorPivot);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les accions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j) \{}
    \DataTypeTok{int}\NormalTok{ intentats;}
    \DataTypeTok{int}\NormalTok{ encertats;}
\NormalTok{    printf(}\StringTok{"Introdueix les dades de la nova jugadora: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}nom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Cognom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}cognom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{\textgreater{}\textgreater{} Promigs per partit:}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Rebots: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&j{-}\textgreater{}rebots);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Taps: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%f"}\NormalTok{, \&j{-}\textgreater{}taps);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Tirs lliures intentats: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&intentats);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Tirs lliures encertats: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&encertats);}
\NormalTok{    j{-}\textgreater{}tirsLliures = percentatgeTirsLliures(intentats, encertats);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j) \{}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\%s, \%s: \%.1f rebots, \%.1f taps, \%.1f\%\% tirs lliures }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, j.cognom, j.nom, j.rebots, j.taps, j.tirsLliures);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen) \{}
    \CommentTok{/* Recordem: }
\CommentTok{     * {-} si el paràmetre és un punter, l\textquotesingle{}accessor }
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}{-}\textgreater{}\textquotesingle{}}
\CommentTok{     * {-} si el paràmetre és un valor, l\textquotesingle{}accessor}
\CommentTok{     *   d\textquotesingle{}atributs serà \textquotesingle{}.\textquotesingle{}}
\CommentTok{     */}
\NormalTok{    strcpy(desti{-}\textgreater{}nom, origen.nom);}
\NormalTok{    strcpy(desti{-}\textgreater{}cognom, origen.cognom);}
\NormalTok{    desti{-}\textgreater{}rebots = origen.rebots;}
\NormalTok{    desti{-}\textgreater{}taps = origen.taps;}
\NormalTok{    desti{-}\textgreater{}tirsLliures = origen.tirsLliures;}
\NormalTok{\}}

\DataTypeTok{int}\NormalTok{ compararJugadores(tJugadora j1, tJugadora j2) \{}
    
    \CommentTok{/* Estem buscant una jugadora que }
\CommentTok{     * tingui un perfil de pivot defensiu, }
\CommentTok{     * amb el que agafarem:}
\CommentTok{     * 1. Aquella que tingui més rebots per partit}
\CommentTok{     * 2. En cas d\textquotesingle{}empat de rebots, aquella que}
\CommentTok{     *    faci més taps per partit}
\CommentTok{     * 3. En cas d\textquotesingle{}empat, la que tingui millor}
\CommentTok{     *    percentatge de tirs lliures}
\CommentTok{     */} 
    \ControlFlowTok{if}\NormalTok{ (j1.rebots \textgreater{} j2.rebots) \{}
        \ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{if}\NormalTok{ (j1.rebots \textless{} j2.rebots) \{}
            \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
            \CommentTok{/* En aquest punt tenim que }
\CommentTok{             * j1.rebots == j2.rebots,}
\CommentTok{             * amb el que anem a comparar el següent}
\CommentTok{             * atribut segons la prioritat definida}
\CommentTok{             * del perfil pivot defensiu}
\CommentTok{             */}
            \ControlFlowTok{if}\NormalTok{ (j1.taps \textgreater{} j2.taps) \{}
                \ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{            \} }\ControlFlowTok{else}\NormalTok{ \{}
                \ControlFlowTok{if}\NormalTok{ (j1.taps \textless{} j2.taps) \{}
                    \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{                \} }\ControlFlowTok{else}\NormalTok{ \{}
                    \CommentTok{/* Afegim la variant de valorar}
\CommentTok{                     * el percentatge de tirs lliures}
\CommentTok{                     */}
                    \ControlFlowTok{if}\NormalTok{ (j1.tirsLliures \textgreater{}= j2.tirsLliures) \{}
                        \ControlFlowTok{return}\NormalTok{ {-}}\DecValTok{1}\NormalTok{;}
\NormalTok{                    \} }\ControlFlowTok{else}\NormalTok{ \{}
                        \ControlFlowTok{return} \DecValTok{1}\NormalTok{;}
\NormalTok{                    \}}
\NormalTok{                \}}
\NormalTok{            \}}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{float}\NormalTok{ percentatgeTirsLliures(}\DataTypeTok{int}\NormalTok{ intentats, }\DataTypeTok{int}\NormalTok{ encertats) \{}
    \ControlFlowTok{return}\NormalTok{ ((}\DataTypeTok{float}\NormalTok{)encertats/intentats)*}\FloatTok{100.0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac08}{%
\chapter{PAC08}\label{pac08}}

\hypertarget{com-inicialitzar-una-taula}{%
\section{Com inicialitzar una taula}\label{com-inicialitzar-una-taula}}

Per inicialitzar/esborrar una taula únicament ens cal indicar que el nombre d'elements que conté és 0.
La pregunta que ens podem fer és \emph{``simplement inicialitzant a 0 aquest atribut és suficient?''}. La resposta és afirmativa: l'atribut que conté el nombre d'elements d'una taula sempre és l'utilitzat a l'hora de recórrer una taula, ja que ens indica quin és l'últim element de la taula. De la mateixa manera, quan inserim un element incrementarem en 1 el seu valor.

Què passa quan li donem valor 0? Estem indicant que la taula té 0 elements, amb el que quan n'hi afegim un de nou ho farem a la primera posició, sobreescrivint tot el que prèviament hi pogués haver en memòria.

\hypertarget{exemple-calcularnota}{%
\section{Exemple: calcularNota}\label{exemple-calcularnota}}

S'ha d'entendre una taula com un conjunt d'elements dels quals sabem en tot moment quants en tenim.

Imaginem que volem fer un programa que calculi la nota mitjana de les PAC d'una assignatura. Podríem plantejar-ho com a un simple array d'enters, però com que ens agrada poder donar més funcionalitats en un futur al nostre programa, tindrem el següent escenari:

\begin{itemize}
\tightlist
\item
  \texttt{tPac}: serà el tipus de dades bàsic que tractarà el nostre programa. Aquesta tupla estarà formada d'una banda per un nom descriptiu de la pac, i d'altra banda per la seva nota numèrica amb decimals.
\item
  \texttt{tAssignatura}: taula que contindrà elements de tipus tPac. A part d'aques array de tPac, també tindrà un comptador intern d'elements: numPacs.
\end{itemize}

Sobre aquesta base realitzarem dues accions:

\begin{itemize}
\tightlist
\item
  \texttt{afegir\_pac()}: es tracta d'una acció que inclou un element de tipus \texttt{tPac} dins de la taula \texttt{tAssignatura}. És una operació similar a l'acció d'omplir una taula dels exemples de la xWiki.
\item
  \texttt{calcular\_nota()}: és una funció que revisa tots els elements \texttt{tPac} de la taula \texttt{tAssignatura} i en calcula la seva nota mitjana. Es tracta d'una operació equivalent a la dels recorreguts de taula dels exemples de la xWiki, ja que estem recorrent un a un tots els elements \texttt{tPac} per obtenir la seva nota.
\end{itemize}

Una possible forma d'implementar-ho seria la següent:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Definició de constants */}
\PreprocessorTok{\#define MAX\_PACS 5}
\PreprocessorTok{\#define MAX\_NOM 5+1}

\CommentTok{/* Definició de la tupla tPac */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{float}\NormalTok{ nota;}
\NormalTok{\} tPac;}

\CommentTok{/* Definició de taula tAssignatura */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tPac pac[MAX\_PACS];}
    \DataTypeTok{int}\NormalTok{ numPacs;}
\NormalTok{\} tAssignatura;}

\CommentTok{/* Definició funcions/accions */}

\CommentTok{/* Acció que afegeix un element de tipus tPac a la taula tAssignatura */}
\DataTypeTok{void}\NormalTok{ afegir\_pac(tAssignatura *assignatura, tPac pac);}

\CommentTok{/* Funció que calcula la mitjana de totes les tPac que conté la taula}
\CommentTok{ * tAssignatura }
\CommentTok{ */}
\DataTypeTok{float}\NormalTok{ calcular\_nota(tAssignatura assignatura);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}

    \CommentTok{/* Definim les variables */}
\NormalTok{    tAssignatura fp;}
\NormalTok{    tPac pac1, pac2, pac3;}
    \DataTypeTok{float}\NormalTok{ nota;}

    \CommentTok{/* Inicialitzem les variables */}
\NormalTok{    nota = }\DecValTok{0}\NormalTok{;}
\NormalTok{    strcpy(pac1.nom,}\StringTok{"PAC01"}\NormalTok{);}
\NormalTok{    pac1.nota = }\DecValTok{10}\NormalTok{;}
\NormalTok{    strcpy(pac2.nom,}\StringTok{"PAC02"}\NormalTok{);}
\NormalTok{    pac2.nota = }\FloatTok{8.5}\NormalTok{;}
\NormalTok{    strcpy(pac3.nom,}\StringTok{"PAC03"}\NormalTok{);}
\NormalTok{    pac3.nota = }\FloatTok{7.5}\NormalTok{;}

    \CommentTok{/* La inicialització de la taula es fa simplement}
\CommentTok{     * posant a 0 el seu comptador }
\CommentTok{     */}
\NormalTok{    fp.numPacs=}\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Afegim les pacs a l\textquotesingle{}assignatura, que és una taula}
\CommentTok{     * d\textquotesingle{}elements de tipus tPac }
\CommentTok{     */}
\NormalTok{    afegir\_pac(\&fp, pac1);}
\NormalTok{    afegir\_pac(\&fp, pac2);}
\NormalTok{    afegir\_pac(\&fp, pac3);}

    \CommentTok{/* i ara calculem la nota amb la funció calcular\_nota */}
\NormalTok{    nota = calcular\_nota(fp);}
\NormalTok{    printf(}\StringTok{"La nota mitjana de les \%d PAC és \%f}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, fp.numPacs, nota);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació funcions/accions */}

\DataTypeTok{void}\NormalTok{ afegir\_pac(tAssignatura *assignatura, tPac pac) \{}
    \CommentTok{/* numPacs conté el número d\textquotesingle{}elements de tipus tPac}
\CommentTok{     * que conté la taula en cada moment }
\CommentTok{     */}
\NormalTok{    assignatura{-}\textgreater{}pac[assignatura{-}\textgreater{}numPacs] = pac;}

    \CommentTok{/* Una vegada hem assignat un element nou tPac a la taula}
\CommentTok{     * incrementem el valor de numPacs }
\CommentTok{     */}
\NormalTok{    assignatura{-}\textgreater{}numPacs = assignatura{-}\textgreater{}numPacs + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{float}\NormalTok{ calcular\_nota(tAssignatura assignatura) \{}
    \CommentTok{/* La variable suma conté el sumatori de totes}
\CommentTok{     * les notes de les tPac que estan dins de la taula}
\CommentTok{     * tAssignatura }
\CommentTok{     */}
    \DataTypeTok{float}\NormalTok{ suma = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Es recorren tots els elements tPac de tAssignatura}
\CommentTok{     * per tal d\textquotesingle{}obtenir la seva nota i acumular{-}les a la}
\CommentTok{     * variable suma }
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} assignatura.numPacs; i++) \{}
\NormalTok{        suma = suma + assignatura.pac[i].nota;}
\NormalTok{    \}}

    \CommentTok{/* Per calcular la mitjana es divideix el sumatori de}
\CommentTok{     * notes pel total d\textquotesingle{}elements de la taula tAssignatura }
\CommentTok{     */}
    \ControlFlowTok{return}\NormalTok{ suma/assignatura.numPacs;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Per facilitar la lectura s'ha unit tot el programa en un únic bloc de codi (un únic arxiu).

\hypertarget{exemple-calcularnota-amb-introducciuxf3-iterativa}{%
\section{Exemple: calcularNota amb introducció iterativa}\label{exemple-calcularnota-amb-introducciuxf3-iterativa}}

He adaptat l'exemple anterior per tal que demani els valors iterativament:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Definició de constants */}
\PreprocessorTok{\#define MAX\_PACS 10}
\PreprocessorTok{\#define MAX\_NOM 10+1}

\CommentTok{/* Definició de la tupla tPac */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{float}\NormalTok{ nota;}
\NormalTok{\} tPac;}

\CommentTok{/* Definició de taula tAssignatura */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tPac pac[MAX\_PACS];}
    \DataTypeTok{int}\NormalTok{ numPacs;}
\NormalTok{\} tAssignatura;}

\CommentTok{/* Definició funcions/accions */}

\CommentTok{/* Acció que afegeix un element de tipus tPac a la taula tAssignatura */}
\DataTypeTok{void}\NormalTok{ afegir\_pac(tAssignatura *assignatura, tPac pac);}

\CommentTok{/* Funció que calcula la mitjana de totes les tPac que conté la taula}
\CommentTok{ * tAssignatura }
\CommentTok{ */}
\DataTypeTok{float}\NormalTok{ calcular\_nota(tAssignatura assignatura);}

\CommentTok{/* Programa principal */} 
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}

    \CommentTok{/* Definim les variables */}
\NormalTok{    tAssignatura fp;}
    \DataTypeTok{float}\NormalTok{ nota;}
    \DataTypeTok{int}\NormalTok{ numPacs, i;}

    \CommentTok{/* Inicialitzem les variables */}
\NormalTok{    nota = }\DecValTok{0}\NormalTok{;}
\NormalTok{    numPacs = }\DecValTok{0}\NormalTok{;}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Inicialitzem la taula */}
\NormalTok{    fp.numPacs=}\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Introduim ara les dades de les PAC des de teclat */}
\NormalTok{    printf(}\StringTok{"Número de PACs a introduir (\textless{}\%d): "}\NormalTok{, MAX\_PACS);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&numPacs);}

    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} numPacs; i++) \{}
\NormalTok{        tPac pacAux;}

\NormalTok{        printf(}\StringTok{"Dades de la PAC0\%d : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, i+}\DecValTok{1}\NormalTok{);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nom : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%s"}\NormalTok{, pacAux.nom);}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nota : "}\NormalTok{);}
\NormalTok{        scanf(}\StringTok{"\%f"}\NormalTok{, \&pacAux.nota);}

        \CommentTok{/* Afegim a la taula la tPac auxiliar utilitzada}
\CommentTok{         * dins del bucle. En cada iteració es construirà}
\CommentTok{         * i s\textquotesingle{}afegirà una tPac diferent }
\CommentTok{         */}
\NormalTok{        afegir\_pac(\&fp, pacAux);}
\NormalTok{    \}}
    \CommentTok{/* Calculem la nota amb la funció calcular\_nota */}
\NormalTok{    nota = calcular\_nota(fp);}
\NormalTok{    printf(}\StringTok{"La nota mitjana de les \%d PAC és \%f}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, fp.numPacs, nota);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació funcions/accions */}
\DataTypeTok{void}\NormalTok{ afegir\_pac(tAssignatura *assignatura, tPac pac) \{}

    \CommentTok{/* numPacs conté el número d\textquotesingle{}elements de tipus tPac}
\CommentTok{     * que conté la taula en cada moment }
\CommentTok{     */}
\NormalTok{    assignatura{-}\textgreater{}pac[assignatura{-}\textgreater{}numPacs] = pac;}

    \CommentTok{/* Una vegada hem assignat un element nou tPac a la taula}
\CommentTok{     * incrementem el valor de numPacs }
\CommentTok{     */}
\NormalTok{    assignatura{-}\textgreater{}numPacs = assignatura{-}\textgreater{}numPacs + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{float}\NormalTok{ calcular\_nota(tAssignatura assignatura) \{}
    \CommentTok{/* La variable suma conté el sumatori de totes}
\CommentTok{     * les notes de les tPac que estan dins de la taula}
\CommentTok{     * tAssignatura }
\CommentTok{     */}
    \DataTypeTok{float}\NormalTok{ suma = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Es recorren tots els elements tPac de tAssignatura}
\CommentTok{     * per tal d\textquotesingle{}obtenir la seva nota i acumular{-}les a la}
\CommentTok{     * variable suma }
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (}\DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{; i \textless{} assignatura.numPacs; i++) \{}
\NormalTok{        suma = suma + assignatura.pac[i].nota;}
\NormalTok{    \}}

    \CommentTok{/* Per calcular la mitjana es divideix el sumatori de}
\CommentTok{     * notes pel total d\textquotesingle{}elements de la taula tAssignatura }
\CommentTok{     */}
   \ControlFlowTok{return}\NormalTok{ suma/assignatura.numPacs;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{exemple-recorregut-vs-cerca}{%
\section{Exemple: recorregut vs cerca}\label{exemple-recorregut-vs-cerca}}

El següent exemple es tracten els conceptes de \textbf{recorregut} i de \textbf{cerca} dels elements d'una taula. Dins del codi s'han afegit comentaris detallats per tal que cada pas quedi explicat.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Ens demanen un programa que permeti registrar}
\CommentTok{ * jugadores de bàsquet dins d\textquotesingle{}una taula. En una}
\CommentTok{ * mateixa taula tindrem tant les jugadores locals}
\CommentTok{ * com les visitants. Sobre elles hi realitzarem}
\CommentTok{ * un recorregut, consistent en mostrar{-}les totes}
\CommentTok{ * per pantalla, i també una cerca, on a partir }
\CommentTok{ * de l\textquotesingle{}equip i el dorsal mostrarem per pantalla}
\CommentTok{ * la jugadora en cas d\textquotesingle{}existir.}
\CommentTok{ * Ens caldrà implementar les següents accions:}
\CommentTok{ * {-} inicialitzarTaula(...): per inicialitzar la}
\CommentTok{ *   taula de jugadores.}
\CommentTok{ * {-} afegirJugadora(...) : per afegir una}
\CommentTok{ *   jugadora a una taula.}
\CommentTok{ * {-} mostrarJugadores(...) : per mostrar per }
\CommentTok{ *   pantalla totes les jugadores de la taula.}
\CommentTok{ * {-} cercarJugadora(...) : per buscar dins de la}
\CommentTok{ *   taula la jugadora que tingui un equip i }
\CommentTok{ *   un dorsal determinat.}
\CommentTok{ */}
 
\PreprocessorTok{\#define MAX\_NOM 20+1}
\PreprocessorTok{\#define MAX\_COGNOM 20+1}
\PreprocessorTok{\#define MAX\_JUGADORES 10}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{LOCAL, VISITANT\} tEquip;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{char}\NormalTok{ cognom[MAX\_COGNOM];}
    \DataTypeTok{int}\NormalTok{ dorsal;}
\NormalTok{    tEquip equip;}
\NormalTok{\} tJugadora;}

\CommentTok{/* Definició del tipus taula de}
\CommentTok{ * jugadores; com es pot veure, tal i }
\CommentTok{ * com s\textquotesingle{}indica a les xWiki, únicament}
\CommentTok{ * està formada per un vector i un }
\CommentTok{ * comptador de les jugadores que conté.}
\CommentTok{ */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tJugadora jugadores[MAX\_JUGADORES];}
    \DataTypeTok{int}\NormalTok{ nJugadores;}
\NormalTok{\} tTaulaJugadores;}

\CommentTok{/* Predeclaracions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j);}
\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j);}
\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen);}
\DataTypeTok{void}\NormalTok{ inicialitzarTaula(tTaulaJugadores *taula);}
\DataTypeTok{void}\NormalTok{ afegirJugadora(tTaulaJugadores *taula, tJugadora j);}
\DataTypeTok{void}\NormalTok{ mostrarJugadores(tTaulaJugadores taula);}
\DataTypeTok{void}\NormalTok{ cercarJugadora(tTaulaJugadores taula, }\DataTypeTok{int}\NormalTok{ dorsal, tEquip equip);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tJugadora jugadora;}
\NormalTok{    tTaulaJugadores taula;}
\NormalTok{    tEquip equip;}
    \DataTypeTok{int}\NormalTok{ dorsal, i;}
    
    \CommentTok{/* Per inicialitzar una taula simplement}
\CommentTok{     * posem el comptador d\textquotesingle{}elements a 0. Com}
\CommentTok{     * que la inserció de jugadores a la taula}
\CommentTok{     * té present aquest comptador, sobreescriurà}
\CommentTok{     * qualsevol altre valor que existís en }
\CommentTok{     * aquesta mateixa posició.}
\CommentTok{     */}
\NormalTok{    inicialitzarTaula(\&taula);}
    
    \CommentTok{/* Demanem les jugadores per teclat i tot}
\CommentTok{     * seguit les anem afegint a la taula.}
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (i=}\DecValTok{0}\NormalTok{; i\textless{}MAX\_JUGADORES; i++) \{}
\NormalTok{        llegirJugadora(\&jugadora);}
\NormalTok{        afegirJugadora(\&taula, jugadora);}
\NormalTok{    \}}
    
    \CommentTok{/* Es recorren tots els elements}
\CommentTok{     * de la taula de jugadores per}
\CommentTok{     * tal d\textquotesingle{}imprimir les dades per }
\CommentTok{     * pantalla}
\CommentTok{     */}
\NormalTok{    mostrarJugadores(taula);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Quina jugadora vols cercar? : "}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Equip (0=LOCAL, 1=VISITANT) : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&equip);}
\NormalTok{    printf(}\StringTok{"\textgreater{}\textgreater{} Dorsal : "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&dorsal);}
    
    \CommentTok{/* Es fa una cerca entre totes les}
\CommentTok{     * jugadores de la taula, de forma que}
\CommentTok{     * mostrarà per pantalla el resultat}
\CommentTok{     * obtingut; si no se\textquotesingle{}n troba cap,}
\CommentTok{     * retorna un missatge informatiu.}
\CommentTok{     */}
\NormalTok{    cercarJugadora(taula, dorsal, equip);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les accions */}
\DataTypeTok{void}\NormalTok{ llegirJugadora(tJugadora *j) \{}
\NormalTok{    printf(}\StringTok{"Introdueix les dades de la nova jugadora: }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Nom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}nom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Cognom: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%s"}\NormalTok{, j{-}\textgreater{}cognom);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Equip (0=LOCAL, 1=VISITANT): "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%u"}\NormalTok{, \&j{-}\textgreater{}equip);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}t}\StringTok{Dorsal: "}\NormalTok{);}
\NormalTok{    scanf(}\StringTok{"\%d"}\NormalTok{, \&j{-}\textgreater{}dorsal);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mostrarJugadora(tJugadora j) \{}
    \ControlFlowTok{if}\NormalTok{ (j.equip == LOCAL) \{}
\NormalTok{        printf(}\StringTok{"LOCAL   : \%d \%s,\%s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, j.dorsal, j.cognom, j.nom);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        printf(}\StringTok{"VISITANT: \%d \%s,\%s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, j.dorsal, j.cognom, j.nom);}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ copiarJugadora(tJugadora *desti, tJugadora origen) \{}
\NormalTok{    strcpy(desti{-}\textgreater{}nom, origen.nom);}
\NormalTok{    strcpy(desti{-}\textgreater{}cognom, origen.cognom);}
\NormalTok{    desti{-}\textgreater{}dorsal = origen.dorsal;}
\NormalTok{    desti{-}\textgreater{}equip = origen.equip;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ inicialitzarTaula(tTaulaJugadores *taula) \{    }
\NormalTok{    taula{-}\textgreater{}nJugadores= }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ afegirJugadora(tTaulaJugadores *taula, tJugadora j) \{}
    
    \CommentTok{/* Es comprova primer que la taula no estigui plena! */}
    \ControlFlowTok{if}\NormalTok{(taula{-}\textgreater{}nJugadores \textgreater{}= MAX\_JUGADORES) \{}
\NormalTok{        printf(}\StringTok{"Error en afegir jugadora a la taula}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
        
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \CommentTok{/* S\textquotesingle{}afegeix la jugadora a la taula, i s\textquotesingle{}incrementa}
\CommentTok{           el comptador d\textquotesingle{}elements de la taula */}
\NormalTok{        copiarJugadora(\&taula{-}\textgreater{}jugadores[taula{-}\textgreater{}nJugadores], j);}
        
        \CommentTok{/* Important!! després d\textquotesingle{}afegir una jugadora, no hem}
\CommentTok{         * d\textquotesingle{}oblidar incrementar el comptador! */}
\NormalTok{        taula{-}\textgreater{}nJugadores++;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mostrarJugadores(tTaulaJugadores taula) \{}
    \DataTypeTok{int}\NormalTok{ i;}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Recorregut: jugadores entrades a la taula ...}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{while}\NormalTok{ (i \textless{} taula.nJugadores) \{}
\NormalTok{        mostrarJugadora(taula.jugadores[i]);}
\NormalTok{        i = i+}\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ cercarJugadora(tTaulaJugadores taula, }\DataTypeTok{int}\NormalTok{ dorsal, tEquip equip) \{}
    \DataTypeTok{int}\NormalTok{ i;}
    \DataTypeTok{bool}\NormalTok{ trobada;}
    
    \CommentTok{/* El booleà \textquotesingle{}trobada\textquotesingle{} s\textquotesingle{}utilitzarà}
\CommentTok{     * per sortir del bucle que recorre totes}
\CommentTok{     * les jugadores de la taula: quan en trobi}
\CommentTok{     * una, trobada = true, i la condició d\textquotesingle{}entrada}
\CommentTok{     * del bucle ja no es complirà, amb el que}
\CommentTok{     * la cerca haurà finalitzat.}
\CommentTok{     */}
\NormalTok{    trobada = false;}
    
    \ControlFlowTok{if}\NormalTok{ (equip == LOCAL) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Cerca: jugadora local amb dorsal núm. \%d ..."}\NormalTok{, dorsal);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Cerca: jugadora visitant amb dorsal núm. \%d ..."}\NormalTok{, dorsal);}
\NormalTok{    \}}
    
    \ControlFlowTok{for}\NormalTok{(i=}\DecValTok{0}\NormalTok{; i\textless{}taula.nJugadores \&\& !trobada; i++) \{}
        \ControlFlowTok{if}\NormalTok{ (taula.jugadores[i].dorsal == dorsal \&\&}
\NormalTok{            taula.jugadores[i].equip == equip) \{}
\NormalTok{                trobada = true;}
\NormalTok{        \}}
\NormalTok{    \}}
    
    \CommentTok{/* Es mostra per pantalla els resultats}
\CommentTok{     * obtinguts }
\CommentTok{     */}
    \ControlFlowTok{if}\NormalTok{ (!trobada) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} No s\textquotesingle{}ha trobat cap jugadora. }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Jugadora trobada : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{        mostrarJugadora(taula.jugadores[i{-}}\DecValTok{1}\NormalTok{]);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac09}{%
\chapter{PAC09}\label{pac09}}

\hypertarget{exemple-llistacartes}{%
\section{Exemple: llistaCartes}\label{exemple-llistacartes}}

El plantejament és el següent: imaginem que tenim una llista de cartes de tipus \texttt{DIAMANTS}, \texttt{CORS}, \texttt{TREVOLS} i \texttt{PIQUES}; el que volem aconseguir és filtrar aquesta llista per un tipus determinat de carta, \texttt{DIAMANTS}, i afegir totes aquestes cartes de \texttt{DIAMANTS} a una altra llista.

Una possible implementació seria:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Definició del model de cartes segons l\textquotesingle{}enllaç:}
\CommentTok{ *  https://ca.wikipedia.org/wiki/Joc\_de\_cartes\#Joc\_de\_cartes\_francès }
\CommentTok{ */}

\PreprocessorTok{\#define MAX\_CARTES 54+1}
\PreprocessorTok{\#define MAX\_DIAMANTS\_CARTES 13+1}

\CommentTok{/* El terme "coll" equival a "baraja" */}
\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{DIAMANTS, PIQUES, TREVOLS, CORS\} tColl;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ valor;}
\NormalTok{    tColl coll;}
\NormalTok{\} tCarta;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tCarta cartes[MAX\_CARTES];}
    \DataTypeTok{int}\NormalTok{ nCartes;}
\NormalTok{\} tCartesList;}

\CommentTok{/* Predeclaració de les accions i les funcions */}
\DataTypeTok{void}\NormalTok{ createList();}
\DataTypeTok{void}\NormalTok{ insert(tCartesList *llista, tCarta carta, }\DataTypeTok{int}\NormalTok{ index);}
\DataTypeTok{void}\NormalTok{ delete(tCartesList *llista, }\DataTypeTok{int}\NormalTok{ index);}
\NormalTok{tCarta get(tCartesList llista, }\DataTypeTok{int}\NormalTok{ index);}
\DataTypeTok{bool}\NormalTok{ end(tCartesList llista, }\DataTypeTok{int}\NormalTok{ pos);}
\DataTypeTok{bool}\NormalTok{ emptyList(tCartesList llista);}
\DataTypeTok{bool}\NormalTok{ fullList(tCartesList llista);}
\DataTypeTok{void}\NormalTok{ printList(tCartesList llista);}
\DataTypeTok{void}\NormalTok{ getCartesByColl(tCartesList llista, tColl coll, tCartesList *llistaByColl);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}

\NormalTok{    tCarta carta1, carta2, carta3, carta4, carta5;}
\NormalTok{    tCartesList llistaCartes, llistaCartesDiamants;}

    \CommentTok{/* Creem les dues llistes */}
\NormalTok{    createList(\&llistaCartes);}
\NormalTok{    createList(\&llistaCartesDiamants);}

    \CommentTok{/* Definim una sèrie de cartes */}
\NormalTok{    carta1.valor = }\CharTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta1.coll = CORS;}
\NormalTok{    carta2.valor = }\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta2.coll = DIAMANTS;}
\NormalTok{    carta3.valor = }\CharTok{\textquotesingle{}J\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta3.coll = TREVOLS;}
\NormalTok{    carta4.valor = }\CharTok{\textquotesingle{}5\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta4.coll = DIAMANTS;}
\NormalTok{    carta5.valor = }\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta5.coll = PIQUES;}

    \CommentTok{/* I les afegim a la llista genèrica de cartes */}
\NormalTok{    insert(\&llistaCartes, carta1, }\DecValTok{0}\NormalTok{);}
\NormalTok{    insert(\&llistaCartes, carta2, }\DecValTok{1}\NormalTok{);}
\NormalTok{    insert(\&llistaCartes, carta3, }\DecValTok{2}\NormalTok{);}
\NormalTok{    insert(\&llistaCartes, carta4, }\DecValTok{3}\NormalTok{);}
\NormalTok{    insert(\&llistaCartes, carta5, }\DecValTok{4}\NormalTok{);}

    \CommentTok{/* Mostrem el contingut de la llista de cartes}
\CommentTok{     * per pantalla, amb l\textquotesingle{}acció printList }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Contingut de la llista \textquotesingle{}llistaCartes\textquotesingle{} :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printList(llistaCartes);}

    \CommentTok{/* Ara volem filtrar la llista genèrica de cartes amb}
\CommentTok{     * un dels colls possibles. Concretament volem separar }
\CommentTok{     * de la llista genèrica de cartes aquelles que siguin }
\CommentTok{     * del coll DIAMANTS; ho fem mitjançant la crida a }
\CommentTok{     * l\textquotesingle{}acció getCartesByColl. Per veure el seu funcionament,}
\CommentTok{     * reviseu el comentari fet en la implementació d\textquotesingle{}aquesta}
\CommentTok{     * acció }
\CommentTok{     */}
\NormalTok{    getCartesByColl(llistaCartes, DIAMANTS, \&llistaCartesDiamants);}

    \CommentTok{/* I mostrem ara el contingut de la llista que conté}
\CommentTok{     * únicament les cartes del coll DIAMANTS }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"Contingut de la llista \textquotesingle{}llistaCartesDiamants\textquotesingle{} :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printList(llistaCartesDiamants);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació dels mètodes de la llista: he fet un copy/paste}
\CommentTok{ * de la codificació C de l\textquotesingle{}exemple 19\_12 de la xWiki, canviant}
\CommentTok{ * el genèric "elem" per "tCarta", i el genèric "list" per "tCartesList",}
\CommentTok{ * ja que aquests seran els elements amb els que treballarem}
\CommentTok{ * en aquest exemple }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ createList(tCartesList *llista) \{}
\NormalTok{    llista{-}\textgreater{}nCartes = }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ insert(tCartesList *llista, tCarta carta, }\DataTypeTok{int}\NormalTok{ index) \{}

    \DataTypeTok{int}\NormalTok{ i = }\DecValTok{0}\NormalTok{;}
    \ControlFlowTok{if}\NormalTok{ (llista{-}\textgreater{}nCartes == MAX\_CARTES) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Full list }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{for}\NormalTok{ (i=llista{-}\textgreater{}nCartes{-}}\DecValTok{1}\NormalTok{; i\textgreater{}=index; i{-}{-}) \{}
\NormalTok{            llista{-}\textgreater{}cartes[i+}\DecValTok{1}\NormalTok{] = llista{-}\textgreater{}cartes[i];}
\NormalTok{        \}}
\NormalTok{        llista{-}\textgreater{}nCartes++;}
\NormalTok{        llista{-}\textgreater{}cartes[index]=carta;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ delete(tCartesList *llista, }\DataTypeTok{int}\NormalTok{ index) \{}

    \DataTypeTok{int}\NormalTok{ i;}
    \ControlFlowTok{if}\NormalTok{ (llista{-}\textgreater{}nCartes == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Empty list}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{for}\NormalTok{ (i=index; i\textless{}llista{-}\textgreater{}nCartes{-}}\DecValTok{1}\NormalTok{; i++) \{}
\NormalTok{            llista{-}\textgreater{}cartes[i] = llista{-}\textgreater{}cartes[i+}\DecValTok{1}\NormalTok{];}
\NormalTok{        \}}
\NormalTok{        llista{-}\textgreater{}nCartes{-}{-};}
\NormalTok{    \}}
\NormalTok{\}}

\NormalTok{tCarta get(tCartesList llista, }\DataTypeTok{int}\NormalTok{ index) \{}

\NormalTok{    tCarta carta;}

    \ControlFlowTok{if}\NormalTok{ (llista.nCartes == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Empty list }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        carta=llista.cartes[index];}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ carta;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ end(tCartesList llista, }\DataTypeTok{int}\NormalTok{ pos) \{}
    \ControlFlowTok{return}\NormalTok{ (pos \textgreater{}= llista.nCartes);}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ emptyList(tCartesList llista) \{}
    \ControlFlowTok{return}\NormalTok{ (llista.nCartes == }\DecValTok{0}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ fullList(tCartesList llista) \{}
    \ControlFlowTok{return}\NormalTok{ (llista.nCartes == MAX\_CARTES);}
\NormalTok{\}}

\CommentTok{/* A continuació s\textquotesingle{}implementaran dues noves accions que}
\CommentTok{ * no surten ja a l\textquotesingle{}exemple 19\_12. La primera acció, }
\CommentTok{ * printList, imprimeix per pantalla una llista. La segona}
\CommentTok{ * acció, getCartesByColl, permet fer un filtratge de }
\CommentTok{ * cartes sobre una llista. }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ printList(tCartesList llista) \{}

    \DataTypeTok{int}\NormalTok{ i;}
\NormalTok{    tCarta cartaAux;}

    \ControlFlowTok{for}\NormalTok{(i = }\DecValTok{0}\NormalTok{; i \textless{} llista.nCartes; i++) \{ }
\NormalTok{        cartaAux = get(llista, i);}
        \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == DIAMANTS) \{}
\NormalTok{            printf(}\StringTok{" [\%c] de DIAMANTS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == PIQUES) \{}
\NormalTok{            printf(}\StringTok{" [\%c] de PIQUES}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == TREVOLS) \{}
\NormalTok{            printf(}\StringTok{" [\%c] de TREVOLS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == CORS) \{}
\NormalTok{            printf(}\StringTok{" [\%c] de CORS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \}}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{/* La següent acció, getCartesByColl, rep tres paràmetres:}
\CommentTok{ * {-} tCartesList llista (in): llista sobre la qual aplicarem el filtre}
\CommentTok{ * {-} tColl tipus (in): correspon al tipus de coll que utilitzarem per }
\CommentTok{ *   fer el filtratge; per exemple, si com a coll indiquem }
\CommentTok{ *   DIAMANTS significa que el filtratge el farem}
\CommentTok{ *   sobre les cartes de tipus DIAMANTS}
\CommentTok{ * {-} tCartesList llistaByColl (out): llista de sortida en la qual }
\CommentTok{ *   s\textquotesingle{}hi inclouran aquelles cartes de la llista d\textquotesingle{}entrada que }
\CommentTok{ *   són del coll tipus}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ getCartesByColl(tCartesList llista, tColl tipus, tCartesList *llistaByColl) \{}

    \DataTypeTok{int}\NormalTok{ i, j;}
\NormalTok{    tCarta carta;}

\NormalTok{    createList(llistaByColl);}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}
\NormalTok{    j = }\DecValTok{0}\NormalTok{;}

    \CommentTok{/* Amb un bucle i la funció end(), controlem que no }
\CommentTok{     * hem arribat al final de la llista }
\CommentTok{     */}
   \ControlFlowTok{while}\NormalTok{ (end(llista, i) == false) \{}

        \CommentTok{/* Obtenim la carta de la posició i */}
\NormalTok{        carta = get(llista, i);}

        \CommentTok{/* Si la carta és del coll indicat per tipus, }
\CommentTok{         * s\textquotesingle{}afegeix a la llista de sortida }
\CommentTok{         */}
        \ControlFlowTok{if}\NormalTok{ (carta.coll == tipus) \{}
\NormalTok{            insert(llistaByColl, carta, j);}
\NormalTok{            j = j + }\DecValTok{1}\NormalTok{;}
\NormalTok{        \}}
\NormalTok{        i = i + }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{pac10}{%
\chapter{PAC10}\label{pac10}}

\hypertarget{pr1}{%
\chapter{PR1}\label{pr1}}

\hypertarget{mode-menu-vs-mode-test}{%
\section{Mode menu vs mode test}\label{mode-menu-vs-mode-test}}

El workspace de la PR1 té habilitats dos modes de funcionament/execució. Per activar un mode o un altre fem el següent, amb el workspace de la PR1 obert: \textbf{CodeLite} --\textgreater{} \textbf{Build} --\textgreater{} \textbf{Configuration manager\ldots{}}

Aquí es mostra un desplegable amb dues opcions:

\begin{itemize}
\tightlist
\item
  \textbf{Menu}: és el mode estàndard de funcionament del programa, el qual mostra el menú per pantalla amb les accions que permet realitzar.
\item
  \textbf{Test}: s'executen una sèrie de tests per validar que les accions que hem codificat al nostre programa funcionin com s'espera que ho facin.
\end{itemize}

Tant si s'escull l'opció \textbf{Menu} com l'opció \textbf{Test}, després hem de fer l'habitual \textbf{CodeLite} --\textgreater{} \textbf{Build} --\textgreater{} \textbf{Build and Run Project} per executar el programa en el mode que hem escollit.

\hypertarget{exemple-tupla-dins-de-tupla}{%
\section{Exemple: tupla dins de tupla}\label{exemple-tupla-dins-de-tupla}}

De vegades pot costar veure com treballar amb atributs d'una tupla que a la seva vegada està dins d'una altra tupla, si s'hi accedeix per valor, per referència (punter), etc. Per aquest motiu, s'adjunta el següent exemple inventat, en el qual s'hi han afegit comentaris per tal que es vegi clarament com treballar amb atributs d'una tupla continguda dins d'una altra tupla:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}

\CommentTok{/* Un parking d\textquotesingle{}un centre comercial ens ha }
\CommentTok{ * encarregat una app que faciliti els seus}
\CommentTok{ * clients a localitzar on ha aparcat el seu}
\CommentTok{ * vehicle.}
\CommentTok{ * }
\CommentTok{ * El parking ja disposa de tres tipus de }
\CommentTok{ * càmeres, independents entre elles:}
\CommentTok{ * }
\CommentTok{ * {-} d\textquotesingle{}entrada: càmera posicionada a l\textquotesingle{}entrada}
\CommentTok{ *   del pàrking que, a més de llegir la matrícula,}
\CommentTok{ *   permet saber el tipus de vehicle.}
\CommentTok{ * }
\CommentTok{ * {-} d\textquotesingle{}accés: càmeres que ens permeten}
\CommentTok{ *   saber si un vehicle ha pujat o ha baixat}
\CommentTok{ *   una planta.}
\CommentTok{ * }
\CommentTok{ * {-} de planta: càmeres que ens permeten saber}
\CommentTok{ *   la fila i eĺ número de plaça on s\textquotesingle{}ha }
\CommentTok{ *   aparcat un vehicle.}
\CommentTok{ * }
\CommentTok{ * L\textquotesingle{}identificador de vehicle és la seva }
\CommentTok{ * matrícula.}
\CommentTok{ * }
\CommentTok{ * A partir de la informació obtinguda pels}
\CommentTok{ * tres conjunts de càmeres, caldrà indicar}
\CommentTok{ * a l\textquotesingle{}usuari on ha aparcat el seu vehicle.}
\CommentTok{ */}

\PreprocessorTok{\#define MAX\_MATRICULA 7+1}

\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{COTXE, MOTO, FURGONETA\} tTipus;}

\CommentTok{/* El lloc on aparca un vehicle ve donat}
\CommentTok{ * per tres valors: la planta, la fila i el }
\CommentTok{ * número de la plaça.}
\CommentTok{ */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{int}\NormalTok{ planta;}
    \DataTypeTok{char}\NormalTok{ fila;}
    \DataTypeTok{int}\NormalTok{ numero;}
\NormalTok{\} tAparcament;}

\CommentTok{/* El tipus tVehicle conté la seva matrícula}
\CommentTok{ * (identificador únic), el tipus de vehicle}
\CommentTok{ * detectat en la primera càmera (COTXE, MOTO,}
\CommentTok{ * FURGONETA), i el lloc on ha aparcat (tAparcament)}
\CommentTok{ */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ matricula[MAX\_MATRICULA];}
\NormalTok{    tTipus tipus;}
\NormalTok{    tAparcament aparcament;}
\NormalTok{\} tVehicle;}

\CommentTok{/* Predeclaració d\textquotesingle{}accions */}
\DataTypeTok{void}\NormalTok{ inicialitzar(tVehicle *vehicle, tTipus tipus, }\DataTypeTok{char}\NormalTok{ *matricula);}
\DataTypeTok{void}\NormalTok{ pujarPlanta(tVehicle *vehicle);}
\DataTypeTok{void}\NormalTok{ baixarPlanta(tVehicle *vehicle);}
\DataTypeTok{void}\NormalTok{ aparcar(tVehicle *vehicle, }\DataTypeTok{char}\NormalTok{ fila, }\DataTypeTok{int}\NormalTok{ numero);}
\DataTypeTok{void}\NormalTok{ obtenirPosicio(tVehicle);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv)\{}
    
\NormalTok{    tVehicle vehicle;}
    
    \CommentTok{/* Es llegeix la matrícula del vehicle amb la }
\CommentTok{     * càmera d\textquotesingle{}entrada del pàrking i s\textquotesingle{}assigna}
\CommentTok{     * a l\textquotesingle{}element de tipus tVehicle del nostre}
\CommentTok{     * pàrking }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Entrada al pàrking }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    inicialitzar(\&vehicle, COTXE, }\StringTok{"7472GZZ"}\NormalTok{);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Baixar una planta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    baixarPlanta(\&vehicle);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Baixar una planta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    baixarPlanta(\&vehicle);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Pujar una planta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    pujarPlanta(\&vehicle);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Baixar una planta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    baixarPlanta(\&vehicle);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Baixar una planta}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    baixarPlanta(\&vehicle);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{\textgreater{}\textgreater{} Aparcar}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    aparcar(\&vehicle, }\CharTok{\textquotesingle{}C\textquotesingle{}}\NormalTok{, }\DecValTok{23}\NormalTok{);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Anem a comprar ..."}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{... passen més de 3 hores ..."}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{... i ens oblidem d\textquotesingle{}on hem aparcat el vehicle !!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Solució: consultem la posició del nostre vehicle"}\NormalTok{);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{a l\textquotesingle{}app del pàrquing : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    obtenirPosicio(vehicle);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Com que la posició ve donada pels atributs planta, fila i}
\CommentTok{ * numero de tAparcament, és molt important que inicialitzem}
\CommentTok{ * els valors (sobretot per la planta). La planta inicial del}
\CommentTok{ * pàrking és la 0, i la resta de plantes són soterrades.}
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ inicialitzar(tVehicle *vehicle, tTipus tipus, }\DataTypeTok{char}\NormalTok{ *matricula) \{}
\NormalTok{    strcpy(vehicle{-}\textgreater{}matricula, matricula);}
\NormalTok{    vehicle{-}\textgreater{}tipus = tipus;}
    \CommentTok{/* L\textquotesingle{}accés a l\textquotesingle{}atribut aparcament (tupla) el fem amb \textquotesingle{}{-}\textgreater{}\textquotesingle{}}
\CommentTok{     * ja que es tracta d\textquotesingle{}un punter, i accedim}
\CommentTok{     * als atributs de la tupla aparcament amb \textquotesingle{}.\textquotesingle{}}
\CommentTok{     */}
\NormalTok{    vehicle{-}\textgreater{}aparcament.planta = }\DecValTok{0}\NormalTok{;}
\NormalTok{    vehicle{-}\textgreater{}aparcament.fila = }\CharTok{\textquotesingle{}{-}\textquotesingle{}}\NormalTok{;}
\NormalTok{    vehicle{-}\textgreater{}aparcament.numero = }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Quan pugem una planta, incrementem en 1 l\textquotesingle{}atribut}
\CommentTok{ * planta de la tupla tAparcament que conté la tupla tVehicle }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ pujarPlanta(tVehicle *vehicle) \{}
\NormalTok{    vehicle{-}\textgreater{}aparcament.planta = vehicle{-}\textgreater{}aparcament.planta + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Quan baixem una planta, decrementem en 1 l\textquotesingle{}atribut}
\CommentTok{ * planta de la tupla tAparcament que conté la tupla tVehicle }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ baixarPlanta(tVehicle *vehicle) \{}
\NormalTok{    vehicle{-}\textgreater{}aparcament.planta = vehicle{-}\textgreater{}aparcament.planta {-} }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Quan aparquem el vehicle, donem valor als atributs}
\CommentTok{ * fila i numero de la tupla tAparcament que conté la }
\CommentTok{ * tupla tVehicle }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ aparcar(tVehicle *vehicle, }\DataTypeTok{char}\NormalTok{ fila, }\DataTypeTok{int}\NormalTok{ numero) \{}
\NormalTok{    vehicle{-}\textgreater{}aparcament.fila = fila;}
\NormalTok{    vehicle{-}\textgreater{}aparcament.numero = numero;}
\NormalTok{\}}

\CommentTok{/* Mostrem per pantalla la posició del tVehicle */} 
\DataTypeTok{void}\NormalTok{ obtenirPosicio(tVehicle vehicle) \{}
    \ControlFlowTok{if}\NormalTok{ (vehicle.tipus == COTXE) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Cotxe \%s : "}\NormalTok{, vehicle.matricula);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
        \ControlFlowTok{if}\NormalTok{ (vehicle.tipus == MOTO) \{}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Moto \%s : "}\NormalTok{, vehicle.matricula);}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Furgoneta \%s : "}\NormalTok{, vehicle.matricula);}
\NormalTok{        \}}
\NormalTok{    \}}
    
    \CommentTok{/* En aquest cas l\textquotesingle{}accés a l\textquotesingle{}atribut aparcament (tupla)}
\CommentTok{     * es fa amb \textquotesingle{}.\textquotesingle{} ja que s\textquotesingle{}ha passat per valor (no és un punter)}
\CommentTok{     * i accedim als atributs de la tupla aparcament amb \textquotesingle{}.\textquotesingle{} }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"planta \%d, "}\NormalTok{, vehicle.aparcament.planta);}
\NormalTok{    printf(}\StringTok{"fila \%c, "}\NormalTok{, vehicle.aparcament.fila);}
\NormalTok{    printf(}\StringTok{"número \%d }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, vehicle.aparcament.numero);}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

El resultat de l'execució d'aquest programa és:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{\textgreater{}\textgreater{} Entrada al pàrking }

\NormalTok{\textgreater{}\textgreater{} Baixar una planta}

\NormalTok{\textgreater{}\textgreater{} Baixar una planta}

\NormalTok{\textgreater{}\textgreater{} Pujar una planta}

\NormalTok{\textgreater{}\textgreater{} Baixar una planta}

\NormalTok{\textgreater{}\textgreater{} Baixar una planta}

\NormalTok{\textgreater{}\textgreater{} Aparcar}

\NormalTok{Anem a comprar regals de reis ...}
\NormalTok{... passem més de }\DecValTok{3}\NormalTok{ hores ...}
\NormalTok{... i ens oblidem d\textquotesingle{}on hem aparcat el vehicle !!}

\NormalTok{Solució: consultem la posició del nostre vehicle }
\NormalTok{a l\textquotesingle{}app del parking : }

\NormalTok{Cotxe }\DecValTok{7472}\ErrorTok{GZZ}\NormalTok{ : planta {-}}\DecValTok{3}\NormalTok{, fila C, número }\DecValTok{23}
\end{Highlighting}
\end{Shaded}

\hypertarget{desplauxe7ament-delements-en-un-vector}{%
\section{Desplaçament d'elements en un vector}\label{desplauxe7ament-delements-en-un-vector}}

Els desplaçaments en un vector es poden produir quan s'afegeix o s'elimina un element d'un vector.

\hypertarget{afegir-un-element}{%
\subsection{Afegir un element}\label{afegir-un-element}}

Volem afegir un element dins del vector de la taula en una posició que no és l'última. Per exemple, si volem que els elements que afegim a un vector vagin a la posició inicial, caldrà abans desplaçar la resta d'elements una posició a la dreta:

Contingut inicial del vector:

\begin{verbatim}
[element2] [element5] [element1] [element7]
\end{verbatim}

Abans d'afegir el nou \texttt{element6}, caldrà desplaçar tots els elements una posició cap a la dreta, per tal de fer un buit a l'inici:

\begin{verbatim}
[........] [element2] [element5] [element1] [element7]
\end{verbatim}

Ara ja es pot afegir l'element6 a la primera posició del vector:

\begin{verbatim}
[element6] [element2] [element5] [element1] [element7]
\end{verbatim}

\textbf{Important}: com a darrer pas, incrementar en 1 l'atribut que conté la mida de la taula.

\hypertarget{esborrar-un-element}{%
\subsection{Esborrar un element}\label{esborrar-un-element}}

Quan volem eliminar un element d'un vector també es pot produir un desplaçament d'elements. Per exemple:

Contingut inicial del vector:

\begin{verbatim}
[element2] [element5] [element1] [element7]
\end{verbatim}

Per eliminar l'\texttt{element5} simplement desplacem la resta d'elements que van a continuació una posició cap a l'esquerra:

\begin{verbatim}
[element2] [element1] [element7]
\end{verbatim}

\textbf{Important}: com a darrer pas, decrementar en 1 l'atribut que conté la mida de la taula.

\hypertarget{exemple-diessetmana}{%
\subsection{Exemple: diesSetmana}\label{exemple-diessetmana}}

A continuació s'adjunta un exemple inventat per consolidar l'explicació anterior: la idea és que pugueu comparar la inserció d'elements a una taula com hem fet habitualment fins ara (afegits al final de tot), amb una altra acció que permet afegir de forma ordenada els elements a la taula. En aquesta segona inserció caldrà anar realitzant desplaçaments cap a la dreta dels elements del vector de la taula per tal que vagin quedant ordenats.

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}string.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Definició de constants */}
\PreprocessorTok{\#define MAX\_DIES 7}
\PreprocessorTok{\#define MAX\_NOM 9+1}

\CommentTok{/* Definició de la tupla tDia */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ nom[MAX\_NOM];}
    \DataTypeTok{int}\NormalTok{ id;}
\NormalTok{\} tDia;}

\CommentTok{/* Definició de la taula tSetmana */}
\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tDia dies[MAX\_DIES];}
    \DataTypeTok{int}\NormalTok{ numDies;}
\NormalTok{\} tSetmana;}

\CommentTok{/* Predeclaració de les accions */}

\CommentTok{/* Acció que inicialitza la taula tSetmana,}
\CommentTok{ * tot posant l\textquotesingle{}atribut numDies a 0 }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ inicialitzar(tSetmana *setmana);}

\CommentTok{/* Acció que afegeix un element de tipus tDia}
\CommentTok{ * a la taula tSetmana }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ afegirDia(tSetmana *setmana, tDia dia);}

\CommentTok{/* Acció que afegeix un element de tipus tDia}
\CommentTok{ * a la taula tSetmana de forma ordenada }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ afegirDiaOrdenat(tSetmana *setmana, tDia dia);}

\CommentTok{/* Acció que copia el contingut d\textquotesingle{}un tDia origen (src)}
\CommentTok{ * a un tDia destí (dst) }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ copiarDia(tDia *dst, tDia src);}

\CommentTok{/* Acció que mostra per pantalla el contingut}
\CommentTok{ * de la taula tSetmana }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ mostrar(tSetmana setmana);}

\CommentTok{/* Programa principal */}
\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
    \CommentTok{/* Definim les variables */}
\NormalTok{    tSetmana setmana, setmanaOrdenada;}
\NormalTok{    tDia dl, dm, dc, dj, dv, ds, dg; }
    
    \CommentTok{/* Inicialitzem les variables de tipus tDia */}
\NormalTok{    strcpy(dl.nom, }\StringTok{"dilluns"}\NormalTok{);}
\NormalTok{    dl.id = }\DecValTok{1}\NormalTok{;}
\NormalTok{    strcpy(dm.nom, }\StringTok{"dimarts"}\NormalTok{);}
\NormalTok{    dm.id = }\DecValTok{2}\NormalTok{;}
\NormalTok{    strcpy(dc.nom, }\StringTok{"dimecres"}\NormalTok{);}
\NormalTok{    dc.id = }\DecValTok{3}\NormalTok{;}
\NormalTok{    strcpy(dj.nom, }\StringTok{"dijous"}\NormalTok{);}
\NormalTok{    dj.id = }\DecValTok{4}\NormalTok{;}
\NormalTok{    strcpy(dv.nom, }\StringTok{"divendres"}\NormalTok{);}
\NormalTok{    dv.id = }\DecValTok{5}\NormalTok{;}
\NormalTok{    strcpy(ds.nom, }\StringTok{"dissabte"}\NormalTok{);}
\NormalTok{    ds.id = }\DecValTok{6}\NormalTok{;}
\NormalTok{    strcpy(dg.nom, }\StringTok{"diumenge"}\NormalTok{);}
\NormalTok{    dg.id = }\DecValTok{7}\NormalTok{;}
    
    \CommentTok{/* Inicialitzem les variables de tipus}
\CommentTok{     * tSetmana }
\CommentTok{     */}
\NormalTok{    inicialitzar(\&setmana);}
\NormalTok{    inicialitzar(\&setmanaOrdenada);}
    
    \CommentTok{/* Afegim sense ordre les variables}
\CommentTok{     * tDia dins de les taules setmana}
\CommentTok{     * i setmanaOrdenada. La diferència}
\CommentTok{     * entre elles serà el mètode utilitzat}
\CommentTok{     * per inserir els tDia: mentre que }
\CommentTok{     * la inserció per setmana serà }
\CommentTok{     * l\textquotesingle{}habitual d\textquotesingle{}afegir com a darrer}
\CommentTok{     * element de la taula, per la }
\CommentTok{     * setmanaOrdenada utilitzarem l\textquotesingle{}acció}
\CommentTok{     * afegirDiaOrdenat()}
\CommentTok{     */}
\NormalTok{    afegirDia(\&setmana, dj);}
\NormalTok{    afegirDia(\&setmana, dl);}
\NormalTok{    afegirDia(\&setmana, dc);}
\NormalTok{    afegirDia(\&setmana, dg);}
\NormalTok{    afegirDia(\&setmana, ds);}
\NormalTok{    afegirDia(\&setmana, dm);}
\NormalTok{    afegirDia(\&setmana, dv);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dj);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dl);    }
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dc);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dg);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, ds);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dm);}
\NormalTok{    afegirDiaOrdenat(\&setmanaOrdenada, dv);}

\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Setmana sense ordenar : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    mostrar(setmana);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Setmana ordenada : }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    mostrar(setmanaOrdenada);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les accions */}

\DataTypeTok{void}\NormalTok{ inicialitzar(tSetmana *setmana) \{}
\NormalTok{    setmana{-}\textgreater{}numDies = }\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ afegirDia(tSetmana *setmana, tDia dia) \{}
    \CommentTok{/* numDies conté el número d\textquotesingle{}elements }
\CommentTok{     * de tipus tDia que conté la taula }
\CommentTok{     * tSetmana en cada moment }
\CommentTok{     */}
\NormalTok{    copiarDia(\&setmana{-}\textgreater{}dies[setmana{-}\textgreater{}numDies], dia);}

    \CommentTok{/* Una vegada assignat un element nou }
\CommentTok{     * tDia a la taula, incrementem el valor }
\CommentTok{     * de numDies }
\CommentTok{     */}
\NormalTok{    setmana{-}\textgreater{}numDies = setmana{-}\textgreater{}numDies + }\DecValTok{1}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Acció que afegeix un element de tipus tDia}
\CommentTok{ * a la taula tSetmana de forma ordenada }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ afegirDiaOrdenat(tSetmana *setmana, tDia dia) \{}
    
    \DataTypeTok{int}\NormalTok{ i, j;}
    \DataTypeTok{bool}\NormalTok{ isAfegit;}
    
\NormalTok{    isAfegit = false;}
\NormalTok{    i = }\DecValTok{0}\NormalTok{;}
    
    \CommentTok{/* Per fer l\textquotesingle{}ordenació s\textquotesingle{}utilitzarà el camp}
\CommentTok{     * id de tDia }
\CommentTok{     */}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} setmana{-}\textgreater{}numDies \&\& !isAfegit; i++) \{}
        
        \CommentTok{/* Si l\textquotesingle{}id del tDia de la tSetmana \textgreater{} id del}
\CommentTok{         * paràmetre dia, a partir d\textquotesingle{}aquest punt }
\CommentTok{         * caldrà desplaçar les tuples tDia cap }
\CommentTok{         * a la dreta. L\textquotesingle{}objectiu és aconseguir un}
\CommentTok{         * lloc lliure, on s\textquotesingle{}afegirà el tDia dia }
\CommentTok{         * passat com a paràmetre a l\textquotesingle{}acció}
\CommentTok{         */}
        \ControlFlowTok{if}\NormalTok{ (setmana{-}\textgreater{}dies[i].id \textgreater{} dia.id) \{}
            
            \CommentTok{/* Desplaçament dels tDia cap a la dreta, a}
\CommentTok{             * partir de la posició on caldrà afegir }
\CommentTok{             * el paràmetre dia passat per valor }
\CommentTok{             */}
            \ControlFlowTok{for}\NormalTok{ (j = setmana{-}\textgreater{}numDies; j \textgreater{} i; j{-}{-}) \{}
\NormalTok{                copiarDia(\&setmana{-}\textgreater{}dies[j], setmana{-}\textgreater{}dies[j{-}}\DecValTok{1}\NormalTok{]);    }
\NormalTok{            \}}
            
            \CommentTok{/* S\textquotesingle{}afegeix el paràmetre dia a la }
\CommentTok{             * posició que li correspon, una vegada}
\CommentTok{             * desplaçats la resta de tuples tDia }
\CommentTok{             * cap a dreta }
\CommentTok{             */}
\NormalTok{            copiarDia(\&setmana{-}\textgreater{}dies[j], dia);}
\NormalTok{            setmana{-}\textgreater{}numDies = setmana{-}\textgreater{}numDies + }\DecValTok{1}\NormalTok{;}
\NormalTok{            isAfegit = true;}
\NormalTok{        \}}
\NormalTok{    \}}

    \CommentTok{/* Si en aquest punt encara no s\textquotesingle{}ha }
\CommentTok{     * afegit el tDia, significa que ha d\textquotesingle{}anar}
\CommentTok{     * al final de tot de la taula tSetmana }
\CommentTok{     */}
    \ControlFlowTok{if}\NormalTok{ (!isAfegit) \{}
\NormalTok{        copiarDia(\&setmana{-}\textgreater{}dies[i], dia);}
\NormalTok{        setmana{-}\textgreater{}numDies = setmana{-}\textgreater{}numDies + }\DecValTok{1}\NormalTok{;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ copiarDia(tDia *dst, tDia src) \{    }
\NormalTok{    dst{-}\textgreater{}id = src.id; }
\NormalTok{    strcpy(dst{-}\textgreater{}nom, src.nom);}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ mostrar(tSetmana setmana) \{}
    \DataTypeTok{int}\NormalTok{ i;}
    \ControlFlowTok{for}\NormalTok{ (i = }\DecValTok{0}\NormalTok{; i \textless{} setmana.numDies; i++) \{}
\NormalTok{        printf(}\StringTok{"\%s}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, setmana.dies[i].nom);}
\NormalTok{    \}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

L'execució del programa genera la següent sortida:

\includegraphics{./img/play.png}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{Setmana sense ordenar : }
\NormalTok{dijous}
\NormalTok{dilluns}
\NormalTok{dimecres}
\NormalTok{diumenge}
\NormalTok{dissabte}
\NormalTok{dimarts}
\NormalTok{divendres}

\NormalTok{Setmana ordenada : }
\NormalTok{dilluns}
\NormalTok{dimarts}
\NormalTok{dimecres}
\NormalTok{dijous}
\NormalTok{divendres}
\NormalTok{dissabte}
\NormalTok{diumenge}
\end{Highlighting}
\end{Shaded}

\hypertarget{pr2}{%
\chapter{PR2}\label{pr2}}

\hypertarget{exemple-pilacartes}{%
\section{Exemple: pilaCartes}\label{exemple-pilacartes}}

A continuació s'exposa un exemple on, donada una pila de cartes inicial, el que volem és codificar l'acció \texttt{separarDiamants} que ens permeti separar de la pila totes aquelles que són \texttt{DIAMANTS}, afegint-les a una nova pila de cartes \texttt{DIAMANTS}.

Exemple: si inicialment tenim la pila1:

\begin{verbatim}
[Q] de PIQUES
[5] de DIAMANTS
[J] de TREVOLS
[A] de DIAMANTS
[3] de CORS
\end{verbatim}

Volem que d'una banda la pila1 contingui totes les cartes que no són \texttt{DIAMANTS}:

\begin{verbatim}
[3] de CORS
[J] de TREVOLS
[Q] de PIQUES
\end{verbatim}

I d'altra banda una nova pila2 amb totes les cartes \texttt{DIAMANTS}:

\begin{verbatim}
[A] de DIAMANTS
[5] de DIAMANTS
\end{verbatim}

S'han afegit comentaris dins el codi per facilitar la seva comprensió:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}
\PreprocessorTok{\#include }\ImportTok{\textless{}stdbool.h\textgreater{}}

\CommentTok{/* Definició del model de cartes segons l\textquotesingle{}enllaç:}
\CommentTok{   https://ca.wikipedia.org/wiki/Joc\_de\_cartes\#Joc\_de\_cartes\_francès */}

\PreprocessorTok{\#define MAX\_CARTES 54+1}

\CommentTok{/* El terme "coll"" equival a "baraja" */}
\KeywordTok{typedef} \KeywordTok{enum}\NormalTok{ \{DIAMANTS, PIQUES, TREVOLS, CORS\} tColl;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
    \DataTypeTok{char}\NormalTok{ valor;}
\NormalTok{    tColl coll;}
\NormalTok{\} tCarta;}

\KeywordTok{typedef} \KeywordTok{struct}\NormalTok{ \{}
\NormalTok{    tCarta A[MAX\_CARTES];}
    \DataTypeTok{int}\NormalTok{ nelem;}
\NormalTok{\} tStack;}

\CommentTok{/* Predeclaració de les accions i les funcions */}
\DataTypeTok{void}\NormalTok{ createStack(tStack *s);}
\DataTypeTok{void}\NormalTok{ push(tStack *s, tCarta e);}
\DataTypeTok{void}\NormalTok{ pop(tStack *s);}
\NormalTok{tCarta top(tStack s);}
\DataTypeTok{bool}\NormalTok{ emptyStack(tStack s);}
\DataTypeTok{bool}\NormalTok{ fullStack(tStack s);}
\DataTypeTok{void}\NormalTok{ printStack(tStack s);}
\DataTypeTok{void}\NormalTok{ separarDiamants(tStack *pilaCartes, tStack *pilaDiamants);}

\CommentTok{/* Programa principal */}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv) \{}
\NormalTok{    tCarta carta1, carta2, carta3, carta4, carta5;}
\NormalTok{    tStack pilaCartes, pilaCartesDiamants;}
    
    \CommentTok{/* Creem dues piles (reviseu el comentari inicial del bloc}
\CommentTok{     * d\textquotesingle{}implementació de les accions/funcions de la pila). }
\CommentTok{     */}
\NormalTok{    createStack(\&pilaCartes);}
\NormalTok{    createStack(\&pilaCartesDiamants);}
    
    \CommentTok{/* Definim una sèrie de cartes. */}
\NormalTok{    carta1.valor = }\CharTok{\textquotesingle{}3\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta1.coll = CORS;}
\NormalTok{    carta2.valor = }\CharTok{\textquotesingle{}A\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta2.coll = DIAMANTS;}
\NormalTok{    carta3.valor = }\CharTok{\textquotesingle{}J\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta3.coll = TREVOLS;}
\NormalTok{    carta4.valor = }\CharTok{\textquotesingle{}5\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta4.coll = DIAMANTS;}
\NormalTok{    carta5.valor = }\CharTok{\textquotesingle{}Q\textquotesingle{}}\NormalTok{;}
\NormalTok{    carta5.coll = PIQUES;}
    
    \CommentTok{/* I les afegim totes a pilaCartes */}
\NormalTok{    push(\&pilaCartes, carta1);}
\NormalTok{    push(\&pilaCartes, carta2);}
\NormalTok{    push(\&pilaCartes, carta3);}
\NormalTok{    push(\&pilaCartes, carta4);}
\NormalTok{    push(\&pilaCartes, carta5);}
    
    \CommentTok{/* Mostrem el contingut de pilaCartes per}
\CommentTok{     * pantalla, amb l\textquotesingle{}acció addicional printStack. }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Contingut de la pila \textquotesingle{}pilaCartes\textquotesingle{} :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printStack(pilaCartes);}
    
    \CommentTok{/* Ara volem separar de pilaCartes totes }
\CommentTok{     * aquelles cartes que són DIAMANTS, les quals}
\CommentTok{     * formaran part d\textquotesingle{}una nova pila de cartes. }
\CommentTok{     */}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Separem les cartes en dues piles!!}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    
    \CommentTok{/* Explicació detallada dins de la implementació}
\CommentTok{     * de l\textquotesingle{}acció. }
\CommentTok{     */}
\NormalTok{    separarDiamants(\&pilaCartes, \&pilaCartesDiamants);}
    
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Contingut de la pila \textquotesingle{}pilaCartes\textquotesingle{} sense DIAMANTS :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printStack(pilaCartes);}
\NormalTok{    printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{Contingut de la pila \textquotesingle{}pilaCartesDiamants\textquotesingle{} :}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    printStack(pilaCartesDiamants);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\CommentTok{/* Implementació de les accions/funcions de la pila: s\textquotesingle{}ha fet un copy/paste}
\CommentTok{ * de la codificació C de l\textquotesingle{}exemple 19\_04 de la xWiki, canviant}
\CommentTok{ * el genèric "elem" per "tCarta". }
\CommentTok{ *}
\CommentTok{ * !!! Atenció !!!: hi poden haver diferències amb funcions/accions }
\CommentTok{ * que us demanen a la PR2. De cara a la PR2 heu de codificar aquests}
\CommentTok{ * mètodes segons les indicacions de l\textquotesingle{}enunciat. }
\CommentTok{ */}

\DataTypeTok{void}\NormalTok{ createStack(tStack *s) \{}
\NormalTok{    s{-}\textgreater{}nelem=}\DecValTok{0}\NormalTok{;}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ push(tStack *s, tCarta e) \{}
    \ControlFlowTok{if}\NormalTok{ (s{-}\textgreater{}nelem == MAX\_CARTES) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Full stack }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        s{-}\textgreater{}A[s{-}\textgreater{}nelem]=e; }\CommentTok{/* first position in C is 0 */}
\NormalTok{        s{-}\textgreater{}nelem++;}
\NormalTok{    \}}
\NormalTok{\}}

\DataTypeTok{void}\NormalTok{ pop(tStack *s) \{}
    \ControlFlowTok{if}\NormalTok{ (s{-}\textgreater{}nelem == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Empty stack}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        s{-}\textgreater{}nelem{-}{-};}
\NormalTok{    \}}
\NormalTok{\}}

\NormalTok{tCarta top(tStack s) \{}
\NormalTok{    tCarta e;}
    \ControlFlowTok{if}\NormalTok{ (s.nelem == }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        printf(}\StringTok{"}\SpecialCharTok{\textbackslash{}n}\StringTok{ Empty stack }\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
\NormalTok{    \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{        e = s.A[s.nelem{-}}\DecValTok{1}\NormalTok{];}
\NormalTok{    \}}
    \ControlFlowTok{return}\NormalTok{ e;}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ emptyStack(tStack s) \{}
    \ControlFlowTok{return}\NormalTok{ (s.nelem == }\DecValTok{0}\NormalTok{);}
\NormalTok{\}}

\DataTypeTok{bool}\NormalTok{ fullStack(tStack s) \{}
    \ControlFlowTok{return}\NormalTok{ (s.nelem == MAX\_CARTES);}
\NormalTok{\}}

\CommentTok{/* Acció addicional que mostra per pantalla tots }
\CommentTok{ * els elements d\textquotesingle{}una pila. }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ printStack(tStack s) \{}
    
\NormalTok{    tCarta cartaAux;}
    
    \ControlFlowTok{while}\NormalTok{ (s.nelem \textgreater{} }\DecValTok{0}\NormalTok{) \{}
\NormalTok{        cartaAux = s.A[s.nelem{-}}\DecValTok{1}\NormalTok{]; }
        \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == DIAMANTS) \{}
\NormalTok{            printf(}\StringTok{"  [\%c] de DIAMANTS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == PIQUES) \{}
\NormalTok{            printf(}\StringTok{"  [\%c] de PIQUES}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == TREVOLS) \{}
\NormalTok{            printf(}\StringTok{"  [\%c] de TREVOLS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \} }\ControlFlowTok{else} \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == CORS) \{}
\NormalTok{            printf(}\StringTok{"  [\%c] de CORS}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{, cartaAux.valor);}
\NormalTok{        \}}
\NormalTok{        s.nelem{-}{-};}
\NormalTok{    \}}
\NormalTok{\}}

\CommentTok{/* Acció que rep dos paràmetres:}
\CommentTok{ * {-} pilaCartes (inout)}
\CommentTok{ * {-} pilaDiamants (out)}
\CommentTok{ * Aquesta acció separa de pilaCartes (inout) aquelles}
\CommentTok{ * cartes amb coll DIAMANTS, i les afegeix a}
\CommentTok{ * pilaDiamants (out). Així una vegada executada l\textquotesingle{}acció, tindrem:}
\CommentTok{ * {-} pilaCartes: contindrà totes les cartes que no són DIAMANTS.}
\CommentTok{ * {-} pilaDiamants: contindrà tots els DIAMANTS. }
\CommentTok{ */}
\DataTypeTok{void}\NormalTok{ separarDiamants(tStack *pilaCartes, tStack *pilaDiamants) \{}
    
\NormalTok{    tCarta cartaAux;}
\NormalTok{    tStack pilaNoDiamants;}
    
    \CommentTok{/* Totes les cartes inicialment estan a pilaCartes.}
\CommentTok{     * Es tracta d\textquotesingle{}anar afegint els DIAMANTS a la pilaDiamants,}
\CommentTok{     * i els que no són DIAMANTS a la pila temporal pilaNoDiamants.}
\CommentTok{     * Posteriorment assignarem pilaNoDiamants a pilaCartes (inout).}
\CommentTok{     */}
    
    \CommentTok{/* Inicialitzem la pila auxiliar. */}
\NormalTok{    createStack(\&pilaNoDiamants);}
    
    \CommentTok{/* Hem de tractar tots els elements de la pila. */}
    \ControlFlowTok{while}\NormalTok{ (!emptyStack(*pilaCartes)) \{}
\NormalTok{        cartaAux = top(*pilaCartes);}
        \ControlFlowTok{if}\NormalTok{ (cartaAux.coll == DIAMANTS) \{}
\NormalTok{            push(pilaDiamants, cartaAux);}
\NormalTok{        \} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{            push(\&pilaNoDiamants, cartaAux);            }
\NormalTok{        \}}
        
\NormalTok{        pop(pilaCartes);}
\NormalTok{    \}}
    
    \CommentTok{/* Reassignació de la pila auxiliar pilaNoDiamants}
\CommentTok{     * a pilaCartes, que al cap i a la fi és el paràmetre}
\CommentTok{     * de tipus inout de l\textquotesingle{}acció. }
\CommentTok{     */}
\NormalTok{    *pilaCartes = pilaNoDiamants;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\hypertarget{vmware-i-codelite}{%
\chapter{VMWare i CodeLite}\label{vmware-i-codelite}}

\hypertarget{per-quuxe8-una-muxe0quina-virtual}{%
\section{Per què una màquina virtual?}\label{per-quuxe8-una-muxe0quina-virtual}}

La màquina virtual s'utilitza per tenir un entorn homogeni de programació, tant per part dels estudiants com per part dels consultors, de forma que qualsevol enunciat/solució publicat a les aules de teoria funcioni a tots els estudiants, i que tots els programes que realitzeu es comportin igual als entorns que s'utilitzaran per corregir-los.

Fa uns semestres ens vam trobar amb uns pocs casos en els quals un programa que funcionava correctament al PC d'un estudiant, fallava a l'hora de ser corregit. I també alguns enunciats que en determinats sistemes operatius / versions de compiladors C, tampoc funcionaven correctament. Per aquest motiu es va decidir utilitzar una màquina virtual.

Nosaltres no tenim forma de controlar que realment utilitzeu la FP20181 o bé un CodeLite instal·lat directament al vostre PC, però si no és així es pot donar alguna situació poc desitjable com les que he comentat.

\hypertarget{virtualbox-i-requeriments-de-virtualitzaciuxf3}{%
\section{VirtualBox i requeriments de virtualització}\label{virtualbox-i-requeriments-de-virtualitzaciuxf3}}

Per poder utilitzar VirtualBox és necessari que disposi d'accés a l'opció de virtualització. Si no és així, es poden obtenir errors del tipus: \textbf{VT-X está deshabilitado en el BIOS para todos los CPUs}.

L'error es pot produir per vàries raons:

\begin{itemize}
\tightlist
\item
  La BIOS del PC té deshabilitada l'opció. Per solucionar-ho, cal entrar dins de la BIOS del PC i trobar l'opció d'activació de la virtualització (varia segons el fabricant): pot ser \textbf{VT-x}, \textbf{Virtualization Technology}, \textbf{VT-x/AMD-V}, \textbf{Intel Virtual Technology}, \textbf{Tecnología de virtualización (VTx/VTd)}, etc.
\item
  Tenim actiu un antivirus el qual té activada una virtualització pròpia que entra en conflicte amb la requerida per VirtualBox. En aquest cas, únicament cal desactivar l'opció de virtualització de l'antivirus.
\end{itemize}

\hypertarget{com-installar-les-guest-additions}{%
\section{Com instal·lar les Guest Additions}\label{com-installar-les-guest-additions}}

Les \textbf{Guest Additions} són una sèrie de drivers que milloren la interacció entre host i màquina virtual. Per instal·lar-les únicament cal fer:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Engegar la màquina virtual \textbf{FP20181}
\item
  Anar a la barra de menú superior -\textgreater{} \textbf{VirtualBox} -\textgreater{} \textbf{Devices} -\textgreater{} \textbf{Insert Guest Additions CD Image\ldots{}} -\textgreater{} instal·larà una unitat de CD amb les \textbf{Guest Additions}.
\item
  Obrir un terminal des de \textbf{Lubuntu} -\textgreater{} \textbf{System Tools} -\textgreater{} \textbf{LXTerminal}
\item
  Dins del terminal \textbf{LXTerminal} executar el següent (la versió que s'estigui instal·lant pot ser més nova que la 6.0.12):
\end{enumerate}

\begin{verbatim}
cd /media/uoc/VBox_GAs_6.0.12/     
sudo sh ./VBoxLinuxAdditions.run
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Reiniciar la \textbf{FP20181} per activar les \textbf{Guest Additions}.
\end{enumerate}

\hypertarget{primers-passos-amb-codelite}{%
\section{Primers passos amb CodeLite}\label{primers-passos-amb-codelite}}

A les xWiki trobareu el mòdul \textbf{Introducció a l'entorn de programació CodeLite}, en el qual es detallen els passos a realitzar per preparar l'entorn.

A continuació es resumeixen una sèrie d'aspectes que es comenten a la xWiki i que són importants recordar:

\begin{itemize}
\tightlist
\item
  Un \textbf{workspace} de CodeLite és una agrupació de projectes.
\item
  Únicament es pot tenir un \textbf{workspace} obert dins de CodeLite.
\item
  Per crear un \textbf{workspace}: \textbf{CodeLite} -\textgreater{} \textbf{Workspace} -\textgreater{} \textbf{New Workspace\ldots{}} -\textgreater{} \textbf{Workspace type:} \texttt{C++} -\textgreater{} \textbf{Workspace name}: el que correspongui; \textbf{Workspace Path}: \texttt{/home/uoc/Documents/codelite/workspaces/} (o qualsevol altre) -\textgreater{} fi
\item
  Com que no es pot tenir més d'un \textbf{workspace} obert, no en podreu crear cap de nou si prèviament no tanqueu el workspace actiu. Si dins del menú de CodeLite veieu la opció \textbf{New Workspace} en gris i que no es pot seleccionar, significa que ja teniu un workspace obert. Per tancar-lo: \textbf{CodeLite} -\textgreater{} \textbf{Workspace} -\textgreater{} \textbf{Close Workspace}.
\item
  Per afegir un projecte a un workspace: \textbf{CodeLite} -\textgreater{} \textbf{File} -\textgreater{} \textbf{New} -\textgreater{} \textbf{New Project} -\textgreater{} de tipus \textbf{Console}: \texttt{Simple\ executable\ (gcc)} -\textgreater{} \textbf{Project name}: el que correspongui -\textgreater{} \textbf{Compiler}: \texttt{GCC}; \textbf{Debugger}: \texttt{GNU\ gdb\ debugger} -\textgreater{} fi
\item
  El projecte que acabem de crear conté un programa \texttt{hello\ world} de mostra, que si executem mostra el missatge \emph{``hello world''} per pantalla. Aquest programa en C el podem editar i afegir/treure tot allò que volem. És aquí dins on hem de codificar els nostres programes en C (\textbf{no} els algorismes!).
\item
  Si tenim més d'un projecte dins d'un workspace, la forma que tenim per indicar quin d'ells és el que està actiu és fent \textbf{doble clic} sobre el nom del projecte. Veureu que el nom queda remarcat en \textbf{\emph{negreta i cursiva}}: a partir d'aquest moment, aquest serà el projecte que compilarem i executarem des de les opcions del menú de CodeLite. Tot i que estiguem visualitzant per pantalla el codi d'un altre projecte, la compilació i execució sempre es farà del projecte actiu.
\item
  Per mostrar la barra d'eines (icones) a la part superior: \textbf{CodeLite} -\textgreater{} \textbf{View} -\textgreater{} \textbf{Show toolbar}.
\item
  La icona del \textbf{play} de color verd cap a la dreta de la toolbar és per \textbf{debuggar}, no per compilar.
\item
  Per compilar i executar podem fer: \textbf{CodeLite} -\textgreater{} \textbf{Build} -\textgreater{} \textbf{Build and run project}. També es pot compilar amb la icona de la toolbar de la fletxa blanca avall amb fons verd, i executar amb la icona de les rodes dentades grises.
\item
  El resultat de l'execució del programa es mostrarà en una pantalla nova tipus terminal. És important anar tancant aquestes finestres una vegada ja hem comprovat el resultat de l'execució.
\end{itemize}

\hypertarget{com-activar-un-projecte}{%
\section{Com activar un projecte}\label{com-activar-un-projecte}}

Dins de CodeLite, a la part esquerra es mostren tots els projects que s'han creat al workspace. Si ens fixem en el nom de tots ells, veurem que un està remarcat en negreta; per exemple podem tenir:

\begin{itemize}
\tightlist
\item
  PAC01
\item
  \textbf{PAC02}
\item
  PAC03
\item
  PAC04
\end{itemize}

Això significa que quan anem a \textbf{CodeLite} --\textgreater{} \textbf{Build} --\textgreater{} \textbf{Build and Run Project}, s'executarà l'acció sobre el project \textbf{PAC02}, tot i que per pantalla s'estigui mostrant el codi d'un altre project.

Si es fa \textbf{doble clic} amb el ratolí sobre el nom del project \textbf{PAC04}, ara veurem:

\begin{itemize}
\tightlist
\item
  PAC01
\item
  PAC02
\item
  PAC03
\item
  \textbf{PAC04}
\end{itemize}

A partir d'aquest moment, el \textbf{Build and Run Project} s'aplicarà sobre \textbf{PAC04}.

\hypertarget{canviar-idioma-del-teclat}{%
\section{Canviar idioma del teclat}\label{canviar-idioma-del-teclat}}

Per canviar l'idioma del teclat a LLubuntu, cal clicar amb el botó dret del ratolí sobre la barra grisa superior -\textgreater{} \textbf{Add/Remove Panel Items} -\textgreater{} pestanya \textbf{Panel Applets} -\textgreater{} botó \textbf{Add} -\textgreater{} seleccionas el plugin \textbf{Keyboard Layout Handler} -\textgreater{} \textbf{Add} -\textgreater{} \textbf{Close}.

En aquests moments a la part superior dreta es mostrarà l'idioma definit per defecte pel teclat -\textgreater{} marcar sobre la bandera amb el botó dret -\textgreater{} \textbf{``Keyboard Layout Handler'' settings} -\textgreater{} desmarcar l'opció \textbf{Keep system layout} -\textgreater{} es pot afegir l'idioma que es vulgui des del botó \textbf{Add}; es pot prioritzar un idioma o l'altre posant-lo en primera posició a la llista. Una vegada s'hagi guardat la configuració desitjada, ja haurà canviat la disposició del teclat al nou idioma.

Si s'han deixat definits varis idiomes a la llista, cada vegada que marqueu sobre la bandera de la part superior dreta, farà un canvi a l'altre idioma de la llista.

\hypertarget{programa-per-defecte-al-crear-un-projecte}{%
\section{Programa per defecte al crear un projecte}\label{programa-per-defecte-al-crear-un-projecte}}

Cada vegada que es crea un nou projecte a CodeLite, per defecte sempre conté el codi del programa \texttt{hello\ world}:

\includegraphics{./img/c.png}

\begin{Shaded}
\begin{Highlighting}[]
\PreprocessorTok{\#include }\ImportTok{\textless{}stdio.h\textgreater{}}

\DataTypeTok{int}\NormalTok{ main(}\DataTypeTok{int}\NormalTok{ argc, }\DataTypeTok{char}\NormalTok{ **argv)}
\NormalTok{\{}
\NormalTok{    printf(}\StringTok{"hello world}\SpecialCharTok{\textbackslash{}n}\StringTok{"}\NormalTok{);}
    \ControlFlowTok{return} \DecValTok{0}\NormalTok{;}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

Per tant, quan volem crear el nostre propi programa, només cal esborrar el programa que crea per defecte i començar a codificar el teu programa nou.

Si malgrat tot no es vol que es mostri aquest codi cada vegada, podem modificar el codi per defecte associat als nous projectes:

\begin{itemize}
\tightlist
\item
  Editar l'arxiu \texttt{/usr/share/codelite/templates/projects/executable/main.cpp}, que és el que es carrega per defecte en crear cada nou projecte.
\item
  Crear un nou template de CodeLite i utilitzar-lo en el moment de crear un nou projecte. La creació d'un nou templates es fa a partir d'un projecte que tinguem -\textgreater{} botó dret sobre el nom del projecte -\textgreater{} \texttt{Save\ as\ template...}.
\end{itemize}

\hypertarget{com-fixar-el-kernel-dinici-amb-lubuntu}{%
\section{Com fixar el kernel d'inici amb Lubuntu}\label{com-fixar-el-kernel-dinici-amb-lubuntu}}

Tot i ser una situació gens habitual, es pot donar el cas que Lubuntu només ens arranqui en un determinat kernel per problemes amb determinades targetes gràfiques.

Tot i que el kernel sempre es pot seleccionar en el moment d'inici de Lubuntu, podem fixar quin és el que volem utilitzar malgrat que aquest no sigui el més nou de tots. Una possible opció per fer-ho amb l'aplicació \textbf{Grub Customizer}; per instal·lar-la fem:

\begin{verbatim}
sudo add-apt-repository ppa:danielrichter2007/grub-customizer
\end{verbatim}

Ens identifiquem amb la password de l'usuari \textbf{uoc}.

A continuació, actualitzem la llista de packages de tots els repositoris:

\begin{verbatim}
sudo apt-get update
sudo apt-get install grub-customizer
\end{verbatim}

En aquest punt haurem instal·lat \textbf{Grub Customizer} dins de la màquina virtual \textbf{FP20181}: aquest programa ens permetrà confirmar exactament què hi ha definit a l'arranc grub de la màquina virtual. Per executar el programa: icona de \textbf{Lubuntu} ---\textgreater{} \textbf{System Tools} ---\textgreater{} \textbf{Grub Customizer} ---\textgreater{} posar contrasenya \textbf{uoc} ---\textgreater{} a la pestanya inicial \textbf{List configuration} es mostren tots els kernels de què disposa l'entorn en aquests moments.

Es recomanable fer una còpia prèvia de les PAC/PR que puguem tenir dins de la \textbf{FP20181} abans de canviar el kernel d'inici. Per canviar el kernel d'arranc per defecte: \textbf{Grub Customizer} -\textgreater{} pestanya \textbf{General Settings} -\textgreater{} com a \textbf{default entry}, seleccionar el kernel que funciona correctament d'entre tots els disponibles. Una vegada escollit, es prem el botó \textbf{Save} de la part superior esquerra.

Per aplicar el canvi que s'acaba de desar a l'arranc de Lubuntu cal obrir un terminal de Lubuntu des de \textbf{System Tools} -\textgreater{} \textbf{LXTerminal}, i des del terminal teclejar:

\begin{verbatim}
sudo update-grub
\end{verbatim}

Una vegada hagi finalitzat el procés, cal realitzar un reboot de la \textbf{FP20181} per tal que agafi ara per defecte el kernel escollit.

\hypertarget{altres}{%
\chapter{Altres}\label{altres}}

\hypertarget{bibliografia}{%
\section{Bibliografia}\label{bibliografia}}

Recursos gratuïts:

\begin{itemize}
\tightlist
\item
  \emph{C Notes for Professionals book}: \url{https://books.goalkicker.com/CBook/}
\item
  \emph{C Programming}: \url{https://en.wikibooks.org/wiki/C_Programming}
\item
  \emph{C Programming Boot Camp}: \url{https://www.gribblelab.org/CBootCamp/}
\item
  \emph{The C Book}: \url{https://publications.gbdirect.co.uk//c_book/}
\item
  \emph{Programming in C}: \url{http://ee.hawaii.edu/~tep/EE160/Book/PDF/Book.html}
\item
  \emph{The ANSI C Programming Language}: \url{https://www.dipmat.univpm.it/~demeio/public/the_c_programming_language_2.pdf}
\end{itemize}

\backmatter
  \bibliography{book.bib,packages.bib}

\end{document}
